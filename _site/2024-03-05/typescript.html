<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  

  <title>
    
      TypeScript &middot; React Study
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">

  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png">

  <!-- RSS -->
  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="React Study" />
</head>


  <body>
    <nav class="nav">
      <div class="nav-container">
        <a href="/">
          <h2 class="nav-title">React Study</h2>
        </a>
        <ul class="nav-social-icons">
          
          
            <li><a target="_blank" href="https://github.com/seo-minki/react-study"><i class="fab fa-github"></i></a></li>
          
          
          
        </ul>
      </div>
    </nav>

    <main>
      <div class="post">

  <div class="post-info">
    
      <time datetime="2024-03-05 00:00:00 +0900">March 05, 2024</time>
    
  </div>
  <h1 class="post-title">
    <div>TypeScript</div>
  </h1>

  <h1 id="typescript">TypeScript</h1>

<h2 id="typescript--javascript--type-check">TypeScript = JavaScript + Type Check</h2>

<ul>
  <li>TypeScript는 <strong>AltJS(Alternative JavaScript)</strong> 중 하나입니다.
    <ul>
      <li>AltJS는 ‘JavaScript 파생 언어’로, TypeScript 말고도 CoffeScript, Dart 등이 있습니다.</li>
    </ul>
  </li>
  <li>TypeScript는 <strong>JavaScript(ES5)의 Superset(상위 확장)</strong>이므로 기존의 JavaScript 문법을 그대로 사용할 수 있습니다.
    <ul>
      <li>따라서 TypeScript 실행 환경에 JavaScript를 coding하면 정상적으로 동작합니다.</li>
      <li>하지만 JavaScript 실행 환경에 TypeScript를 coding하면 동작하지 않습니다.</li>
    </ul>
  </li>
  <li>TypeScript는 ‘정적 Typing’, ES6(ECMAScript 2015)의 ‘class’와 ‘module’, ES7의 ‘Decorator’ 등을 지원합니다.</li>
</ul>

<h3 id="typescript의-type-계층-구조">TypeScript의 Type 계층 구조</h3>

<pre><code class="language-mermaid">flowchart TD

unknown --&gt; any

any --&gt; null
any --&gt; void --&gt; undefined

any --&gt; number --&gt; numberEnum --&gt; never
any --&gt; BigInt
any --&gt; boolean
any --&gt; string --&gt; stringEnum --&gt; never
any --&gt; Symbol --&gt; uniqueSymbol

any --&gt; object
object --&gt; Array --&gt; Tuple
object --&gt; function --&gt; never
</code></pre>

<hr />

<h2 id="typescript의-주요-특징--정적-typing">TypeScript의 주요 특징 : 정적 Typing</h2>

<ul>
  <li><strong>TypeScript는 정적(Static) Typing을 지원</strong>합니다.
    <ul>
      <li>정적 type 언어는 변수를 선언할 때, 변수에 할당할 값의 type에 따라 <strong>사전에 type을 명시적으로 선언(type declaration)</strong>하고, <strong>선언한 type에 맞는 값을 할당</strong>합니다.
        <ul>
          <li>type이 결정된 후에는 type을 변경할 수 없습니다.
            <ul>
              <li>잘못된 type의 값이 할당되거나 반환되면, compiler는 이를 감지해 오류를 발생시킵니다.</li>
            </ul>
          </li>
          <li>C-family(C, Java 등) 언어도 정적 typeing을 지원하는 언어입니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>JavaScript는 동적(Dynamic) Typing만을 지원</strong>합니다.
    <ul>
      <li>JavaScript는 동적 type(dynamic typed) 언어 혹은 느슨한 type(loosely typed) 언어이며, <strong>type의 사전 선언 없이, 값이 할당되는 과정에서 동적으로 type을 추론(type inference)</strong>합니다.
        <ul>
          <li>동적 type 언어는 type 추론에 의해 <strong>변수의 type이 결정된 후에도 같은 변수에 여러 type의 값을 교차하여 할당</strong>할 수 있습니다.</li>
        </ul>
      </li>
      <li>동적 typing은 사용하기 간편하지만, code를 예측하기 힘들어 예상치 못한 오류를 만들 가능성이 높습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="동적-typing과-정적-typing의-비교">동적 Typing과 정적 Typing의 비교</h3>

<h4 id="동적-typing--javascript">동적 Typing : JavaScript</h4>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JavaScript</span>
<span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>    <span class="c1">// 3</span>
<span class="nx">sum</span><span class="p">(</span><span class="dl">'</span><span class="s1">x</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">y</span><span class="dl">'</span><span class="p">);</span>    <span class="c1">// 'xy' (의도하지 않은 함수 사용 방법)</span>
</code></pre></div></div>

<ul>
  <li>함수의 의도는 2개의 number type 인수를 전달받아 합계를 반환하는 것입니다.
    <ul>
      <li>하지만 JavaScript code에는 어떤 type의 인수를 전달해야 하는지, 어떤 type의 반환 값을 return해야 하는지 명확히 기술되어 있지 않습니다.</li>
    </ul>
  </li>
  <li>함수의 인자로 string type을 넣어도 JavaScript 문법상 어떠한 문제도 없으므로, JavaScript Engine은 개발자가 의도하지 않은 동작을 그대로 실행합니다.</li>
  <li>이러한 상황이 발생한 이유는 변수나 반환 값의 type을 사전에 지정하지 않는 JavaScript의 동적 typing에 의한 것입니다.</li>
</ul>

<h4 id="정적-typing--typescript">정적 Typing : TypeScript</h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// TypeScript</span>
<span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>    <span class="c1">// 3</span>
<span class="nx">sum</span><span class="p">(</span><span class="dl">'</span><span class="s1">x</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">y</span><span class="dl">'</span><span class="p">);</span>    <span class="c1">// error TS2345: Argument of type '"x"' is not assignable to parameter of type 'number'.</span>
</code></pre></div></div>

<ul>
  <li>TypeScript는 정적 typing을 지원하므로, compile 단계에서 오류를 포착할 수 있습니다.</li>
  <li>또한 명시적인 type 지정을 통해 type에 대한 의도를 명확하게 기술할 수 있고, code의 가독성, 예측성, 안정성을 향상시킬 수 있습니다.
    <ul>
      <li>이는 대규모 project 개발에 크게 도움이 됩니다.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="typescript의-특징--객체-지향-programming-지원">TypeScript의 특징 : 객체 지향 Programming 지원</h2>

<ul>
  <li>interface, generic 등과 같은 객체 지향 programming(OOP, Object-Orientied Programming) 지원은 크고 복잡한 project의 code 기반을 쉽게 구성할 수 있도록 돕습니다.</li>
  <li>Java, C# 등의 class 기반 객체 지향 언어에 익숙한 개발자가 JavaScript Project를 수행하는 데 진입 장벽을 낮추는 효과도 있습니다.</li>
</ul>

<hr />

<h2 id="typescript의-특징--도구의-지원을-받을-수-있음">TypeScript의 특징 : 도구의 지원을 받을 수 있음</h2>

<ul>
  <li>TypeScript를 사용하면 IDE(통합 개발 환경)를 포함한 다양한 도구의 지원을 받을 수 있습니다.</li>
  <li>IDE에 type 정보를 제공함으로써, 높은 수준의 IntelliSense, Code Assist, Type Check, Refactoring 등을 지원받을 수 있습니다.
    <ul>
      <li>동적 typing은 IDE가 변수나 매개 변수, 함수 반환 값의 type을 알 수 없어, 개발 편의 기능을 지원할 수 없게 합니다.</li>
    </ul>
  </li>
  <li>도구의 지원은 대규모 project를 위한 필수 요소이기도 합니다.</li>
</ul>

<hr />

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://poiemaweb.com/">https://poiemaweb.com/</a></li>
  <li><a href="https://opentutorials.org/course/5080">https://opentutorials.org/course/5080</a></li>
</ul>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript---type-declaration-변수함수의-type-선언하기">TypeScript - Type Declaration (변수/함수의 Type 선언하기)</h1>

<h2 id="type-declaration">Type Declaration</h2>

<ul>
  <li><strong>사전에 type을 선언(type declaration)</strong>하여 변수나 함수의 type을 명시하는 작업은 code의 가독성, 예측성, 안정성을 향상시킵니다.</li>
  <li>type 선언은 강력한 type check를 가능하게 하여, ‘문법 오류’나 ‘type과 일치하지 않는 값의 할당’ 등의 <strong>기본적인 오류를 runtime 전에 검출</strong>합니다.
    <ul>
      <li><strong>compile 시점에 type과 문법을 검사</strong>합니다.</li>
    </ul>
  </li>
  <li>VisualStudioCode와 같은 도구를 사용하면, code 작성 시점에 오류를 검출할 수 있어서 개발 효율이 대폭 향상됩니다.</li>
</ul>

<hr />

<h2 id="type을-선언하는-방법">Type을 선언하는 방법</h2>

<h3 id="변수-type-선언">변수 Type 선언</h3>

<ul>
  <li>TypeScript는 변수명 뒤에 type을 명시하는 것으로 type을 선언할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">foo</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>선언한 type에 맞지 않는 값을 할당하면 compile 시점에 오류가 발생합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">bar</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>    <span class="c1">// error TS2322: Type 'true' is not assignable to type 'number'.</span>
</code></pre></div></div>

<h3 id="함수-type-선언">함수 Type 선언</h3>

<ul>
  <li>함수의 매개 변수와 반환 값에 대한 type을 선언할 수 있습니다.</li>
  <li>일반 변수와 마찬가지로 선언된 type에 일치하지 않는 값이 주어지면 오류가 발생합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 함수 선언식</span>
<span class="kd">function</span> <span class="nx">multiply1</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 함수 표현식</span>
<span class="kd">const</span> <span class="nx">multiply2</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">y</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">multiply1</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">multiply2</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">multiply1</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>    <span class="c1">// error TS2345: Argument of type 'true' is not assignable to parameter of type 'number'.</span>
</code></pre></div></div>

<hr />

<h2 id="다양한-type에-대한-선언-예시">다양한 Type에 대한 선언 예시</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* boolean */</span>
<span class="kd">let</span> <span class="nx">isDone</span><span class="p">:</span> <span class="nx">boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

<span class="cm">/* null */</span>
<span class="kd">let</span> <span class="nx">n</span><span class="p">:</span> <span class="kc">null</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

<span class="cm">/* undefined */</span>
<span class="kd">let</span> <span class="nx">u</span><span class="p">:</span> <span class="kc">undefined</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>

<span class="cm">/* number */</span>
<span class="kd">let</span> <span class="nx">decimal</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">hex</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mh">0xf00d</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">binary</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mb">0b1010</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">octal</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mo">0o744</span><span class="p">;</span>

<span class="cm">/* string */</span>
<span class="kd">let</span> <span class="nx">color</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">blue</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">color</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">red</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">myName</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="s2">`Lee`</span><span class="p">;</span>    <span class="c1">// ES6 template 문자열</span>
<span class="kd">let</span> <span class="nx">greeting</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="s2">`Hello, my name is </span><span class="p">${</span> <span class="nx">myName</span> <span class="p">}</span><span class="s2">.`</span><span class="p">;</span>    <span class="c1">// ES6 template 대입문</span>

<span class="cm">/* object */</span>
<span class="kd">const</span> <span class="nx">obj</span><span class="p">:</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{};</span>

<span class="cm">/* array */</span>
<span class="kd">let</span> <span class="nx">list1</span><span class="p">:</span> <span class="kr">any</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">two</span><span class="dl">'</span><span class="p">,</span> <span class="kc">true</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">list2</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">list3</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>    <span class="c1">// generic 배열 type</span>

<span class="cm">/* tuple */</span>
<span class="kd">let</span> <span class="nx">tuple</span><span class="p">:</span> <span class="p">[</span><span class="kr">string</span><span class="p">,</span> <span class="kr">number</span><span class="p">];</span>
<span class="nx">tuple</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">,</span> <span class="mi">10</span><span class="p">];</span>    <span class="c1">// OK</span>
<span class="nx">tuple</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">];</span>    <span class="c1">// Error</span>
<span class="nx">tuple</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="dl">'</span><span class="s1">world</span><span class="dl">'</span><span class="p">,</span> <span class="mi">100</span><span class="p">];</span>    <span class="c1">// Error</span>
<span class="nx">tuple</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>    <span class="c1">// Error</span>

<span class="cm">/* enum */</span>
<span class="kr">enum</span> <span class="nx">Color1</span> <span class="p">{</span><span class="nx">Red</span><span class="p">,</span> <span class="nx">Green</span><span class="p">,</span> <span class="nx">Blue</span><span class="p">};</span>
<span class="kd">let</span> <span class="nx">c1</span><span class="p">:</span> <span class="nx">Color1</span> <span class="o">=</span> <span class="nx">Color1</span><span class="p">.</span><span class="nx">Green</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c1</span><span class="p">);</span>    <span class="c1">// 1</span>

<span class="kr">enum</span> <span class="nx">Color2</span> <span class="p">{</span><span class="nx">Red</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">Green</span><span class="p">,</span> <span class="nx">Blue</span><span class="p">};</span>
<span class="kd">let</span> <span class="nx">c2</span><span class="p">:</span> <span class="nx">Color2</span> <span class="o">=</span> <span class="nx">Color2</span><span class="p">.</span><span class="nx">Green</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c2</span><span class="p">);</span>    <span class="c1">// 2</span>

<span class="kr">enum</span> <span class="nx">Color3</span> <span class="p">{</span><span class="nx">Red</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">Green</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">Blue</span> <span class="o">=</span> <span class="mi">4</span><span class="p">};</span>
<span class="kd">let</span> <span class="nx">c3</span><span class="p">:</span> <span class="nx">Color3</span> <span class="o">=</span> <span class="nx">Color3</span><span class="p">.</span><span class="nx">Blue</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c3</span><span class="p">);</span>    <span class="c1">// 4</span>

<span class="cm">/* any */</span>
<span class="kd">let</span> <span class="nx">notSure</span><span class="p">:</span> <span class="kr">any</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="nx">notSure</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">maybe a string instead</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">notSure</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>    <span class="c1">// okay, definitely a boolean</span>

<span class="cm">/* void */</span>
<span class="kd">function</span> <span class="nx">warnUser</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">This is my warning message</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* never */</span>
<span class="kd">function</span> <span class="nx">infiniteLoop</span><span class="p">():</span> <span class="nx">never</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">error</span><span class="p">(</span><span class="nx">message</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nx">never</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><strong>객체(<code class="highlighter-rouge">Object</code>)도 type으로 선언할 수 있으며</strong>, 이 경우에 type은 대문자로 시작합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">today</span><span class="p">:</span> <span class="nb">Date</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>    <span class="c1">// Date type</span>

<span class="kd">const</span> <span class="nx">elem</span><span class="p">:</span> <span class="nx">HTMLElement</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myId</span><span class="dl">'</span><span class="p">);</span>    <span class="c1">// HTMLElement type</span>

<span class="kd">class</span> <span class="nx">Person</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">const</span> <span class="nx">person</span><span class="p">:</span> <span class="nx">Person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">();</span>    <span class="c1">// Person type</span>
</code></pre></div></div>

<hr />

<h2 id="reference-1">Reference</h2>

<ul>
  <li><a href="https://poiemaweb.com/typescript-typing">https://poiemaweb.com/typescript-typing</a></li>
</ul>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript---type-inference-type-추론">TypeScript - Type Inference (Type 추론)</h1>

<h2 id="type-추론--compiler의-type-자동-결정-기능">Type 추론 : Compiler의 Type 자동 결정 기능</h2>

<ul>
  <li>TypeScript의 type 추론(type inference)은 <strong>code에서 type을 명시적으로 지정하지 않아도 TypeScript compiler가 자동으로 type 정보를 유추하는 기능</strong>입니다.
    <ul>
      <li><strong>type 선언을 생략하면, 값이 할당되는 과정에서 동적으로 type이 결정</strong>됩니다.</li>
      <li>TypeScript와 달리, JavaScript는 동적 type 언어이기 때문에 모든 값에 기본적으로 type 추론이 적용됩니다.</li>
    </ul>
  </li>
  <li>type 추론은 다양한 상황에서 작동하며, code의 명시성을 유지하면서도 type 선언의 번거로움을 줄여줍니다.
    <ul>
      <li>그러나 type 추론의 한계점이 드러나는 특수한 상황에서는, type 선언을 명시적으로 하는 것이 좋습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="기본-type-추론">기본 Type 추론</h3>

<ul>
  <li>변수나 상수에 초기 값을 할당할 때, TypeScript는 할당된 값의 type을 해당 변수나 상수의 type으로 추론합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">num</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>    <span class="c1">// num은 number type</span>
<span class="kd">const</span> <span class="nx">message</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, TypeScript</span><span class="dl">"</span><span class="p">;</span>    <span class="c1">// message는 string type</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>    <span class="c1">// foo는 number type</span>
<span class="nx">foo</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hi</span><span class="dl">'</span><span class="p">;</span>    <span class="c1">// Error: Type '"hi"' is not assignable to type 'number'.</span>
</code></pre></div></div>

<ul>
  <li>변수 foo에 type을 선언하지 않았으나, type 추론에 의해 변수의 type이 결정됩니다.</li>
  <li>동적 type 언어는 type 추론에 의해 변수의 type이 결정된 후에도 같은 변수에 여러 type의 값을 교차하여 할당할 수 있습니다.</li>
  <li>하지만 <strong>정적 type 언어는 type이 결정된 후에는 type을 변경할 수 없습니다.</strong></li>
  <li>TypeScript는 정적 type 언어이므로, type 추론으로 type이 결정된 이후에 다른 type의 값을 할당하면 오류가 발생합니다.</li>
</ul>

<h3 id="함수-type-추론">함수 Type 추론</h3>

<ul>
  <li>함수에서 반환 값에 대한 type을 명시하지 않으면 TypeScript는 반환되는 값들을 분석하여 반환 type을 추론합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>    <span class="c1">// 반환 type은 number로 추론됨</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="best-common-type-추론">Best Common Type 추론</h3>

<ul>
  <li>여러 type이 혼합된 배열을 생성할 때 TypeScript는 배열의 요소로 가능한 모든 type을 포함하는 “가장 근접한 공통 type(best common type)”을 추론합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">mixedArray</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="dl">"</span><span class="s2">two</span><span class="dl">"</span><span class="p">,</span> <span class="kc">true</span><span class="p">];</span>    <span class="c1">// (number | string | boolean)[] type으로 추론됨</span>
</code></pre></div></div>

<h3 id="context-typing">Context Typing</h3>

<ul>
  <li>변수나 함수에 사용된 context를 기반으로 type을 추론합니다.
    <ul>
      <li>e.g., event handler에서 event 객체의 type을 추론할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">onmousedown</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">mouseEvent</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">mouseEvent</span><span class="p">.</span><span class="nx">button</span><span class="p">);</span>    <span class="c1">// mouseEvent는 MouseEvent type으로 추론됨</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="generic-type-추론">Generic Type 추론</h3>

<ul>
  <li>generic을 사용할 때 명시적으로 type 인수를 제공하지 않으면 TypeScript는 함수의 인수나 변수의 할당 값 등을 기반으로 해당 generic type을 추론합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">identity</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">arg</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">arg</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">identity</span><span class="p">(</span><span class="dl">"</span><span class="s2">myString</span><span class="dl">"</span><span class="p">);</span>    <span class="c1">// output은 string type으로 추론됨</span>
</code></pre></div></div>

<hr />

<h2 id="type-추론이-불가능한-경우--any-type">Type 추론이 불가능한 경우 : <code class="highlighter-rouge">any</code> Type</h2>

<ul>
  <li>type 선언을 생략하고 값도 할당하지 않아서 type을 추론할 수 없으면, <strong>자동으로 <code class="highlighter-rouge">any</code> type</strong>이 됩니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">foo</span><span class="p">;</span>    <span class="c1">// let foo: any</span>

<span class="nx">foo</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">foo</span><span class="p">);</span>    <span class="c1">// string</span>

<span class="nx">foo</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">foo</span><span class="p">);</span>    <span class="c1">// boolean</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">any</code> type의 변수는 JavaScript의 <code class="highlighter-rouge">var</code> keyword로 선언된 변수처럼, <strong>어떤 type의 값도 재할당이 가능</strong>합니다.</li>
  <li>그러나 <code class="highlighter-rouge">any</code> type은 TypeScript를 사용하는 장점을 없애기 때문에, 사용하지 않는 편이 좋습니다.</li>
</ul>

<hr />

<h2 id="reference-2">Reference</h2>

<ul>
  <li><a href="https://poiemaweb.com/typescript-typing">https://poiemaweb.com/typescript-typing</a></li>
</ul>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript---type-casting-type-변환하기">TypeScript - Type Casting (Type 변환하기)</h1>

<h2 id="type-casting--type-변환하기">Type Casting : Type 변환하기</h2>

<ul>
  <li>type casting은 <strong>변수의 type을 명시적으로 변환</strong>하는 것입니다.
    <ul>
      <li>type casting은 type assertion(단언)과 비슷합니다.</li>
    </ul>
  </li>
  <li>type casting을 사용하여 compiler에게 변수의 type을 알려줄 수 있습니다.
    <ul>
      <li>TypeScript는 정적 type을 가지고 있어 compile time에 type 검사를 수행하지만, 때로는 <strong>개발자가 특정 변수의 type에 대해 더 잘 알고 있을 때</strong>가 있습니다.</li>
    </ul>
  </li>
  <li>type casting은 <strong>type의 안전성을 개발자가 관리</strong>할 수 있게 하지만, <strong>남용은 code 안정성을 해칠 수 있으므로 신중하게 사용</strong>해야 합니다.
    <ul>
      <li>type casting은 compile time에만 영향을 미치며, runtime에는 아무런 영향을 미치지 않습니다.</li>
      <li>따라서, 실제 runtime type이 casting한 type과 다를 경우 예상치 못한 오류가 발생할 수 있습니다.</li>
      <li>type casting을 사용할 때는 주의해야 하며, type guard를 사용하여 runtime에 type을 확인하는 것이 좋습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="type-casting-방법-1---operator-사용">Type Casting 방법 1 : <code class="highlighter-rouge">&lt;&gt;</code> Operator 사용</h3>

<ul>
  <li><code class="highlighter-rouge">&lt;&gt;</code> 연산자는 JavaScript의 JSX와 함께 사용할 때 충돌을 일으킬 수 있으므로, JSX를 사용하는 환경에서는 권장되지 않습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">someValue</span><span class="p">:</span> <span class="kr">any</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">this is a string</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">strLength</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="p">(</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="nx">someValue</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">&lt;string&gt;someValue</code>는 <code class="highlighter-rouge">someValue</code>를 <code class="highlighter-rouge">string</code> type으로 casting하고 있음을 나타냅니다.</li>
  <li><code class="highlighter-rouge">string</code> type으로 type casting을 했기 때문에, <code class="highlighter-rouge">.length</code> property에 안전하게 접근할 수 있습니다.</li>
</ul>

<h3 id="type-casting-방법-2--as-keyword-사용">Type Casting 방법 2 : <code class="highlighter-rouge">as</code> Keyword 사용</h3>

<ul>
  <li><code class="highlighter-rouge">as</code> keyword는 JSX와의 충돌 없이 사용할 수 있으므로, JSX를 사용하는 TypeScript 환경에서는 이 방법이 권장됩니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">someValue</span><span class="p">:</span> <span class="kr">any</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">this is a string</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">strLength</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="p">(</span><span class="nx">someValue</span> <span class="k">as</span> <span class="kr">string</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">someValue as string</code>은 <code class="highlighter-rouge">someValue</code>를 <code class="highlighter-rouge">string</code> type으로 casting하고 있음을 나타냅니다.</li>
</ul>

<hr />

<h2 id="type-casting-활용-예제--htmlinputelement">Type Casting 활용 예제 : <code class="highlighter-rouge">HTMLInputElement</code></h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">$input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">input["type="text"]</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">val</span> <span class="o">=</span> <span class="nx">$input</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>    <span class="c1">// TS2339: Property 'value' does not exist on type 'Element'.</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">document.querySelector</code> method는 <code class="highlighter-rouge">Element | null</code> type의 값을 반환합니다.</li>
  <li><code class="highlighter-rouge">$input</code>은 <code class="highlighter-rouge">Element | null</code> type이며, <code class="highlighter-rouge">$input.value</code>를 실행하면 compile 오류가 발생합니다.
    <ul>
      <li><code class="highlighter-rouge">Element</code> 또는 <code class="highlighter-rouge">null</code> type에는 <code class="highlighter-rouge">value</code>라는 property가 존재하지 않기 때문입니다.</li>
    </ul>
  </li>
  <li><strong><code class="highlighter-rouge">value</code> property는 <code class="highlighter-rouge">HTMLInputElement</code> type(<code class="highlighter-rouge">Element</code> type의 하위 type)에만 존재하므로, type casting이 필요합니다.</strong></li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 'as' keyword 사용</span>
<span class="kd">const</span> <span class="nx">$input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">input["type="text"]</span><span class="dl">'</span><span class="p">)</span> <span class="k">as</span> <span class="nx">HTMLInputElement</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">val</span> <span class="o">=</span> <span class="nx">$input</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// '&lt;&gt;' 연산자 사용</span>
<span class="kd">const</span> <span class="nx">$input</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">HTMLInputElement</span><span class="o">&gt;</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">input["type="text"]</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">val</span> <span class="o">=</span> <span class="nx">$input</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</code></pre></div></div>

<hr />

<h2 id="reference-3">Reference</h2>

<ul>
  <li><a href="https://poiemaweb.com/typescript-typing">https://poiemaweb.com/typescript-typing</a></li>
</ul>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript---type-alias-type-별칭">TypeScript - Type Alias (Type 별칭)</h1>

<h2 id="type-alias--type에-이름-붙이기">Type Alias : Type에 이름 붙이기</h2>

<ul>
  <li>type alias는 <strong>기존에 존재하는 하나 이상의 type에 새로운 이름을 부여</strong>하는, TypeScript의 강력한 type system을 활용한 기능 중 하나입니다.
    <ul>
      <li>복잡한 type 구조를 간결하게 표현하고, code의 가독성을 높일 수 있습니다.</li>
    </ul>
  </li>
  <li>type alias는 <code class="highlighter-rouge">type</code> keyword를 사용하여 정의합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span>
    <span class="nx">age</span><span class="p">?:</span> <span class="kr">number</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="type-alias의-특징">Type Alias의 특징</h3>

<ol>
  <li>
    <p><strong>재사용성</strong> : type alias를 통해 정의한 type은 project 전반에 걸쳐 재사용할 수 있어, type 관리를 용이하게 합니다.</p>
  </li>
  <li>
    <p><strong>가독성 향상</strong> : 복잡한 type을 간결하고 의미 있는 이름으로 정의할 수 있어, code의 가독성이 향상됩니다.</p>
  </li>
  <li>
    <p><strong>확장성 제한</strong> : type alias는 확장이 불가능하며, 상속이나 interface처럼 기존 type을 확장하여 새로운 type을 만들 수 없습니다.</p>
    <ul>
      <li>대신, intersection type을 사용하여 type을 결합할 수는 있습니다.</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="type-alias-사용하기">Type Alias 사용하기</h2>

<h3 id="primitive-type-alias">Primitive Type Alias</h3>

<ul>
  <li>간단한 예로, 문자열이나 숫자 같은 기본 type에 더 구체적인 이름을 부여할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">UserID</span> <span class="o">=</span> <span class="kr">number</span><span class="p">;</span>
<span class="kd">type</span> <span class="nx">UserName</span> <span class="o">=</span> <span class="kr">string</span><span class="p">;</span>

<span class="kd">type</span> <span class="nx">Str</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Lee</span><span class="dl">'</span><span class="p">;</span>    <span class="c1">// string literal type</span>

<span class="kd">let</span> <span class="nx">id</span><span class="p">:</span> <span class="nx">UserID</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">nm</span><span class="p">:</span> <span class="nx">UserName</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">simin</span><span class="dl">'</span><span class="p">;</span>

<span class="nx">id</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">;</span>    <span class="c1">// Error: Type 'string' is not assignable to type 'number'.</span>
</code></pre></div></div>

<h3 id="union-type-alias">Union Type Alias</h3>

<ul>
  <li>두 개 이상의 type을 하나로 결합한 type을 정의할 때 사용합니다.</li>
  <li>union type을 통해 변수가 여러 type 중 하나를 가질 수 있음을 명시할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">StringOrNumber</span> <span class="o">=</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">;</span>    <span class="c1">// primitive union type</span>
<span class="kd">type</span> <span class="nx">Func</span> <span class="o">=</span> <span class="p">(()</span> <span class="o">=&gt;</span> <span class="kr">string</span><span class="p">)</span> <span class="o">|</span> <span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">);</span>    <span class="c1">// function union type</span>
<span class="kd">type</span> <span class="nx">Shape</span> <span class="o">=</span> <span class="nx">Square</span> <span class="o">|</span> <span class="nx">Rectangle</span>  <span class="nx">Circle</span><span class="p">;</span>    <span class="c1">// interface union type</span>

<span class="kd">type</span> <span class="nx">Name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Lee</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">Kim</span><span class="dl">'</span><span class="p">;</span>    <span class="c1">// string literal union type</span>
<span class="kd">type</span> <span class="nx">Num</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="mi">3</span> <span class="o">|</span> <span class="mi">4</span> <span class="o">|</span> <span class="mi">5</span><span class="p">;</span>    <span class="c1">// number literal union type</span>
<span class="kd">type</span> <span class="nx">Obj</span> <span class="o">=</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span> <span class="o">|</span> <span class="p">{</span><span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">};</span>    <span class="c1">// object literal union type</span>
</code></pre></div></div>

<h3 id="tuple-type-alias">Tuple Type Alias</h3>

<ul>
  <li>고정된 길이의 배열 type을 정의할 때 사용하며, 각 요소의 type을 정확히 지정할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Point</span> <span class="o">=</span> <span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="kr">number</span><span class="p">];</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Tuple</span> <span class="o">=</span> <span class="p">[</span><span class="kr">string</span><span class="p">,</span> <span class="nx">boolean</span><span class="p">];</span>

<span class="kd">const</span> <span class="nx">tupleA</span><span class="p">:</span> <span class="nx">Tuple</span> <span class="o">=</span> <span class="p">[</span><span class="dl">''</span><span class="p">,</span> <span class="kc">true</span><span class="p">];</span>    <span class="c1">// OK</span>
<span class="kd">const</span> <span class="nx">tupleB</span><span class="p">:</span> <span class="nx">Tuple</span> <span class="o">=</span> <span class="p">[</span><span class="dl">''</span><span class="p">,</span> <span class="dl">''</span><span class="p">];</span>    <span class="c1">// Error</span>
</code></pre></div></div>

<h3 id="object-type-alias">Object Type Alias</h3>

<ul>
  <li>객체의 구조를 정의할 때 사용합니다.</li>
  <li>interface와 유사하지만, type alias를 사용하면 객체 type뿐만 아니라 다른 type들과의 조합도 가능합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Point</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">y</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">UserID</span> <span class="o">=</span> <span class="kr">number</span><span class="p">;</span>
<span class="kd">type</span> <span class="nx">UserName</span> <span class="o">=</span> <span class="kr">string</span><span class="p">;</span>

<span class="kd">type</span> <span class="nx">User</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">id</span><span class="p">:</span> <span class="nx">UserID</span><span class="p">;</span>    <span class="c1">// type alias를 type으로 지정</span>
    <span class="nl">name</span><span class="p">:</span> <span class="nx">UserName</span><span class="p">;</span>    <span class="c1">// type alias를 type으로 지정</span>
    <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="intersection-type-alias">Intersection Type Alias</h3>

<ul>
  <li>두 개 이상의 type을 모두 만족하는 새로운 type을 생성할 때 사용합니다.</li>
  <li>이를 통해 여러 type의 특성을 합칠 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Circle</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">radius</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">type</span> <span class="nx">Colorful</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">color</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">type</span> <span class="nx">ColorfulCircle</span> <span class="o">=</span> <span class="nx">Circle</span> <span class="o">&amp;</span> <span class="nx">Colorful</span><span class="p">;</span>
</code></pre></div></div>

<hr />

<h2 id="비슷하지만-다른-type-alias와-interface">비슷하지만 다른 Type Alias와 Interface</h2>

<ul>
  <li>type alias와 interface 모두 custom type을 정의하고, 정의한 custom type을 type으로 사용할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 작성 : type alias</span>
<span class="kd">type</span> <span class="nx">Person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span>
    <span class="nx">age</span><span class="p">?:</span> <span class="kr">number</span>
<span class="p">}</span>

<span class="c1">// 작성 : interface</span>
<span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
    <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span>
    <span class="nx">age</span><span class="p">?:</span> <span class="kr">number</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 사용 : type alias, interface 공통</span>
<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">as</span> <span class="nx">Person</span><span class="p">;</span>    <span class="c1">// 빈 객체를 'Person' type으로 지정</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Lee</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">address</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Seoul</span><span class="dl">'</span><span class="p">;</span>    <span class="c1">// Error</span>
</code></pre></div></div>

<ul>
  <li>작성과 사용 방법이 비슷하지만, 몇 가지 주요한 차이점이 있습니다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>기능 / 특징</th>
      <th>Type Alias</th>
      <th>Interface</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>정의 방식</strong></td>
      <td><strong><code class="highlighter-rouge">type</code> keyword</strong>를 사용하여 정의함.</td>
      <td><strong><code class="highlighter-rouge">interface</code> keyword</strong>를 사용하여 정의함.</td>
    </tr>
    <tr>
      <td><strong>확장 가능성</strong></td>
      <td><strong>확장 불가능</strong>. 새로운 type(intersection type)을 생성하여 확장해야 함.</td>
      <td><strong>확장 가능</strong>. <code class="highlighter-rouge">extends</code>를 사용하거나 같은 이름으로 추가 선언하여 확장할 수 있음.</td>
    </tr>
    <tr>
      <td><strong>재정의 및 병합</strong></td>
      <td><strong>재정의 불가능</strong>. 동일 이름으로 여러 번 선언할 수 없음.</td>
      <td><strong>자동 병합 지원</strong>. 동일 이름의 interface를 여러 번 선언하면 자동으로 병합됨.</td>
    </tr>
    <tr>
      <td><strong>Union/Intersection Type</strong></td>
      <td><strong>지원</strong>함. union type과 intersection type 사용 가능.</td>
      <td><strong>직접적으로 지원하지 않음</strong>. interface를 확장하여 유사한 기능 구현 가능.</td>
    </tr>
    <tr>
      <td><strong>Type 결합</strong></td>
      <td><strong>복잡한 type 결합에 유리</strong>함. 다양한 type을 결합한 새로운 type 정의 가능.</td>
      <td>주로 <strong>상속을 통한 확장에 유리</strong>함. 단일 상속 구조를 따름.</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>대부분의 경우, type alias와 interface는 개인적인 선호에 따라 선택하여 사용할 수 있습니다.
    <ul>
      <li>많은 개발자들이 함수형 programming paradigm과 잘 맞기 때문에 type alias를 선호합니다.
        <ul>
          <li>type alias의 풍부한 type 표현을 사용하여, type-safe한 방식으로 함수형 programming 기능(함수형 구성, 불변성 등)을 쉽게 충족시킬 수 있습니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>interface와 type alias 둘 중 하나를 반드시 사용해야 하거나, 사용하는 편이 더 나은 경우도 있습니다.</li>
</ul>

<h3 id="interface를-사용해야-할-때">Interface를 사용해야 할 때</h3>

<ul>
  <li>interface가 가지고 있는 대부분의 기능은 type alias로도 사용할 수 있지만, 예외적으로 <strong>interface의 ‘선언 병합(declaration merging)’은 type alias에서 사용할 수 없습니다.</strong></li>
  <li>따라서 기존의 library를 확장하거나 새로운 type의 spec을 작성할 때, <strong>선언 병합이 필요다면 interface를 사용</strong>해야 합니다.
    <ul>
      <li>interface의 선언 병합은 type alias에서 intersection type을 사용하여 비슷하게 구현할 수도 있습니다.</li>
    </ul>
  </li>
  <li>또한, program에 OOP의 <strong>상속 개념을 적용하는 경우, interface의 <code class="highlighter-rouge">extends</code> keyword를 사용</strong>하는 것이 type alias들을 intersection type으로 만들어 사용하는 것보다 더 낫습니다.</li>
</ul>

<h3 id="type-alias를-사용해야-할-때">Type Alias를 사용해야 할 때</h3>

<ol>
  <li>원시 type에 새로운 이름(별칭)을 생성할 때.</li>
  <li>union type, tuple type, function type, 또는 더 복잡한 type을 정의할 때.</li>
  <li>함수를 overloading할 때.</li>
  <li>mapped type, 조건부(conditional) type, type guard, 또는 기타 고급(advanced) type 기능을 사용할 때.</li>
</ol>

<ul>
  <li>interface로는 구현하기 어려운 <strong>type alias만의 고급 기능</strong>들이 있습니다.
    <ul>
      <li>e.g., 조건부(conditional) type, generic type, type guard, 고급(advanced) type 등.</li>
      <li>type alias의 고급 기능을 사용하여, 강력한 type system을 갖춘 application을 만들 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h4 id="type-alias-고급-기능-사용-예제--객체의-getter-method-자동-생성하기">Type Alias 고급 기능 사용 예제 : 객체의 Getter Method 자동 생성하기</h4>

<ul>
  <li>type alias는 interface보다 표현력이 더 풍부합니다.
    <ul>
      <li>수많은 고급 type 기능(advanced type feature)들을 interface는 지원하지 않으며, 이러한 고급 기능들은 TypeScript가 발전함에 따라 계속해서 추가되고 있습니다.</li>
    </ul>
  </li>
  <li>아래는 interface로 구현할 수 없는 고급 type 기능 구현 예제입니다.
    <ul>
      <li>모든 object type 객체에 대해서, getter method를 자동으로 생성해주는 type alias입니다.</li>
      <li>mapped type, template literal types, <code class="highlighter-rouge">keyof</code> 연산자(operator)를 사용합니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Client</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">address</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Getters</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">K</span> <span class="k">in</span> <span class="kr">keyof</span> <span class="nx">T</span> <span class="k">as</span> <span class="s2">`get</span><span class="p">${</span><span class="nx">Capitalize</span><span class="o">&lt;</span><span class="kr">string</span> <span class="o">&amp;</span> <span class="nx">K</span><span class="o">&gt;</span><span class="p">}</span><span class="s2">`</span><span class="p">]:</span>  <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">T</span><span class="p">[</span><span class="nx">K</span><span class="p">];</span>
<span class="p">};</span>

<span class="kd">type</span> <span class="nx">clientType</span> <span class="o">=</span> <span class="nx">Getters</span><span class="o">&lt;</span><span class="nx">Client</span><span class="o">&gt;</span><span class="p">;</span>
<span class="c1">// type clientType = {</span>
<span class="c1">//     getName: () =&gt; string;</span>
<span class="c1">//     getAddress: () =&gt; string;</span>
<span class="c1">// }</span>
</code></pre></div></div>

<hr />

<h2 id="reference-4">Reference</h2>

<ul>
  <li><a href="https://poiemaweb.com/typescript-alias">https://poiemaweb.com/typescript-alias</a></li>
  <li><a href="https://blog.logrocket.com/types-vs-interfaces-typescript/">https://blog.logrocket.com/types-vs-interfaces-typescript/</a></li>
</ul>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-primitive-type-원시-type">TypeScript Primitive Type (원시 Type)</h1>

<h2 id="primitive-type--원시-type">Primitive Type : 원시 Type</h2>

<ul>
  <li>TypeScript의 원시(primitive) type은 JavaScript의 원시 type을 기반으로 합니다.</li>
  <li>원시 type은 program의 기본 단위로 사용되며, <strong>직접 변경할 수 없는 불변의 값</strong>입니다.</li>
</ul>

<h3 id="number-type"><code class="highlighter-rouge">number</code> Type</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">integer</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">decimal</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mf">6.5</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><strong>모든 종류의 숫자</strong>를 나타내는 type으로 <strong>정수와 실수를 포함</strong>합니다.</li>
  <li>TypeScript는 JavaScript와 같이 별도의 정수형 타입을 제공하지 않으며, <strong>모든 숫자는 부동 소수점 값으로 처리</strong>됩니다.</li>
</ul>

<h3 id="string-type"><code class="highlighter-rouge">string</code> Type</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">firstName</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">greeting</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="s2">`Hello, </span><span class="p">${</span><span class="nx">firstName</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><strong>text data</strong>를 나타내는 type으로, 문자 data를 작은따옴표(<code class="highlighter-rouge">' '</code>), 큰따옴표(<code class="highlighter-rouge">" "</code>), 또는 backtick(<code class="highlighter-rouge">` `</code>)으로 묶어서 표현합니다.
    <ul>
      <li>backtick을 사용하면 template literal을 통해 표현식을 문자열 안에 포함시킬 수 있고, 여러 line의 문자열도 한 묶음으로 지원할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="boolean-type"><code class="highlighter-rouge">boolean</code> Type</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">isDone</span><span class="p">:</span> <span class="nx">boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><strong>논리적인 값인 <code class="highlighter-rouge">true</code>와 <code class="highlighter-rouge">false</code></strong>만을 가질 수 있는 type입니다.</li>
  <li>조건문과 제어 흐름을 결정하는 데 주로 사용됩니다.</li>
</ul>

<h3 id="undefined-type과-null-type"><code class="highlighter-rouge">undefined</code> Type과 <code class="highlighter-rouge">null</code> Type</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">u</span><span class="p">:</span> <span class="kc">undefined</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">n</span><span class="p">:</span> <span class="kc">null</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>
    <p><code class="highlighter-rouge">undefined</code>는 <strong>‘정의되지 않은 값’</strong>을, <code class="highlighter-rouge">null</code>은 <strong>‘없는 값’</strong>을 나타냅니다.</p>
  </li>
  <li>기본 설정에서는 <code class="highlighter-rouge">undefined</code>와 <code class="highlighter-rouge">null</code>을 <strong>다른 모든 type의 하위 type으로 취급</strong>합니다.
    <ul>
      <li>e.g., <code class="highlighter-rouge">number</code>나 <code class="highlighter-rouge">string</code> type의 변수에 <code class="highlighter-rouge">null</code>이나 <code class="highlighter-rouge">undefined</code>를 할당할 수 있습니다.</li>
    </ul>
  </li>
  <li>만약 <code class="highlighter-rouge">--strictNullChecks</code> 옵션을 활성화하면, <code class="highlighter-rouge">null</code>과 <code class="highlighter-rouge">undefined</code>는 <code class="highlighter-rouge">any</code>와 각각의 type들에만 할당할 수 있게 됩니다.</li>
</ul>

<h3 id="symbol-type">Symbol Type</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">sym1</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">"</span><span class="s2">key1</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">sym2</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">"</span><span class="s2">key2</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>ES2015(ES6)에서 도입된 Symbol type은 <strong>고유하고 변경 불가능</strong>한 type입니다.</li>
</ul>

<h3 id="bigint-type"><code class="highlighter-rouge">bigint</code> Type</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">big</span><span class="p">:</span> <span class="nx">bigint</span> <span class="o">=</span> <span class="mi">100</span><span class="nx">n</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">bigint</code> type은 <strong>큰 정수</strong>를 나타내기 위해 ES2020에서 도입되었습니다.
    <ul>
      <li><code class="highlighter-rouge">number</code> type으로 표현할 수 있는 범위를 넘어서는 큰 정수를 안전하게 처리할 수 있습니다.</li>
    </ul>
  </li>
  <li>
    <p><code class="highlighter-rouge">bigint</code> literal은 <strong>정수 뒤에 <code class="highlighter-rouge">n</code>을 붙여 표현</strong>합니다.</p>
  </li>
  <li><code class="highlighter-rouge">bigint</code>와 <code class="highlighter-rouge">number</code> type 간에는 직접적인 연산이 불가능합니다.
    <ul>
      <li><code class="highlighter-rouge">bigint</code>와 <code class="highlighter-rouge">number</code>가 내부적으로 다르게 처리되기 때문입니다.</li>
      <li>e.g., <code class="highlighter-rouge">bigint</code>와 <code class="highlighter-rouge">number</code>를 더하려고 하면 compiler는 오류를 발생시킵니다.</li>
    </ul>
  </li>
</ul>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-primitive-type---number-숫자">TypeScript Primitive Type - Number (숫자)</h1>

<h2 id="number숫자-type">Number(숫자) Type</h2>

<ul>
  <li>TypeScript에서 <code class="highlighter-rouge">number</code> type은 JavaScript의 <strong>숫자</strong>를 나타내는 type입니다.
    <ul>
      <li><code class="highlighter-rouge">number</code> type은 JavaScript의 모든 숫자 값(정수, 실수, <code class="highlighter-rouge">NaN</code>, <code class="highlighter-rouge">Infinity</code>, <code class="highlighter-rouge">-Infinity</code> 등)를 포함합니다.</li>
    </ul>
  </li>
</ul>

<h3 id="기본-사용법">기본 사용법</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">integer</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">float</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">hex</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mh">0xf00d</span><span class="p">;</span>    <span class="c1">// 16진수</span>
<span class="kd">let</span> <span class="nx">binary</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mb">0b1010</span><span class="p">;</span>    <span class="c1">// 2진수</span>
<span class="kd">let</span> <span class="nx">octal</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mo">0o744</span><span class="p">;</span>    <span class="c1">// 8진수</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">number</code> type 변수에는 모든 유형의 숫자를 할당할 수 있습니다.
    <ul>
      <li>10진수뿐만 아니라, 16진수, 2진수, 8진수 literal도 지원합니다.
        <ul>
          <li>JavaScript의 <code class="highlighter-rouge">number</code> type이 ‘IEEE 754 표준’을 따르기 때문입니다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="숫자-연산">숫자 연산</h3>

<ul>
  <li><code class="highlighter-rouge">number</code> type 변수들은 수학적 연산(사칙연산)이 가능합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">sum</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="nx">integer</span> <span class="o">+</span> <span class="nx">float</span><span class="p">;</span>    <span class="c1">// 더하기</span>
<span class="kd">let</span> <span class="nx">difference</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="nx">integer</span> <span class="o">-</span> <span class="nx">float</span><span class="p">;</span>    <span class="c1">// 빼기</span>
<span class="kd">let</span> <span class="nx">product</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="nx">integer</span> <span class="o">*</span> <span class="nx">float</span><span class="p">;</span>    <span class="c1">// 곱하기</span>
<span class="kd">let</span> <span class="nx">quotient</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="nx">integer</span> <span class="o">/</span> <span class="nx">float</span><span class="p">;</span>    <span class="c1">// 나누기</span>
<span class="kd">let</span> <span class="nx">remainder</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="nx">integer</span> <span class="o">%</span> <span class="nx">float</span><span class="p">;</span>    <span class="c1">// 나머지</span>
</code></pre></div></div>

<h4 id="example--안전한-나누기-연산">Example : 안전한 나누기 연산</h4>

<ul>
  <li>무한대가 반환되지 않도록 값을 검사합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">safeDivide</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">b</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">Cannot divide by zero</span><span class="dl">"</span><span class="p">);</span>
        <span class="c1">// return 0;    // 또는 기본 값 반환</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">/</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="특별한-숫자-값--nan-infinity--infinity">특별한 숫자 값 : <code class="highlighter-rouge">NaN</code>, <code class="highlighter-rouge">Infinity</code>, <code class="highlighter-rouge">-Infinity</code></h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">notANumber</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="kc">NaN</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">positiveInfinity</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="kc">Infinity</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">negativeInfinity</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="o">-</span><span class="kc">Infinity</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>TypeScript의 <strong><code class="highlighter-rouge">number</code> type은 몇 가지 특별한 값(<code class="highlighter-rouge">NaN</code>, <code class="highlighter-rouge">Infinity</code>, <code class="highlighter-rouge">-Infinity</code>)을 포함</strong>합니다.
    <ul>
      <li>이 값들은 JavaScript에서의 동작을 그대로 따릅니다.</li>
    </ul>
  </li>
  <li><strong>0으로 나누는 연산이 <code class="highlighter-rouge">Infinity</code>를 반환</strong>하고, <strong><code class="highlighter-rouge">NaN</code>이 특별한 숫자 값으로 존재하는 것</strong>은 TypeScript의 숫자 type을 다룰 때 이해해야 할 중요한 특징입니다.
    <ul>
      <li>이 특성들이 유용하게 사용될 수도 있지만, 예상치 못한 결과를 초래할 수 있으므로 programming할 때 주의해야 합니다.</li>
      <li>JavaScript와 TypeScript에서 모두 동일한 숫자 처리 방식을 사용하므로, 두 언어 모두 동일하게 적용됩니다.</li>
    </ul>
  </li>
  <li>이를 올바르게 처리하기 위해서는 특수 값들이 반환될 가능성이 있는 경우를 항상 염두에 두고, 적절한 검사 routine(<code class="highlighter-rouge">isNaN</code>, 무한대 검사 등)을 구현하는 것이 좋습니다.</li>
</ul>

<h3 id="infinity--infinity--0으로-나누는-연산의-결과"><code class="highlighter-rouge">Infinity</code>, <code class="highlighter-rouge">-Infinity</code> : 0으로 나누는 연산의 결과</h3>

<ul>
  <li>일반적인 수학에서는 값을 0으로 나눌 수 없지만, programming 언어에서는 이를 어떻게 처리할지에 대한 정의가 필요합니다.</li>
  <li>JavaScript와 TypeScript에서는 0으로 나누는 연산을 수행할 경우, <code class="highlighter-rouge">Infinity</code> 또는 <code class="highlighter-rouge">-Infinity</code>를 반환합니다.
    <ul>
      <li>‘IEEE 754 부동소수점 수 표준’을 따릅니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">positiveInfinity</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// Infinity</span>
<span class="kd">let</span> <span class="nx">negativeInfinity</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// -Infinity</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">Infinity</code> 또는 <code class="highlighter-rouge">-Infinity</code>를 사용하는 처리 방식은 runtime error를 방지하고, 연산의 결과를 계속해서 처리할 수 있게 합니다.</li>
  <li>하지만 오류를 발생시키지 않고 계산을 계속 진행할 수 있게 하기 때문에, programming logic에서는 이런 결과 값이 예상치 못한 오류를 발생시킬 수 있습니다.</li>
</ul>

<h3 id="nan--숫자가-아닌-값"><code class="highlighter-rouge">NaN</code> : 숫자가 아닌 값</h3>

<ul>
  <li><code class="highlighter-rouge">NaN</code>은 ‘Not-a-Number’의 약자로, 숫자가 아닌 값을 나타내는 특별한 숫자 값입니다.
    <ul>
      <li>숫자 연산의 결과가 유효한 숫자가 아닐 때 반환됩니다.</li>
    </ul>
  </li>
  <li>0으로 0을 나누거나, 숫자가 아닌 문자열을 숫자로 나누는 등의 연산에서 <code class="highlighter-rouge">NaN</code>이 반환됩니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">notANumber1</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">/</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// NaN</span>
<span class="kd">let</span> <span class="nx">notANumber2</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">text</span><span class="dl">"</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>    <span class="c1">// NaN</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">NaN</code>을 확인하기 위해서는 <code class="highlighter-rouge">isNaN()</code> 함수를 사용해야 합니다.
    <ul>
      <li><code class="highlighter-rouge">NaN</code>은 그 자체로 고유하기 때문에, 다른 <code class="highlighter-rouge">NaN</code> 값과도 동등하지 않습니다.</li>
      <li><code class="highlighter-rouge">NaN === NaN</code>은 <code class="highlighter-rouge">false</code>를 반환합니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kc">NaN</span> <span class="o">===</span> <span class="kc">NaN</span><span class="p">);</span>    <span class="c1">// false</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">isNaN</span><span class="p">(</span><span class="nx">result</span><span class="p">));</span>    <span class="c1">// true</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">NaN</code>을 포함하는 모든 수학 연산의 결과는 <code class="highlighter-rouge">NaN</code>입니다.
    <ul>
      <li><code class="highlighter-rouge">NaN</code>의 반환은 연산 중에 오류가 발생했다는 신호이며, 이후의 계산 결과에 영향을 미칠 수 있습니다.</li>
    </ul>
  </li>
</ul>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-primitive-type---string-문자열">TypeScript Primitive Type - String (문자열)</h1>

<h2 id="string문자-type">String(문자) Type</h2>

<ul>
  <li>TypeScript의 <code class="highlighter-rouge">string</code> type은 <strong>text data를 다루기 위해 사용</strong>됩니다.
    <ul>
      <li><code class="highlighter-rouge">string</code> type은 Unicode 문자의 sequence를 나타내며, 이를 통해 text data를 표현, 저장, 조작할 수 있습니다.</li>
    </ul>
  </li>
  <li>JavaScript와 마찬가지로, TypeScript에서 문자열은 <strong>큰따옴표(<code class="highlighter-rouge">" "</code>), 작은따옴표(<code class="highlighter-rouge">' '</code>), 또는 backtick(<code class="highlighter-rouge">` `</code>)으로 묶어 표현</strong>할 수 있습니다.
    <ul>
      <li>backtick을 사용하면 여러 line의 문자열을 한 묶음으로 표현할 수 있습니다.</li>
    </ul>
  </li>
  <li>TypeScript에서는 <strong>단일 문자(character)와 여러 문자를 포함하는 문자열(string) 사이에 구문적인 차이가 없습니다.</strong>
    <ul>
      <li>JavaScript와 TypeScript에서 문자와 문자열 사이에는 기술적으로 명확한 구분이 없습니다.
        <ul>
          <li>모든 text data가 문자열로 처리되며, 단일 문자도 길이가 1인 문자열로 취급합니다.</li>
        </ul>
      </li>
      <li>다른 programming 언어(C, Java 등)에서는 문자(<code class="highlighter-rouge">char</code>)와 문자열(<code class="highlighter-rouge">String</code>)이 별도의 data type으로 구분되기도 합니다.</li>
    </ul>
  </li>
</ul>

<h3 id="문자열-기본">문자열 기본</h3>

<ul>
  <li>문자열은 문자의 연속으로, JavaScript의 기본적인 문자열 조작 기능과 함께 사용할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">firstName</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">John</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">lastName</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Doe</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">greeting</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="s2">`Hello, </span><span class="p">${</span><span class="nx">firstName</span><span class="p">}</span><span class="s2"> </span><span class="p">${</span><span class="nx">lastName</span><span class="p">}</span><span class="s2">!`</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">greeting</span><span class="p">);</span>    <span class="c1">// "Hello, John Doe!"</span>

<span class="kd">let</span> <span class="nx">multiLine</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="s2">`
first line.
second line.
third line.
`</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="문자열-template">문자열 Template</h3>

<ul>
  <li>backtick(<code class="highlighter-rouge">`</code>)을 사용한 문자열 literal에서는, 문자열 내에 변수나 표현식의 값을 직접 삽입할 수 있는 template literal 기능을 사용할 수 있습니다.</li>
  <li>template literal을 통해 문자열을 쉽게 구성하고, code의 가독성을 높일 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">price</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mf">19.99</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">message</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="s2">`The price is: $</span><span class="p">${</span><span class="nx">price</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>    <span class="c1">// "The price is: $19.99"</span>
</code></pre></div></div>

<h3 id="문자열-method">문자열 Method</h3>

<ul>
  <li>TypeScript에서 문자열은 JavaScript의 <code class="highlighter-rouge">String</code> 객체와 동일한 method를 사용할 수 있습니다.</li>
  <li>문자열 method를 사용하여 문자열 검색, 변환, 분할 등 다양한 조작을 수행할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">myString</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, TypeScript!</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">myString</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>    <span class="c1">// 17 (길이)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">myString</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">());</span>    <span class="c1">// HELLO, TYPESCRIPT! (대문자 변환)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">myString</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">7</span><span class="p">));</span>    <span class="c1">// TypeScript! (자르기)</span>
</code></pre></div></div>

<h3 id="문자열과-unicode">문자열과 Unicode</h3>

<ul>
  <li>TypeScript의 문자열은 Unicode text를 완벽하게 지원합니다.</li>
  <li>Unicode를 지원하기 때문에 다양한 언어와 특수 문자를 문자열 내에서 자유롭게 사용할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">greetingInKorean</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">안녕하세요!</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">greetingInKorean</span><span class="p">);</span>    <span class="c1">// 안녕하세요!</span>

<span class="kd">let</span> <span class="nx">emojiString</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">😀 😃 😄 😁</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">emojiString</span><span class="p">);</span>    <span class="c1">// 😀 😃 😄 😁</span>
</code></pre></div></div>

<hr />

<h2 id="string과-string의-차이"><code class="highlighter-rouge">string</code>과 <code class="highlighter-rouge">String</code>의 차이</h2>

<ul>
  <li><code class="highlighter-rouge">string</code> type은 TypeScript가 기본으로 제공하는 원시 type인 문자열 type을 의미합니다.</li>
  <li>하지만 대문자로 시작하는 <code class="highlighter-rouge">String</code> type은 <code class="highlighter-rouge">String</code> 생성자 함수로 생성된 <code class="highlighter-rouge">String</code> wrapper 객체 type을 의미합니다.</li>
  <li>따라서 <code class="highlighter-rouge">string</code> type에 <code class="highlighter-rouge">String</code> type을 할당하면 오류가 발생합니다.
    <ul>
      <li><code class="highlighter-rouge">String</code> type에는 <code class="highlighter-rouge">string</code> type을 할당할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* String : String 생성자 함수로 생성된 String wrapper 객체 type */</span>
<span class="kd">let</span> <span class="nx">objectStr</span><span class="p">:</span> <span class="nb">String</span><span class="p">;</span>
<span class="nx">objectStr</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>    <span class="c1">// OK</span>
<span class="nx">objectStr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">String</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">);</span>    <span class="c1">// OK</span>

<span class="cm">/* string : 원시 문자열 type */</span>
<span class="kd">let</span> <span class="nx">primitiveStr</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="nx">primitiveStr</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>    <span class="c1">// OK</span>
<span class="nx">primitiveStr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">String</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">);</span>    <span class="c1">// Error : 원시 type 문자열 type에 객체를 할당하면 오류 발생</span>
<span class="c1">// Type 'String' is not assignable to type 'string'.</span>
<span class="c1">// 'string' is a primitive, but 'String' is a wrapper object. Prefer using 'string' when possible.</span>
</code></pre></div></div>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-primitive-type---boolean-참과-거짓">TypeScript Primitive Type - Boolean (참과 거짓)</h1>

<h2 id="boolean-type--truefalse">Boolean Type : True/False</h2>

<ul>
  <li><code class="highlighter-rouge">boolean</code> type은 <strong>참(<code class="highlighter-rouge">true</code>) 또는 거짓(<code class="highlighter-rouge">false</code>)의 논리적 값</strong>으로 표현됩니다.</li>
  <li>
    <p>TypeScript의 <code class="highlighter-rouge">boolean</code> type은 JavaScript의 <code class="highlighter-rouge">boolean</code> type과 동일하게 작동합니다.</p>
  </li>
  <li><code class="highlighter-rouge">boolean</code> type을 효과적으로 사용하면 program의 logic을 명확하게 표현하고 제어할 수 있습니다.
    <ul>
      <li>조건문, 제어 흐름, 논리 연산 등 program의 흐름을 결정하는 데 주로 사용됩니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">isCompleted</span><span class="p">:</span> <span class="nx">boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">isVisible</span><span class="p">:</span> <span class="nx">boolean</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="조건문에서의-boolean-사용">조건문에서의 Boolean 사용</h3>

<ul>
  <li><code class="highlighter-rouge">boolean</code> type은 조건문에서 특히 유용합니다.</li>
  <li>program의 흐름을 제어하는 데 사용되는 조건문에서는 <code class="highlighter-rouge">boolean</code> type의 표현식이나 변수가 자주 사용됩니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nx">isCompleted</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Task is completed.</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Task is not completed.</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="논리-연산자와-함께-사용하기">논리 연산자와 함께 사용하기</h3>

<ul>
  <li><code class="highlighter-rouge">boolean</code> type은 논리 연산자(<code class="highlighter-rouge">&amp;&amp;</code>, <code class="highlighter-rouge">||</code>, <code class="highlighter-rouge">!</code>)와 함께 사용될 때 더욱 강력해집니다.</li>
  <li>이를 통해 복잡한 조건을 표현하고 program의 흐름을 더 세밀하게 제어할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">isReady</span><span class="p">:</span> <span class="nx">boolean</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">isAllowed</span><span class="p">:</span> <span class="nx">boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">isReady</span> <span class="o">&amp;&amp;</span> <span class="nx">isAllowed</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">You can proceed.</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">You cannot proceed.</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isAllowed</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Access is denied.</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="boolean을-사용한-복잡한-예제--사용자-검증">Boolean을 사용한 복잡한 예제 : 사용자 검증</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">User</span> <span class="p">{</span>
    <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">hasPermission</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>
    <span class="nl">isAccountActive</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">canUserPerformAction</span><span class="p">(</span><span class="nx">user</span><span class="p">:</span> <span class="nx">User</span><span class="p">,</span> <span class="nx">actionRequiredAge</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">needsPermission</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">):</span> <span class="nx">boolean</span> <span class="p">{</span>
    <span class="c1">// 계정 활성 상태 확인</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">user</span><span class="p">.</span><span class="nx">isAccountActive</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">User's account is not active.</span><span class="dl">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 필요한 나이보다 사용자의 나이가 적은지 확인</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">user</span><span class="p">.</span><span class="nx">age</span> <span class="o">&lt;</span> <span class="nx">actionRequiredAge</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`User needs to be at least </span><span class="p">${</span><span class="nx">actionRequiredAge</span><span class="p">}</span><span class="s2"> years old.`</span><span class="p">);</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 특정 작업을 수행하기 위해 특별한 권한이 필요한지 확인</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">needsPermission</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">user</span><span class="p">.</span><span class="nx">hasPermission</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">User does not have the required permission.</span><span class="dl">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 모든 조건을 통과했다면, 사용자는 작업을 수행할 수 있음</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">user</span><span class="p">:</span> <span class="nx">User</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">age</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
    <span class="na">hasPermission</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="na">isAccountActive</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">actionRequiredAge</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">needsPermission</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

<span class="c1">// 사용자가 특정 작업을 수행할 수 있는지 여부를 결정함</span>
<span class="kd">const</span> <span class="nx">canPerform</span> <span class="o">=</span> <span class="nx">canUserPerformAction</span><span class="p">(</span><span class="nx">user</span><span class="p">,</span> <span class="nx">actionRequiredAge</span><span class="p">,</span> <span class="nx">needsPermission</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Can user perform action? </span><span class="p">${</span><span class="nx">canPerform</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
</code></pre></div></div>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-primitive-type---undefined-and-null-정의되지-않았거나-없는-값">TypeScript Primitive Type - Undefined and Null (정의되지 않았거나 없는 값)</h1>

<h2 id="undefined-type--null-type">Undefined Type &amp; Null Type</h2>

<ul>
  <li><code class="highlighter-rouge">undefined</code>는 ‘값이 정의되지 않음’을, <code class="highlighter-rouge">null</code>은 ‘값이 없음’을 명시적으로 표현합니다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Undefined</th>
      <th>Null</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>초기화가 되지 않음</td>
      <td>초기화가 된 후, 의도적으로 <code class="highlighter-rouge">null</code> 값을 할당함</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>변수에 <code class="highlighter-rouge">null</code> 또는 <code class="highlighter-rouge">undefined</code>를 할당할 수 있으며, 이는 해당 변수가 값이 없거나 정의되지 않았음을 의미합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">myVar</span><span class="p">:</span> <span class="kc">null</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">myUndefinedVar</span><span class="p">:</span> <span class="kc">undefined</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>TypeScript에는 JavaScript에는 없는 <code class="highlighter-rouge">undefined</code>와 <code class="highlighter-rouge">null</code> type에 대한 추가적인 기능들이 있으며, 이는 TypeScript가 제공하는 강력한 type system의 일부입니다.
    <ul>
      <li>e.g., <code class="highlighter-rouge">--strictNullChecks</code> option을 사용하여 type 안전성을 강화하고, optional chaining과 nullish coalescing를 활용하여 code의 안정성과 가독성을 높일 수 있습니다.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="엄격한strict-null-check----strictnullchecks-compile-option">엄격한(Strict) Null Check : <code class="highlighter-rouge">--strictNullChecks</code> Compile Option</h2>

<ul>
  <li>TypeScript에서 <code class="highlighter-rouge">--strictNullChecks</code> option은 type 안전성을 강화하기 위한 중요한 compiler 설정 중 하나입니다.
    <ul>
      <li>TypeScript project 설정에서 활성화할 수 있습니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">--strictNullChecks</code> option이 활성화되면, <code class="highlighter-rouge">null</code>과 <code class="highlighter-rouge">undefined</code>를 모든 type에서 기본적으로 허용하지 않게 되고, 오직 <code class="highlighter-rouge">any</code> type과 각각의 type(<code class="highlighter-rouge">null</code>, <code class="highlighter-rouge">undefined</code>)에만 할당할 수 있습니다.
    <ul>
      <li>변수나 함수의 반환 값 등이 <code class="highlighter-rouge">null</code> 또는 <code class="highlighter-rouge">undefined</code>일 수 있다면, 이를 명시적으로 type에 추가해야 합니다.</li>
      <li>이런 엄격한 check는 code 내에서 잠재적인 null 참조 오류를 사전에 방지하고, 더 안전하고 예측 가능한 code를 작성할 수 있도록 도와줍니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">myName</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>    <span class="c1">// 오류: --strictNullChecks가 활성화되어 있을 때, 'null'을 'string'에 할당할 수 없습니다.</span>
</code></pre></div></div>

<h3 id="--strictnullchecks-활성화의-이점"><code class="highlighter-rouge">--strictNullChecks</code> 활성화의 이점</h3>

<ol>
  <li>Type 안전성 향상 : 변수나 반환 값에 예상치 못한 <code class="highlighter-rouge">null</code> 또는 <code class="highlighter-rouge">undefined</code>가 할당되는 것을 방지하여, runtime 오류의 가능성을 줄일 수 있습니다.</li>
  <li>명시적 Type 선언 : 개발자는 <code class="highlighter-rouge">null</code>이나 <code class="highlighter-rouge">undefined</code>를 처리해야 하는 경우, 이를 명시적으로 type에 포함시켜 code의 의도를 더 명확하게 전달할 수 있습니다.</li>
  <li>Bug 조기 발견 : compile 시점에 <code class="highlighter-rouge">null</code> 또는 <code class="highlighter-rouge">undefined</code>와 관련된 잠재적 오류를 포착하여, runtime에 발생할 수 있는 bug를 사전에 제거할 수 있습니다.</li>
</ol>

<h3 id="--strictnullchecks-사용-방법"><code class="highlighter-rouge">--strictNullChecks</code> 사용 방법</h3>

<ul>
  <li><code class="highlighter-rouge">--strictNullChecks</code> option을 활성화하면, 모든 type은 기본적으로 <code class="highlighter-rouge">null</code>과 <code class="highlighter-rouge">undefined</code>를 포함하지 않습니다.</li>
  <li>따라서, 변수가 <code class="highlighter-rouge">null</code> 또는 <code class="highlighter-rouge">undefined</code>를 받을 수 있게 하려면, union type을 사용하여 명시적으로 선언해야 합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">myName</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>    <span class="c1">// 정상 작동</span>
<span class="kd">let</span> <span class="nx">myAge</span><span class="p">:</span> <span class="kr">number</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">;</span>    <span class="c1">// 'undefined'를 명시적으로 포함</span>
</code></pre></div></div>

<h3 id="--strictnullchecks-예제"><code class="highlighter-rouge">--strictNullChecks</code> 예제</h3>

<ul>
  <li>함수의 매개 변수나 반환 type도 <code class="highlighter-rouge">--strictNullChecks</code> option의 영향을 받습니다.</li>
  <li>함수가 <code class="highlighter-rouge">null</code>이나 <code class="highlighter-rouge">undefined</code>를 반환할 수 있다면, 이를 type에 포함시켜야 합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">getCustomer</span><span class="p">(</span><span class="nx">id</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="nx">Customer</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
    <span class="c1">// 고객 정보를 조회하고 결과에 따라 Customer 객체 또는 null 반환</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">foundCustomer</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">foundCustomer</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>    <span class="c1">// 명시적으로 null 반환을 허용했기 때문에 null 반환 가능</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="typescript-37-이상에서-지원하는-고급-기능--optional-chaining-nullish-coalescing">TypeScript 3.7 이상에서 지원하는 고급 기능 : Optional Chaining, Nullish Coalescing</h2>

<ul>
  <li>TypeScript 3.7에서는 ‘optional chaining(선택적 chaining)’과 ‘nullish coalescing(null 병합 연산자)’가 도입되었습니다.</li>
  <li>이 기능들은 <code class="highlighter-rouge">null</code>과 <code class="highlighter-rouge">undefined</code>를 다루는 방식을 개선하여 code의 가독성을 높이고, error를 줄이는 데 기여합니다.</li>
</ul>

<h3 id="optional-chaining---객체의-속성에-안전하게-접근하기">Optional Chaining (<code class="highlighter-rouge">?.</code>) : 객체의 속성에 안전하게 접근하기</h3>

<ul>
  <li>optional chaining(<code class="highlighter-rouge">?.</code>)은 객체의 속성에 접근할 때, 그 객체 또는 속성이 <code class="highlighter-rouge">null</code> 또는 <code class="highlighter-rouge">undefined</code>일 경우 오류가 발생하는 것을 방지하는 안전한 방법을 제공합니다.</li>
  <li>이는 객체의 속성을 참조할 때 중첩된 객체가 있고, 그 중 하나라도 <code class="highlighter-rouge">null</code> 또는 <code class="highlighter-rouge">undefined</code>일 가능성이 있을 때 매우 유용합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">obj</span><span class="p">?.</span><span class="nx">prop</span>    <span class="c1">// 객체의 속성 접근</span>
<span class="nx">obj</span><span class="p">?.[</span><span class="nx">expr</span><span class="p">]</span>    <span class="c1">// 객체의 계산된 속성 접근</span>
<span class="nx">arr</span><span class="p">?.[</span><span class="nx">index</span><span class="p">]</span>    <span class="c1">// 배열 index 접근</span>
<span class="nx">func</span><span class="p">?.(</span><span class="nx">args</span><span class="p">)</span>    <span class="c1">// 함수 호출</span>
</code></pre></div></div>

<h4 id="optional-chaining-예제">Optional Chaining 예제</h4>

<ul>
  <li><code class="highlighter-rouge">user.info?.email</code>은 <code class="highlighter-rouge">user.info</code>가 <code class="highlighter-rouge">null</code> 또는 <code class="highlighter-rouge">undefined</code>이면 평가를 중지하고 <code class="highlighter-rouge">undefined</code>를 반환합니다.
    <ul>
      <li>그렇지 않으면 <code class="highlighter-rouge">email</code> 속성에 계속 접근합니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">User</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">info</span><span class="p">?:</span> <span class="p">{</span>
        <span class="nx">email</span><span class="p">?:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">user</span><span class="p">:</span> <span class="nx">User</span> <span class="o">=</span> <span class="p">{};</span>

<span class="c1">// optional chaining을 사용하지 않는 경우</span>
<span class="kd">const</span> <span class="nx">userEmail</span> <span class="o">=</span> <span class="nx">user</span><span class="p">.</span><span class="nx">info</span> <span class="p">?</span> <span class="nx">user</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">email</span> <span class="p">:</span> <span class="kc">undefined</span><span class="p">;</span>

<span class="c1">// optional chaining을 사용하는 경우</span>
<span class="kd">const</span> <span class="nx">userEmailWithOptionalChaining</span> <span class="o">=</span> <span class="nx">user</span><span class="p">.</span><span class="nx">info</span><span class="p">?.</span><span class="nx">email</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="nullish-coalescing--">Nullish Coalescing (<code class="highlighter-rouge">??</code>) :</h3>

<ul>
  <li><code class="highlighter-rouge">??</code> 연산자(nullish coalescing)는 왼쪽 피연산자가 <code class="highlighter-rouge">null</code> 또는 <code class="highlighter-rouge">undefined</code>일 경우에만 오른쪽 피연산자의 값을 반환합니다.
    <ul>
      <li>이는 논리 OR 연산자(<code class="highlighter-rouge">||</code>)와 유사하지만, <code class="highlighter-rouge">||</code> 연산자는 <code class="highlighter-rouge">0</code>, <code class="highlighter-rouge">NaN</code>, 빈 문자열(<code class="highlighter-rouge">''</code>)을 포함한 모든 falsy 값들을 검사한다는 점이 다릅니다.</li>
      <li>‘falsy 값’은 조건문이나 논리 연산에서 <code class="highlighter-rouge">false</code>로 평가되는 <code class="highlighter-rouge">false</code>, <code class="highlighter-rouge">0</code>, <code class="highlighter-rouge">-0</code>, <code class="highlighter-rouge">0n</code>, 빈 문자열(<code class="highlighter-rouge">""</code>, <code class="highlighter-rouge">''</code>, ` `` <code class="highlighter-rouge">), </code>null<code class="highlighter-rouge">, </code>undefined<code class="highlighter-rouge">, </code>NaN` 등의 값들을 의미합니다.</li>
    </ul>
  </li>
  <li>따라서 <code class="highlighter-rouge">??</code> 연산자(nullish coalescing)는 <code class="highlighter-rouge">null</code>이나 <code class="highlighter-rouge">undefined</code>인 경우만 검사하여 값을 정하고 싶을 때 사용합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">expr1</span> <span class="o">??</span> <span class="nx">expr2</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">expr1</code>이 <code class="highlighter-rouge">null</code> 또는 <code class="highlighter-rouge">undefined</code>가 아니면 <code class="highlighter-rouge">expr1</code>의 결과가 반환되고, 그렇지 않으면 <code class="highlighter-rouge">expr2</code>의 결과가 반환됩니다.</li>
</ul>

<h4 id="nullish-coalescing-예제">Nullish Coalescing 예제</h4>

<ul>
  <li><code class="highlighter-rouge">??</code> 연산자는 <code class="highlighter-rouge">input</code> 값이 빈 문자열인 경우에도 <code class="highlighter-rouge">input</code>의 값을 유지합니다.
    <ul>
      <li><code class="highlighter-rouge">input</code>이 <code class="highlighter-rouge">null</code>이나 <code class="highlighter-rouge">undefined</code>가 아니기 때문입니다.</li>
    </ul>
  </li>
  <li>그러나 <code class="highlighter-rouge">||</code> 연산자는 <code class="highlighter-rouge">input</code>이 falsy한 값(<code class="highlighter-rouge">0</code>, <code class="highlighter-rouge">NaN</code>, <code class="highlighter-rouge">''</code> 등)일 경우, 오른쪽 피연산자(<code class="highlighter-rouge">'default'</code>)를 반환합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">input</span> <span class="o">=</span> <span class="dl">''</span><span class="p">;</span>    <span class="c1">// 빈 문자열</span>

<span class="c1">// || 연산자를 사용할 경우, 빈 문자열은 falsy한 값으로 간주되어 기본 값("default")이 사용됩니다.</span>
<span class="kd">const</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">input</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">default</span><span class="dl">'</span><span class="p">;</span>    <span class="c1">// 'default' </span>

<span class="c1">// ?? 연산자를 사용할 경우, 오직 null 또는 undefined일 때만 기본 값("default")이 사용됩니다.</span>
<span class="kd">const</span> <span class="nx">outputWithNullish</span> <span class="o">=</span> <span class="nx">input</span> <span class="o">??</span> <span class="dl">'</span><span class="s1">default</span><span class="dl">'</span><span class="p">;</span>    <span class="c1">// ''</span>
</code></pre></div></div>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-primitive-type---symbol-고유-값">TypeScript Primitive Type - Symbol (고유 값)</h1>

<h2 id="symbol-type-1">Symbol Type</h2>

<ul>
  <li>
    <p>JavaScript의 symbol type은 ES6(ES2015)에서 도입된, <strong>변경 불가능한 원시(primitive) type</strong>입니다.</p>
  </li>
  <li>각 symbol 값은 고유하며, 주로 객체 속성의 key로 사용됩니다.
    <ul>
      <li>symbol type을 사용하는 주된 목적은 이름 충돌의 위험 없이 객체에 유일한 속성들을 추가하는 것입니다.</li>
    </ul>
  </li>
  <li>
    <p>symbol을 사용하면 객체에 Metaprogramming 기능을 추가하여, JavaScript engine이 객체를 어떻게 처리해야 할지에 대한 사용자 정의 동작을 구현할 수 있습니다.</p>
  </li>
  <li>TypeScript에서 symbol type은 <code class="highlighter-rouge">Symbol()</code>로 표현합니다.
    <ul>
      <li>symbol type의 동작 방식, 사용 방법은 정적 typing을 제외하고 JavaScript와 모두 동일합니다.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="일반-symbol--symbol">일반 Symbol : <code class="highlighter-rouge">Symbol()</code></h2>

<ul>
  <li><code class="highlighter-rouge">Symbol()</code> 함수를 호출하여 symbol을 생성할 수 있으며, 선택적으로 문자열을 description 인자로 전달할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">symbol1</span><span class="p">:</span> <span class="nx">symbol</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">symbol2</span><span class="p">:</span> <span class="nx">symbol</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">description</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>각 symbol은 고유합니다.</li>
  <li>동일한 description을 가진 두 symbol을 생성해도, 두 symbol은 서로 다릅니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">symbol1</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">description</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">symbol2</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">description</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">symbol1</span> <span class="o">===</span> <span class="nx">symbol2</span><span class="p">);</span>    <span class="c1">// false</span>
</code></pre></div></div>

<h3 id="객체-속성-key로-symbol-사용하기">객체 속성 Key로 Symbol 사용하기</h3>

<ul>
  <li>symbol을 객체의 속성 key(object property key)로 사용할 때, ‘computed property names 문법’을 사용하여 객체 literal 내에서 symbol을 속성 key로 사용할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">mySymbol</span><span class="p">:</span> <span class="nx">symbol</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">mySymbol</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">obj</span><span class="p">:</span> <span class="p">{</span> <span class="p">[</span><span class="nx">key</span><span class="p">:</span> <span class="nx">symbol</span><span class="p">]:</span> <span class="kr">string</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">mySymbol</span><span class="p">]:</span> <span class="dl">'</span><span class="s1">value</span><span class="dl">'</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">mySymbol</span><span class="p">]);</span>    <span class="c1">// value</span>
</code></pre></div></div>

<ul>
  <li>symbol을 객체의 속성 key로 사용하면, 해당 속성은 열거할 수 없으며, 기본적으로는 JSON 문자열로 변환될 때 포함되지 않습니다.
    <ul>
      <li>symbol로 선언된 속성은 <code class="highlighter-rouge">for...in</code> loop나 <code class="highlighter-rouge">Object.keys()</code> method로는 찾을 수 없습니다.</li>
      <li>이러한 특성 때문에 symbol을 사용하면, 객체 내부의 ‘숨겨진(private)’ 속성을 만들 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h4 id="example--symbol을-사용한-숨겨진-속성private-property-추가">Example : Symbol을 사용한 숨겨진 속성(Private Property) 추가</h4>

<ul>
  <li>symbol을 사용하여 객체에 숨겨진 속성을 추가하고, 숨겨진 속성이 일반적인 방법으로 열거되지 않는 것을 확인하는 code입니다.</li>
  <li><code class="highlighter-rouge">Object.getOwnPropertySymbols()</code> method를 사용하여, 객체에 추가된 숨겨진 symbol 속성 key를 조회할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* symbol을 생성합니다. */</span>
<span class="kd">let</span> <span class="nx">hiddenSymbol</span><span class="p">:</span> <span class="nx">symbol</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">hiddenProperty</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">anotherSymbol</span><span class="p">:</span> <span class="nx">symbol</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">anotherProperty</span><span class="dl">'</span><span class="p">);</span>

<span class="cm">/* symbol을 속성 key로 사용하여 객체를 생성합니다. */</span>
<span class="kd">let</span> <span class="nx">myObject</span><span class="p">:</span> <span class="p">{</span> <span class="p">[</span><span class="nx">key</span><span class="p">:</span> <span class="nx">symbol</span><span class="p">]:</span> <span class="kr">any</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">hiddenSymbol</span><span class="p">]:</span> <span class="dl">'</span><span class="s1">This is a hidden message</span><span class="dl">'</span><span class="p">,</span>
  <span class="p">[</span><span class="nx">anotherSymbol</span><span class="p">]:</span> <span class="dl">'</span><span class="s1">This is another hidden message</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">visibleProperty</span><span class="p">:</span> <span class="dl">'</span><span class="s1">This is a visible message</span><span class="dl">'</span>
<span class="p">};</span>

<span class="cm">/* symbol로 선언된 속성에 접근합니다. */</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">myObject</span><span class="p">[</span><span class="nx">hiddenSymbol</span><span class="p">]);</span>    <span class="c1">// This is a hidden message</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">myObject</span><span class="p">[</span><span class="nx">anotherSymbol</span><span class="p">]);</span>    <span class="c1">// This is another hidden message</span>

<span class="cm">/* 객체의 모든 속성을 열거합니다(for...in loop). */</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">property</span> <span class="k">in</span> <span class="nx">myObject</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">property</span><span class="p">}</span><span class="s2">: </span><span class="p">${</span><span class="nx">myObject</span><span class="p">[</span><span class="nx">property</span><span class="p">]}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 출력: visibleProperty: This is a visible message</span>
<span class="c1">// Note: symbol로 선언된 속성은 출력되지 않습니다.</span>

<span class="cm">/* Object.keys()를 사용하여 속성 key를 얻습니다. */</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">myObject</span><span class="p">));</span>
<span class="c1">// 출력: ["visibleProperty"]</span>
<span class="c1">// Note: symbol로 선언된 속성 key는 포함되지 않습니다.</span>

<span class="cm">/* Object.getOwnPropertySymbols()를 사용하여 symbol 속성 key를 얻습니다. */</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertySymbols</span><span class="p">(</span><span class="nx">myObject</span><span class="p">));</span>
<span class="c1">// 출력: [Symbol(hiddenProperty), Symbol(anotherProperty)]</span>
<span class="c1">// Note: symbol 속성 key만 포함됩니다.</span>

<span class="cm">/* JSON.stringify()를 사용하여 객체를 문자열로 변환합니다. */</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">myObject</span><span class="p">));</span>
<span class="c1">// 출력: {"visibleProperty":"This is a visible message"}</span>
<span class="c1">// Note: symbol로 선언된 속성은 포함되지 않습니다.</span>
</code></pre></div></div>

<hr />

<h2 id="전역-symbol--symbolfor와-symbolkeyfor">전역 Symbol : <code class="highlighter-rouge">Symbol.for()</code>와 <code class="highlighter-rouge">Symbol.keyFor()</code></h2>

<ul>
  <li><code class="highlighter-rouge">Symbol.for()</code>와 <code class="highlighter-rouge">Symbol.keyFor()</code>는 전역 symbol registry(global symbol registry)를 사용하여 symbol을 생성하고 조회하는 기능을 제공합니다.
    <ul>
      <li><code class="highlighter-rouge">Symbol</code>을 통한 Metaprogramming 기능 중에서도, 특히 전역적인 context에서 symbol을 공유하고 재사용할 필요가 있을 때 유용하게 사용됩니다.</li>
    </ul>
  </li>
  <li>전역 symbol registry는 전역적으로 공유되어야 하는 고유한 식별자를 생성하고자 할 때 사용합니다.
    <ul>
      <li>e.g., 여러 module이나 package에서 동일한 식별자를 참조해야 하는 경우, <code class="highlighter-rouge">Symbol.for()</code>를 사용하여 동일한 symbol을 안전하게 공유할 수 있습니다.</li>
      <li>이는 이름 충돌 없이 module 간의 상호 작용을 구현하는 데 도움이 됩니다.</li>
      <li>application 전반에서 symbol 값의 일관성을 유지할 수 있으며, debugging이나 code의 이해를 돕는 데에도 유용하게 사용될 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="symbolfor--전역-symbol-생성-및-사용"><code class="highlighter-rouge">Symbol.for()</code> : 전역 Symbol 생성 및 사용</h3>

<ul>
  <li><code class="highlighter-rouge">Symbol.for()</code> method는 symbol의 고유성이 유지되면서도, 명시적으로 이름을 지정하여 전역적으로 공유할 수 있는 방법을 제공합니다.
    <ul>
      <li>전역 symbol registry를 사용하여 symbol을 생성하고 검색하는 mechanism을 제공합니다.</li>
      <li>application의 어느 부분에서든지 동일한 문자열 인자로 <code class="highlighter-rouge">Symbol.for()</code>를 호출하면, 항상 동일한 symbol instance를 반환합니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">globalSymbol1</span><span class="p">:</span> <span class="nx">symbol</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="dl">'</span><span class="s1">globalSymbol</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">globalSymbol2</span><span class="p">:</span> <span class="nx">symbol</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="dl">'</span><span class="s1">globalSymbol</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">globalSymbol1</span> <span class="o">===</span> <span class="nx">globalSymbol2</span><span class="p">);</span>    <span class="c1">// true</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">globalSymbol1</code>과 <code class="highlighter-rouge">globalSymbol2</code>는 동일한 symbol을 참조합니다.
    <ul>
      <li>두 변수가 ‘globalSymbol’이라는 동일한 key로 <code class="highlighter-rouge">Symbol.for()</code>를 호출했기 때문입니다.</li>
    </ul>
  </li>
</ul>

<h3 id="symbolkeyfor--전역-symbol의-key-확인"><code class="highlighter-rouge">Symbol.keyFor()</code> : 전역 Symbol의 Key 확인</h3>

<ul>
  <li><code class="highlighter-rouge">Symbol.keyFor()</code> method는 주어진 symbol이 전역 symbol registry에 등록되어 있다면, 해당 symbol의 key를 문자열로 반환합니다.
    <ul>
      <li><code class="highlighter-rouge">Symbol.for()</code>를 사용하여 생성한 symbol에만 적용될 수 있으며, 직접 <code class="highlighter-rouge">Symbol()</code> 생성자로 생성한 symbol에는 적용되지 않습니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">globalSymbol</span><span class="p">:</span> <span class="nx">symbol</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="dl">'</span><span class="s1">globalSymbol</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">symbolKey</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">.</span><span class="nx">keyFor</span><span class="p">(</span><span class="nx">globalSymbol</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">symbolKey</span><span class="p">);</span>    <span class="c1">// 'globalSymbol'</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">globalSymbol</code> symbol이 ‘globalSymbol’이라는 key로 전역 symbol registry에 등록되어 있기 때문에 <code class="highlighter-rouge">symbolKey</code>는 ‘globalSymbol’이라는 문자열을 반환합니다.</li>
</ul>

<hr />

<h2 id="well-known-symbol--사전-정의된-symbol">Well-Known Symbol : 사전 정의된 Symbol</h2>

<ul>
  <li>
    <p>well-known symbol은 ECMAScript 사양에 미리 정의되어 있는 ‘잘 알려진(well-known)’ symbol을 의미합니다.</p>
  </li>
  <li>well-known symbol은 객체의 표준 동작(내부적인 언어 동작)을 변경(사용자 정의)할 수 있게 하여, metaprogramming을 가능하게 합니다.
    <ul>
      <li>e.g., <code class="highlighter-rouge">Symbol.iterator</code>는 객체가 반복자 protocol을 구현하는 방법을 정의하는 데 사용됩니다.</li>
    </ul>
  </li>
  <li>다양한 Well-Known Symbol들이 있으며, 필요에 따라서 선택하여 사용합니다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Well-Known Symbol</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">Symbol.iterator</code></td>
      <td>객체가 ‘iterable’이 되게 하여 <code class="highlighter-rouge">for...of</code> loop와 같은 구문에서 사용될 수 있도록 합니다.<br /><code class="highlighter-rouge">Symbol.iterator</code>는 객체에 method를 정의하며, 이 method는 반복자(iterator)를 반환해야 합니다.<br />이 반복자는 <code class="highlighter-rouge">next</code> method를 가지고 있으며, <code class="highlighter-rouge">next</code>는 반복될 각 값에 대한 <code class="highlighter-rouge">{value, done}</code> 객체를 반환해야 합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Symbol.asyncIterator</code></td>
      <td>비동기 반복자를 정의하는 데 사용됩니다.<br />이를 통해 객체는 <code class="highlighter-rouge">for await...of</code> loop에 의해 비동기적으로 반복될 수 있습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Symbol.toStringTag</code></td>
      <td>객체의 기본 <code class="highlighter-rouge">toString()</code> method 호출 결과에 사용되는 문자열을 정의합니다.<br />e.g., <code class="highlighter-rouge">Object.prototype.toString.call(new Array())</code>을 호출하면 <code class="highlighter-rouge">"[object Array]"</code>가 반환되는데, 이는 <code class="highlighter-rouge">Array</code> 객체의 <code class="highlighter-rouge">Symbol.toStringTag</code> 속성이 <code class="highlighter-rouge">"Array"</code>로 설정되어 있기 때문입니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Symbol.species</code></td>
      <td>생성자 함수에 의해 생성된 객체의 유형을 지정합니다.<br />이 symbol을 사용하여 내장 객체의 subclass에서 <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">filter</code> 같은 method를 호출할 때 반환되는 instance의 유형을 customizing할 수 있습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Symbol.hasInstance</code></td>
      <td><code class="highlighter-rouge">instanceof</code> 연산자를 사용할 때 객체의 instance 여부를 결정하는 method를 정의합니다.</td>
    </tr>
  </tbody>
</table>

<h3 id="symboliterator"><code class="highlighter-rouge">Symbol.iterator</code></h3>

<ul>
  <li>
    <p>어떤 객체가 <code class="highlighter-rouge">Symbol.iterator</code>를 property key로 사용한 method를 가지고 있으면, JavaScript engine은 이 객체가 iteration protocol을 따르는 것으로 간주하고 iterator로 동작하도록 합니다.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Symbol.iterator</code>를 property key로 사용하여 method를 구현하고 있는 여러 built-in 객체(built-in iterable)가 있습니다.</p>
    <ul>
      <li>Built-in iterable은 iteration protocol을 준수하여 iterator를 반환하며, iterator를 반환한다는 뜻은 <code class="highlighter-rouge">for...of</code> loop로 요소를 순회할 수 있다는 것을 의미합니다.</li>
    </ul>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th>Object</th>
      <th>Built-in Itertable</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Array</td>
      <td><code class="highlighter-rouge">Array.prototype[Symbol.iterator]</code></td>
    </tr>
    <tr>
      <td>String</td>
      <td><code class="highlighter-rouge">String.prototype[Symbol.iterator]</code></td>
    </tr>
    <tr>
      <td>Map</td>
      <td><code class="highlighter-rouge">Map.prototype[Symbol.iterator]</code></td>
    </tr>
    <tr>
      <td>Set</td>
      <td><code class="highlighter-rouge">Set.prototype[Symbol.iterator]</code></td>
    </tr>
    <tr>
      <td>DOM data structures</td>
      <td><code class="highlighter-rouge">NodeList.prototype[Symbol.iterator] HTMLCollection.prototype[Symbol.iterator]</code></td>
    </tr>
    <tr>
      <td>arguments</td>
      <td><code class="highlighter-rouge">arguments[Symbol.iterator]</code></td>
    </tr>
  </tbody>
</table>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Symbol.iterator를 property key로 사용한 method를 구현해야 합니다.</span>
<span class="c1">// 배열에는 Array.prototype[Symbol.iterator] method가 구현되어 있습니다.</span>
<span class="kd">const</span> <span class="nx">iterable</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">];</span>

<span class="c1">// iterator : iterable의 Symbol.iterator를 property key로 사용한 method는 iterator를 반환합니다.</span>
<span class="kd">const</span> <span class="nx">iterator</span> <span class="o">=</span> <span class="nx">iterable</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]();</span>

<span class="c1">// iterator는 순회 가능한 자료 구조인 iterable의 요소를 탐색하기 위한 pointer로써,</span>
<span class="c1">// value, done property를 갖는 객체를 반환하는 next() 함수를 method로 갖는 객체입니다.</span>
<span class="c1">// iterator의 next() method를 통해 iterable 객체를 순회할 수 있습니다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span>    <span class="c1">// { value: 'a', done: false }</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span>    <span class="c1">// { value: 'b', done: false }</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span>    <span class="c1">// { value: 'c', done: false }</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span>    <span class="c1">// { value: undefined, done: true }</span>
</code></pre></div></div>

<h4 id="symboliterator-예제"><code class="highlighter-rouge">Symbol.iterator</code> 예제</h4>

<ul>
  <li><code class="highlighter-rouge">Symbol.iterator</code>를 사용하여 반복될 객체의 내부 동작을 사용자가 제어할 수 있으며, 다양한 유형의 data에 대해 반복 logic을 쉽게 구현할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">iterableObj</span><span class="p">:</span> <span class="p">{</span>
    <span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="na">next</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="na">value</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="na">done</span><span class="p">:</span> <span class="nx">boolean</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">step</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="nx">next</span><span class="p">()</span> <span class="p">{</span>
                <span class="nx">step</span><span class="o">++</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">step</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span> <span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">,</span> <span class="na">done</span><span class="p">:</span> <span class="kc">false</span> <span class="p">};</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">step</span> <span class="o">===</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span> <span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">World</span><span class="dl">'</span><span class="p">,</span> <span class="na">done</span><span class="p">:</span> <span class="kc">false</span> <span class="p">};</span>
                <span class="k">return</span> <span class="p">{</span> <span class="na">value</span><span class="p">:</span> <span class="dl">''</span><span class="p">,</span> <span class="na">done</span><span class="p">:</span> <span class="kc">true</span> <span class="p">};</span>
            <span class="p">}</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">iterableObj</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>    <span class="c1">// 'Hello' 다음 'World' 출력</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>
    <p><code class="highlighter-rouge">iterableObj</code> 객체는 <code class="highlighter-rouge">Symbol.iterator</code>를 사용하여 반복 가능한(iterable) protocol을 구현합니다.</p>
  </li>
  <li><code class="highlighter-rouge">iterableObj[Symbol.iterator]</code> method는 호출될 때마다 새로운 반복자(iterator) 객체를 반환합니다.
    <ul>
      <li>iterator 객체는 <code class="highlighter-rouge">next</code> method를 포함하고 있으며, <code class="highlighter-rouge">next</code>는 반복될 각 단계에서 <code class="highlighter-rouge">{value, done}</code> 객체를 반환합니다.
        <ul>
          <li><code class="highlighter-rouge">value</code>는 현재 단계의 값이며, <code class="highlighter-rouge">done</code>은 반복이 끝났는지의 여부를 나타냅니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>이 구조를 통해 <code class="highlighter-rouge">for...of</code> loop는 <code class="highlighter-rouge">iterableObj</code>를 반복할 때마다 <code class="highlighter-rouge">iterableObj</code>의 <code class="highlighter-rouge">Symbol.iterator</code> method로부터 반환된 반복자의 <code class="highlighter-rouge">next</code> method를 호출합니다.</li>
  <li><code class="highlighter-rouge">next</code> method는 처음에는 “Hello”를, 두 번째에는 “World”를 반환하고, 그 다음에는 <code class="highlighter-rouge">done</code>을 <code class="highlighter-rouge">true</code>로 설정하여 반복이 종료되었음을 나타냅니다.</li>
</ul>

<hr />

<h2 id="reference-5">Reference</h2>

<ul>
  <li><a href="https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EC%9E%90%EB%A3%8C%ED%98%95-Symbol-%F0%9F%9A%A9-%EC%A0%95%EB%A6%AC">https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EC%9E%90%EB%A3%8C%ED%98%95-Symbol-%F0%9F%9A%A9-%EC%A0%95%EB%A6%AC</a></li>
</ul>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-primitive-type---bigint-매우-큰-정수">TypeScript Primitive Type - BigInt (매우 큰 정수)</h1>

<h2 id="bigint-type--매우-큰-정수">BigInt Type : 매우 큰 정수</h2>

<ul>
  <li><code class="highlighter-rouge">bigint</code>는 JavaScript와 TypeScript에서 <strong>매우 큰 정수</strong>를 나타내기 위한 원시(primitive) type입니다.
    <ul>
      <li>ES2020에서 JavaScript에 도입되었으며, TypeScript에서도 사용할 수 있습니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">bigint</code>는 매우 큰 숫자를 사용하거나 정밀한 숫자 계산이 필요한 경우에 유용하게 사용될 수 있습니다.
    <ul>
      <li>e.g., 큰 숫자를 암호화(cryptography), 고정밀 시간 측정기(high precision timer), 고유 식별자 생성(unique id generation) 생성, 금융 service 등.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">bigint</code> 값을 생성하기 위해서는 숫자 literal 끝에 <code class="highlighter-rouge">n</code>을 붙이거나, <code class="highlighter-rouge">BigInt()</code> 함수를 호출합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// literal을 통한 bigint 생성</span>
<span class="kd">let</span> <span class="nx">bigIntegerLiteral</span><span class="p">:</span> <span class="nx">bigint</span> <span class="o">=</span> <span class="mi">1234567890123456789012345678901234567890</span><span class="nx">n</span><span class="p">;</span>

<span class="c1">// 함수를 통한 bigint 생성</span>
<span class="kd">let</span> <span class="nx">bigIntegerFunction</span><span class="p">:</span> <span class="nx">bigint</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="dl">"</span><span class="s2">1234567890123456789012345678901234567890</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="json-직렬화-불가능">JSON 직렬화 불가능</h3>

<ul>
  <li><code class="highlighter-rouge">bigint</code> type은 JSON 표준에서 기본적으로 지원되지 않습니다.</li>
  <li><code class="highlighter-rouge">bigint</code> 값을 JSON으로 직렬화(serialization)하려면 주의가 필요하며, 일반적으로는 값을 문자열로 변환하여 처리합니다.
    <ul>
      <li><code class="highlighter-rouge">JSON.stringify()</code> 함수가 <code class="highlighter-rouge">bigint</code> 값을 직접 처리할 수 없기 때문입니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">bigInt</span><span class="p">:</span> <span class="nx">bigint</span> <span class="o">=</span> <span class="mi">1234567890123456789012345678901234567890</span><span class="nx">n</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">serializedBigInt</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">bigInt</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>    <span class="c1">// 문자열로 변환하여 JSON 직렬화</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">serializedBigInt</span><span class="p">);</span>    <span class="c1">// "1234567890123456789012345678901234567890"</span>
</code></pre></div></div>

<h3 id="bigint-type과-number-type">BigInt Type과 Number Type</h3>

<ul>
  <li><code class="highlighter-rouge">bigint</code>와 <code class="highlighter-rouge">number</code>는 모두 TypeScript에서 수치 data를 다룰 때 선택할 수 있는 type입니다.</li>
</ul>

<ol>
  <li><code class="highlighter-rouge">bigint</code> type은 <code class="highlighter-rouge">number</code> type보다 다를 수 있는 숫자의 범위가 크고, 정밀한 계산이 가능합니다.
    <ul>
      <li><code class="highlighter-rouge">number</code> type은 IEEE 754 표준에 따른 64 Bit 부동 소수점 숫자를 나타내며, 큰 정수값을 정확히 표현하는 데 한계가 있습니다.</li>
      <li><code class="highlighter-rouge">bigint</code> type은 이론상으로 제한 없이 큰 정수를 표현할 수 있어, <code class="highlighter-rouge">number</code> type의 한계를 넘어서는 큰 정수 연산에 적합합니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">bigint</code>와 <code class="highlighter-rouge">number</code> type 간에는 자동 변환이 이루어지지 않으며, 따라서 두 type 간의 직접적인 산술 연산 역시 불가능합니다.
    <ul>
      <li>e.g., <code class="highlighter-rouge">bigint</code> type의 값과 <code class="highlighter-rouge">number</code> type의 값을 더하려고 하면, TypeScript는 type 오류를 발생시킵니다.</li>
      <li>이러한 제약은 <code class="highlighter-rouge">bigint</code>와 <code class="highlighter-rouge">number</code>가 내부적으로 다르게 처리되기 때문이며, 명시적인 type 변환(type casting)을 통해 해결할 수 있지만, type의 안전성을 해칠 수 있으므로 권장되지 않습니다.
        <ul>
          <li>가능한 한 같은 type 간의 연산을 유지하는 것이 좋습니다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">bigInt1</span><span class="p">:</span> <span class="nx">bigint</span> <span class="o">=</span> <span class="mi">100</span><span class="nx">n</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">bigInt2</span><span class="p">:</span> <span class="nx">bigint</span> <span class="o">=</span> <span class="mi">200</span><span class="nx">n</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">sumOfBigInts</span><span class="p">:</span> <span class="nx">bigint</span> <span class="o">=</span> <span class="nx">bigInt1</span> <span class="o">+</span> <span class="nx">bigInt2</span><span class="p">;</span>    <span class="c1">// 300n</span>

<span class="kd">let</span> <span class="nx">normalNumber</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">sumOfBigIntAndNumber</span> <span class="o">=</span> <span class="nx">bigInt1</span> <span class="o">+</span> <span class="nx">normalNumber</span><span class="p">;</span>    <span class="c1">// Error : 'bigint'와 'number'를 더할 수 없음</span>
</code></pre></div></div>

<hr />

<h2 id="bigint의-사용-예제--unique-id-생성">BigInt의 사용 예제 : Unique ID 생성</h2>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">generateUniqueId</span><span class="p">():</span> <span class="nx">bigint</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">timestamp</span><span class="p">:</span> <span class="nx">bigint</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getTime</span><span class="p">());</span>
    <span class="kd">let</span> <span class="nx">random</span><span class="p">:</span> <span class="nx">bigint</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">10000</span><span class="p">));</span>
    <span class="k">return</span> <span class="nx">timestamp</span> <span class="o">*</span> <span class="mi">10000</span><span class="nx">n</span> <span class="o">+</span> <span class="nx">random</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">generateUniqueId</span><span class="p">());</span>
</code></pre></div></div>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-literal-type-특정한-값">TypeScript Literal Type (특정한 값)</h1>

<h2 id="literal-type---특정-값을-지정하기">Literal Type - 특정 값을 지정하기</h2>

<ul>
  <li>TypeScript의 literal type은 <strong>특정 값만을 가질 수 있는 변수</strong>를 선언할 때 사용합니다.
    <ul>
      <li>이는 변수가 <strong>정확히 그 값만을 가질 수 있음</strong>을 의미합니다.</li>
    </ul>
  </li>
  <li>
    <p>literal type은 문자열, 숫자, boolean 값 등을 정확하게 지정할 수 있습니다.</p>
  </li>
  <li>literal type을 사용하면 type의 정확성을 높일 수 있어, code의 안정성을 높이고 오류를 줄이는 데 도움이 됩니다.
    <ul>
      <li>code를 통해 변수나 속성이 가질 수 있는 값의 범위를 명확히 표현할 수 있습니다.</li>
      <li>예상치 못한 값의 할당을 compile time에 방지하여, runtime 오류의 가능성을 줄일 수 있습니다.</li>
      <li>IDE에서 literal type을 사용하면, 가능한 값에 대한 자동 완성 기능을 지원받을 수 있어, 개발 효율성을 높일 수 있습니다.</li>
    </ul>
  </li>
  <li>literal type은 <strong>보통 union type과 결합하여 literl union type으로 만들어 사용하는 경우가 많습니다.</strong></li>
</ul>

<h3 id="문자열-literal-type">문자열 Literal Type</h3>

<ul>
  <li>문자열 literal type을 사용하면 변수가 특정 문자열 값만 가질 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">direction</span><span class="p">:</span> <span class="dl">"</span><span class="s2">up</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">down</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">left</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">right</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">direction</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">up</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">direction</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">down</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">direction</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">forward</span><span class="dl">"</span><span class="p">;</span>    <span class="c1">// Error: Type '"forward"' is not assignable to type '"up" | "down" | "left" | "right"'.</span>
</code></pre></div></div>

<h3 id="숫자-literal-type">숫자 Literal Type</h3>

<ul>
  <li>숫자 literal type은 변수가 특정 숫자 값만을 가질 수 있게 합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">errorCode</span><span class="p">:</span> <span class="mi">404</span> <span class="o">|</span> <span class="mi">403</span> <span class="o">|</span> <span class="mi">500</span><span class="p">;</span>
<span class="nx">errorCode</span> <span class="o">=</span> <span class="mi">404</span><span class="p">;</span>
<span class="nx">errorCode</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>    <span class="c1">// Error: Type '200' is not assignable to type '404 | 403 | 500'.</span>
</code></pre></div></div>

<h3 id="boolean-literal-type">Boolean Literal Type</h3>

<ul>
  <li>boolean literal type을 사용하여, 변수가 <code class="highlighter-rouge">true</code>나 <code class="highlighter-rouge">false</code> 중 하나의 값만 가질 수 있게 할 수 있습니다.
    <ul>
      <li>하지만 <code class="highlighter-rouge">true</code>나 <code class="highlighter-rouge">false</code> 중 하나의 값만 가질 수 있다는 점은 기본 boolean type과 동일하기 때문에, boolean literal type은 특정 조건에서만 유용합니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">isTrue</span><span class="p">:</span> <span class="kc">true</span><span class="p">;</span>
<span class="nx">isTrue</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="nx">isTrue</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>    <span class="c1">// Error: Type 'false' is not assignable to type 'true'.</span>
</code></pre></div></div>

<h3 id="객체-literal-type">객체 literal type</h3>

<ul>
  <li>객체의 속성에 literal type을 사용할 수도 있습니다.
    <ul>
      <li>특정 속성이 정해진 몇 가지 값 중 하나만을 가질 수 있도록 제한할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Button</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">color</span><span class="p">:</span> <span class="dl">"</span><span class="s2">red</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">blue</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">green</span><span class="dl">"</span><span class="p">;</span>
    <span class="nl">disabled</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">let</span> <span class="nx">submitButton</span><span class="p">:</span> <span class="nx">Button</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">color</span><span class="p">:</span> <span class="dl">"</span><span class="s2">red</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">disabled</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">};</span>

<span class="nx">submitButton</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">yellow</span><span class="dl">"</span><span class="p">;</span>    <span class="c1">// Error: Type '"yellow"' is not assignable to type '"red" | "blue" | "green"'.</span>
</code></pre></div></div>

<hr />

<h2 id="literal-union-type--literal-type으로-만든-union-type">Literal Union Type : Literal Type으로 만든 Union Type</h2>

<ul>
  <li>literal union type은 TypeScript의 강력한 type 정의 방식 중 하나로, <strong>여러 literal type을 union(<code class="highlighter-rouge">|</code>) 연산자를 사용하여 결합</strong>한 것입니다.
    <ul>
      <li>literal union type을 사용하면 이러한 literal type들을 하나의 type으로 결합하여, 변수가 <strong>여러 개의 구체적인 값 중 하나를 가질 수 있도록</strong> 할 수 있습니다.</li>
    </ul>
  </li>
  <li>literal union type을 통해 변수나 속성이 가질 수 있는 값의 범위를 명시적으로 제한할 수 있습니다.
    <ul>
      <li>변수가 특정 값들 중 하나만을 가질 수 있도록 제한할 때, 함수가 받을 수 있는 인자의 값을 제한하고자 할 때 literal union type을 사용합니다.</li>
      <li>또한 특정 값에 따라 다른 처리를 해야 하는 경우, type guard와 함께 사용하여 code의 안전성을 보장할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="type-alias와-결합하기">Type Alias와 결합하기</h3>

<ul>
  <li>literal union type으로 객체의 속성을 제한합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Status</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">open</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">closed</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">pending</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">type</span> <span class="nx">UserStatus</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">status</span><span class="p">:</span> <span class="nx">Status</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">let</span> <span class="nx">userStatus</span><span class="p">:</span> <span class="nx">UserStatus</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">status</span><span class="p">:</span> <span class="dl">"</span><span class="s2">open</span><span class="dl">"</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="함수의-인자와-결과-값을-제한하기">함수의 인자와 결과 값을 제한하기</h3>

<ul>
  <li>union literal type을 사용하여, 함수가 특정한 문자열이나 숫자 값만을 인자로 받도록 제한할 수 있습니다.
    <ul>
      <li>이는 API 호출 시 action type을 지정하거나, 설정 option 값을 제한하는 데 유용합니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">configureSettings</span><span class="p">(</span><span class="nx">setting</span><span class="p">:</span> <span class="dl">"</span><span class="s2">light</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">dark</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">auto</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 설정 적용 logic</span>
<span class="p">}</span>

<span class="nx">configureSettings</span><span class="p">(</span><span class="dl">"</span><span class="s2">light</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">configureSettings</span><span class="p">(</span><span class="dl">"</span><span class="s2">dark</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">configureSettings</span><span class="p">(</span><span class="dl">"</span><span class="s2">blue</span><span class="dl">"</span><span class="p">);</span>    <span class="c1">// Error: Argument of type '"blue"' is not assignable to parameter of type '"light" | "dark" | "auto"'.</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">getResponseStatus</span><span class="p">(</span><span class="nx">status</span><span class="p">:</span> <span class="dl">"</span><span class="s2">success</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">error</span><span class="dl">"</span><span class="p">):</span> <span class="mi">200</span> <span class="o">|</span> <span class="mi">404</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">success</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">200</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">404</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="객체-속성의-값을-제한하기">객체 속성의 값을 제한하기</h3>

<ul>
  <li>객체의 속성 값으로 특정 literal 값만을 허용하도록 할 때, union literal type을 사용합니다.
    <ul>
      <li>이는 객체가 특정 상태 중 하나만 가지도록 제한하는 데 활용될 수 있습니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">User</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">role</span><span class="p">:</span> <span class="dl">"</span><span class="s2">admin</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">user</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">guest</span><span class="dl">"</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">newUser</span><span class="p">:</span> <span class="nx">User</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Jane Doe</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">role</span><span class="p">:</span> <span class="dl">"</span><span class="s2">admin</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">invalidUser</span><span class="p">:</span> <span class="nx">User</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">John Doe</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">role</span><span class="p">:</span> <span class="dl">"</span><span class="s2">superuser</span><span class="dl">"</span><span class="p">,</span>    <span class="c1">// Error: Type '"superuser"' is not assignable to type '"admin" | "user" | "guest"'.</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="type-guard와-결합하기">Type Guard와 결합하기</h3>

<ul>
  <li>literal union type을 사용한 type guard를 통해, code block 내에서 변수의 type을 좁히는 것(type narrowing)이 가능해집니다.
    <ul>
      <li>이는 함수 내에서 다양한 조건 처리를 할 때 TypeScript가 type을 정확하게 인식하도록 돕습니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Action</span> <span class="o">=</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">LOGIN</span><span class="dl">"</span> <span class="p">}</span> <span class="o">|</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">LOGOUT</span><span class="dl">"</span> <span class="p">}</span> <span class="o">|</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">REFRESH</span><span class="dl">"</span><span class="p">;</span> <span class="nl">timeout</span><span class="p">:</span> <span class="kr">number</span> <span class="p">};</span>

<span class="kd">function</span> <span class="nx">handleAction</span><span class="p">(</span><span class="nx">action</span><span class="p">:</span> <span class="nx">Action</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">REFRESH</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 'action'이 { type: "REFRESH"; timeout: number } type으로 추론됨</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Refreshing with timeout: </span><span class="p">${</span><span class="nx">action</span><span class="p">.</span><span class="nx">timeout</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 'action'이 { type: "LOGIN" } | { type: "LOGOUT" } type으로 추론됨</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Action type: </span><span class="p">${</span><span class="nx">action</span><span class="p">.</span><span class="kd">type</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Action</span> <span class="o">=</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">INCREMENT</span><span class="dl">"</span> <span class="p">}</span> <span class="o">|</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">DECREMENT</span><span class="dl">"</span><span class="p">;</span> <span class="nl">amount</span><span class="p">:</span> <span class="kr">number</span> <span class="p">};</span>

<span class="kd">function</span> <span class="nx">performAction</span><span class="p">(</span><span class="nx">action</span><span class="p">:</span> <span class="nx">Action</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">INCREMENT</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 'action'이 { type: "INCREMENT" } type으로 추론됨</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 'action'이 { type: "DECREMENT"; amount: number } type으로 추론됨</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="generic-literal-union-type--더-유연하게-값을-제한하기">Generic Literal Union Type : 더 유연하게 값을 제한하기</h2>

<ul>
  <li>literal type과 generic을 결합하면 함수나 class가 처리할 수 있는 값의 범위를 좁히면서도 code의 재사용성을 높일 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">getProperty</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">K</span> <span class="kd">extends</span> <span class="kr">keyof</span> <span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">obj</span><span class="p">:</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">key</span><span class="p">:</span> <span class="nx">K</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">};</span>
<span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">getProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">"</span><span class="s2">a</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">getProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">"</span><span class="s2">d</span><span class="dl">"</span><span class="p">);</span>    <span class="c1">// Error: Argument of type '"d"' is not assignable to parameter of type '"a" | "b" | "c"'.</span>
</code></pre></div></div>

<h3 id="generic-예시--상태-관리">Generic 예시 : 상태 관리</h3>

<ul>
  <li>상태 관리 함수를 구현할 때, literal type과 generic을 함께 사용하여 특정 상태 값들만을 처리하도록 제한할 수 있습니다.
    <ul>
      <li>이는 상태 관리 logic에서 오류를 방지하는 데 도움이 됩니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">State</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">status</span><span class="p">:</span> <span class="dl">"</span><span class="s2">loading</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">success</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">error</span><span class="dl">"</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">updateState</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">State</span><span class="p">,</span> <span class="nx">K</span> <span class="kd">extends</span> <span class="kr">keyof</span> <span class="nx">State</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">state</span><span class="p">:</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">key</span><span class="p">:</span> <span class="nx">K</span><span class="p">,</span> <span class="nx">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">[</span><span class="nx">K</span><span class="p">])</span> <span class="p">{</span>
    <span class="nx">state</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">myState</span><span class="p">:</span> <span class="nx">State</span> <span class="o">=</span> <span class="p">{</span> <span class="na">status</span><span class="p">:</span> <span class="dl">"</span><span class="s2">loading</span><span class="dl">"</span> <span class="p">};</span>

<span class="nx">updateState</span><span class="p">(</span><span class="nx">myState</span><span class="p">,</span> <span class="dl">"</span><span class="s2">status</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">success</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">updateState</span><span class="p">(</span><span class="nx">myState</span><span class="p">,</span> <span class="dl">"</span><span class="s2">status</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">failed</span><span class="dl">"</span><span class="p">);</span>    <span class="c1">// Error: Argument of type '"failed"' is not assignable to parameter of type '"loading" | "success" | "error"'.</span>
</code></pre></div></div>

<h3 id="generic-예시--설정-객체-update">Generic 예시 : 설정 객체 Update</h3>

<ul>
  <li>설정 객체를 update하는 함수에서, 특정 field에 할당될 수 있는 값의 종류를 제한하고자 할 때 literal type과 generic을 사용할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Config</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">theme</span><span class="p">:</span> <span class="dl">"</span><span class="s2">light</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">dark</span><span class="dl">"</span><span class="p">;</span>
    <span class="nl">layout</span><span class="p">:</span> <span class="dl">"</span><span class="s2">grid</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">list</span><span class="dl">"</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">setConfigOption</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">Config</span><span class="p">,</span> <span class="nx">K</span> <span class="kd">extends</span> <span class="kr">keyof</span> <span class="nx">Config</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">config</span><span class="p">:</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">option</span><span class="p">:</span> <span class="nx">K</span><span class="p">,</span> <span class="nx">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">[</span><span class="nx">K</span><span class="p">])</span> <span class="p">{</span>
    <span class="nx">config</span><span class="p">[</span><span class="nx">option</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">myConfig</span><span class="p">:</span> <span class="nx">Config</span> <span class="o">=</span> <span class="p">{</span> <span class="na">theme</span><span class="p">:</span> <span class="dl">"</span><span class="s2">light</span><span class="dl">"</span><span class="p">,</span> <span class="na">layout</span><span class="p">:</span> <span class="dl">"</span><span class="s2">grid</span><span class="dl">"</span> <span class="p">};</span>

<span class="nx">setConfigOption</span><span class="p">(</span><span class="nx">myConfig</span><span class="p">,</span> <span class="dl">"</span><span class="s2">theme</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">dark</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">setConfigOption</span><span class="p">(</span><span class="nx">myConfig</span><span class="p">,</span> <span class="dl">"</span><span class="s2">theme</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">blue</span><span class="dl">"</span><span class="p">);</span>    <span class="c1">// Error: Argument of type '"blue"' is not assignable to parameter of type '"light" | "dark"'.</span>
</code></pre></div></div>

<h3 id="generic-예시--event-handler">Generic 예시 : Event Handler</h3>

<ul>
  <li>event 유형과 해당 event에 대한 handler 함수를 mapping할 때, literal type과 generic을 사용하여 event 유형을 제한할 수 있습니다.
    <ul>
      <li>이를 통해 특정 event 유형에 대해서만 handler 함수를 등록할 수 있게 합니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">EventHandlers</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">onClick</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>
    <span class="nl">onMouseEnter</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">addEventHandler</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="kr">keyof</span> <span class="nx">EventHandlers</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">eventType</span><span class="p">:</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">handler</span><span class="p">:</span> <span class="nx">EventHandlers</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="p">{</span>
    <span class="c1">// event handler 등록 logic</span>
<span class="p">}</span>

<span class="nx">addEventHandler</span><span class="p">(</span><span class="dl">"</span><span class="s2">onClick</span><span class="dl">"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Clicked</span><span class="dl">"</span><span class="p">));</span>
<span class="nx">addEventHandler</span><span class="p">(</span><span class="dl">"</span><span class="s2">onScroll</span><span class="dl">"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Scrolled</span><span class="dl">"</span><span class="p">));</span>    <span class="c1">// Error: Argument of type '"onScroll"' is not assignable to parameter of type 'keyof EventHandlers'.</span>
</code></pre></div></div>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-enum-type-관련된-상수들의-집합">TypeScript Enum Type (관련된 상수들의 집합)</h1>

<h2 id="enum-enumeration-type--열거형-type"><code class="highlighter-rouge">enum</code> (Enumeration) Type : 열거형 Type</h2>

<ul>
  <li>TypeScript에서 <code class="highlighter-rouge">enum</code> type은 <strong>명명된 숫자 상수의 집합</strong>을 정의할 때 사용됩니다.
    <ul>
      <li>TypeScript의 <code class="highlighter-rouge">enum</code>은 JavaScript에는 존재하지 않는, TypeScript가 제공하는 특별한 기능 중 하나입니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">enum</code>을 사용하면 <strong>숫자나 문자열 값 집합에 더 의미 있는 이름을 부여</strong>할 수 있습니다.
    <ul>
      <li>code에서 magic number 대신 의미 있는 명확한 이름을 사용하여 가독성을 높일 수 있습니다.
        <ul>
          <li>‘magic number’는 code 내에서 명확한 설명 없이 직접 사용된 hardcoding된 숫자 값으로, code의 가독성과 유지보수성을 저하시킬 수 있습니다.</li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">enum</code> 자체가 값의 범위를 문서화하는 역할을 하며, code의 의도를 더 명확하게 전달할 수 있습니다.</li>
      <li><code class="highlighter-rouge">enum</code>은 특정한 값들만을 가질 수 있게 함으로써, type 안전성을 높여줍니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">enum</code>은 runtime에도 존재하는 실제 객체이며, 추가적인 JavaScript code를 생성합니다.
    <ul>
      <li>이는 project의 크기나 성능에 악영향을 줄 수 있지만, 미미합니다.</li>
    </ul>
  </li>
</ul>

<h3 id="숫자-열거형-numeric-enumeration">숫자 열거형 (Numeric Enumeration)</h3>

<ul>
  <li><code class="highlighter-rouge">enum</code>을 선언하면, <strong>기본적으로 값은 0부터 시작하여 member마다 순차적으로 증가</strong>합니다.</li>
  <li>각 member에 특정 값을 할당하지 않으면, compiler가 자동으로 값을 할당합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Direction</span> <span class="p">{</span>
    <span class="nx">Up</span><span class="p">,</span>
    <span class="nx">Down</span><span class="p">,</span>
    <span class="nx">Left</span><span class="p">,</span>
    <span class="nx">Right</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Direction</span><span class="p">.</span><span class="nx">Up</span><span class="p">);</span>    <span class="c1">// 0</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Direction</span><span class="p">.</span><span class="nx">Down</span><span class="p">);</span>    <span class="c1">// 1</span>
</code></pre></div></div>

<ul>
  <li>member에 <strong>특정 숫자 값을 할당할 수도 있으며, 할당된 값부터 순차적으로 증가</strong>합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Direction</span> <span class="p">{</span>
    <span class="nx">Up</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nx">Down</span><span class="p">,</span>    <span class="c1">// 2</span>
    <span class="nx">Left</span><span class="p">,</span>    <span class="c1">// 3</span>
    <span class="nx">Right</span>    <span class="c1">// 4</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="문자열-열거형-string-enumeration">문자열 열거형 (String Enumeration)</h3>

<ul>
  <li>각 member에 문자열 <strong>string literal 값을 할당</strong>하여 문자열 <code class="highlighter-rouge">enum</code>을 만들 수 있습니다.</li>
  <li>문자열 <code class="highlighter-rouge">enum</code>은 값이 자동으로 증가하지 않으므로, <strong>각 member에 값을 명시적으로 할당</strong>해야 합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Direction</span> <span class="p">{</span>
    <span class="nx">Up</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">UP</span><span class="dl">"</span><span class="p">,</span>
    <span class="nx">Down</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">DOWN</span><span class="dl">"</span><span class="p">,</span>
    <span class="nx">Left</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">LEFT</span><span class="dl">"</span><span class="p">,</span>
    <span class="nx">Right</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">RIGHT</span><span class="dl">"</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="enum과-비슷한-literal-union-type"><code class="highlighter-rouge">enum</code>과 비슷한 Literal Union Type</h3>

<ul>
  <li><code class="highlighter-rouge">enum</code> type은 유용한 기능을 제공하지만, 모든 상황에서 최선의 선택은 아닐 수 있습니다.</li>
  <li>특히, TypeScript 2.4 version 이상에서는 literal union type을 사용하여 <code class="highlighter-rouge">enum</code>과 유사한 기능을 구현할 수 있으며, 이 방법이 더 적합할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* literal union type의 사용 예시 */</span>
<span class="kd">type</span> <span class="nx">TextAlignment</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">left</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">right</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">center</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">type</span> <span class="nx">HttpStatusCode</span> <span class="o">=</span> <span class="mi">200</span> <span class="o">|</span> <span class="mi">404</span> <span class="o">|</span> <span class="mi">500</span><span class="p">;</span>
<span class="kd">type</span> <span class="nx">Toggle</span> <span class="o">=</span> <span class="kc">true</span> <span class="o">|</span> <span class="kc">false</span><span class="p">;</span>    <span class="c1">// 기본 boolean type을 사용하는 것과 동일함</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>특성</th>
      <th><code class="highlighter-rouge">enum</code> Type</th>
      <th>Literal Union Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>정의 방식</td>
      <td><code class="highlighter-rouge">enum</code> Type 사용. ‘enum’ keyword.</td>
      <td>type alias 사용. ‘type’ keyword.</td>
    </tr>
    <tr>
      <td>Runtime에 code 추가</td>
      <td>runtime에 추가 code를 생성함(runtime 객체로 존재). runtime code가 있어 bundle 크기가 증가할 수 있음.</td>
      <td>runtime에 추가 code를 생성하지 않음. compile time에만 존재하므로 bundle 크기에 영향 없음.</td>
    </tr>
    <tr>
      <td>Type Checking</td>
      <td>자동 완성 기능 지원. type checking에 용이함.</td>
      <td>각 가능한 값을 수동으로 입력해야 함. 자동 완성 기능 사용 시 덜 편리함.</td>
    </tr>
    <tr>
      <td>Iterable</td>
      <td>값이기 때문에 순회가 가능함.</td>
      <td>type이기 때문에 순회가 불가능함.</td>
    </tr>
    <tr>
      <td>JavaScript 호환성</td>
      <td>TypeScript code를 JavaScript로 compile할 때 그 구조를 유지함. JavaScript와 TypeScript를 혼합하여 사용하는 project에 적합함.</td>
      <td>JavaScript로 compile 시 구조를 유지하지 않음. type 정보만 존재함.</td>
    </tr>
    <tr>
      <td>사용을 권장하는 경우</td>
      <td><code class="highlighter-rouge">enum</code> 값을 반복하거나, <code class="highlighter-rouge">enum</code>의 값들을 runtime에 조작해야 하는 경우.<br />특정 범주에 속하는 명확한 option 집합을 표현해야 할 때.<br />TypeScript와 JavaScript 간의 호환성이 중요한 경우.</td>
      <td>type이 간단하고, runtime에서의 사용이 필요하지 않을 때(더 가볍고 간결한 code를 유지할 수 있음).<br />최종 bundle 크기를 최소화하고자 할 때(web application의 loading 시간과 성능 최적화에 유리).</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="enum-사용-방법"><code class="highlighter-rouge">enum</code> 사용 방법</h2>

<h3 id="enum-항목을-반복하기"><code class="highlighter-rouge">enum</code> 항목을 반복하기</h3>

<ul>
  <li><code class="highlighter-rouge">enum</code>을 반복하는 것은 JavaScript 객체를 반복하는 방법과 유사합니다.</li>
  <li><code class="highlighter-rouge">enum</code>의 key와 값을 순회할 수 있으며, 이를 통해 동적인 <code class="highlighter-rouge">enum</code> 관련 code를 작성할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Color</span> <span class="p">{</span>
    <span class="nx">Red</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">RED</span><span class="dl">"</span><span class="p">,</span>
    <span class="nx">Green</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">GREEN</span><span class="dl">"</span><span class="p">,</span>
    <span class="nx">Blue</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">BLUE</span><span class="dl">"</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">color</span> <span class="k">in</span> <span class="nx">Color</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">color</span><span class="p">);</span>    <span class="c1">// 'Red', 'Green', 'Blue'</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="switch-문과-함께-사용하기"><code class="highlighter-rouge">switch</code> 문과 함께 사용하기</h3>

<ul>
  <li>
    <p><code class="highlighter-rouge">enum</code>을 <code class="highlighter-rouge">switch</code> 문과 함께 사용하는 것은 분기 처리를 위한 일반적인 pattern입니다.</p>
  </li>
  <li><code class="highlighter-rouge">enum</code>을 <code class="highlighter-rouge">switch</code>의 조합은 code의 가독성을 높이고, <code class="highlighter-rouge">enum</code> 값에 따라 다른 logic을 실행할 수 있게 해주어, 복잡한 조건 logic을 효과적으로 관리할 수 있습니다.
    <ul>
      <li><code class="highlighter-rouge">enum</code>의 각 member를 <code class="highlighter-rouge">case</code>로 사용하여 <code class="highlighter-rouge">switch</code> 문 내에서 분기를 처리하는 방식은, 특정 상태나 option에 따라 다른 행동을 취해야 할 때 유용합니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">switch</code> 문에서 <code class="highlighter-rouge">enum</code>을 사용했을 때의 여러가지 장점이 있습니다.
    <ol>
      <li>명확성 : <code class="highlighter-rouge">enum</code> member를 사용하면, magic number나 문자열 literal 대신 의미 있는 이름을 사용할 수 있어, code의 의도를 명확히 전달할 수 있습니다.</li>
      <li>type 안전성 : TypeScript compiler는 <code class="highlighter-rouge">enum</code>과 <code class="highlighter-rouge">switch</code> 문을 사용할 때, 모든 <code class="highlighter-rouge">enum</code> member가 처리되었는지 확인합니다.
        <ul>
          <li><code class="highlighter-rouge">case</code>를 누락한 경우, compiler가 경고할 수 있으므로, error를 미연에 방지할 수 있습니다.</li>
        </ul>
      </li>
      <li>유지보수성 : <code class="highlighter-rouge">enum</code>을 사용하면, 관련 상수 값을 한 곳에서 관리할 수 있어, 나중에 값이 변경되거나 새로운 값이 추가될 때 유지 보수하기가 더 쉽습니다.</li>
    </ol>
  </li>
  <li><code class="highlighter-rouge">enum</code>을 정의하고, 해당 <code class="highlighter-rouge">enum</code>의 값에 따라 다른 작업을 수행하도록 <code class="highlighter-rouge">switch</code> 문을 사용하는 예제입니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Color</span> <span class="p">{</span>
    <span class="nx">Red</span><span class="p">,</span>
    <span class="nx">Green</span><span class="p">,</span>
    <span class="nx">Blue</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">getColorName</span><span class="p">(</span><span class="nx">color</span><span class="p">:</span> <span class="nx">Color</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="nx">color</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">Color</span><span class="p">.</span><span class="nx">Red</span><span class="p">:</span>
            <span class="k">return</span> <span class="dl">'</span><span class="s1">Red Color Name</span><span class="dl">'</span><span class="p">;</span>
        <span class="k">case</span> <span class="nx">Color</span><span class="p">.</span><span class="nx">Green</span><span class="p">:</span>
            <span class="k">return</span> <span class="dl">'</span><span class="s1">Green Color Name</span><span class="dl">'</span><span class="p">;</span>
        <span class="k">case</span> <span class="nx">Color</span><span class="p">.</span><span class="nx">Blue</span><span class="p">:</span>
            <span class="k">return</span> <span class="dl">'</span><span class="s1">Blue Color Name</span><span class="dl">'</span><span class="p">;</span>
        <span class="nl">default</span><span class="p">:</span>
            <span class="k">return</span> <span class="dl">'</span><span class="s1">Unknown Color Name</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">getColorName</span><span class="p">(</span><span class="nx">Color</span><span class="p">.</span><span class="nx">Red</span><span class="p">));</span>    <span class="c1">// "Red Color Name"</span>
</code></pre></div></div>

<h4 id="완전성-검사-exhaustiveness-checking">완전성 검사 (Exhaustiveness Checking)</h4>

<ul>
  <li><code class="highlighter-rouge">switch</code> 문에서 <code class="highlighter-rouge">enum</code>을 사용할 때는 모든 <code class="highlighter-rouge">enum</code> member가 처리되었는지 확인하는 것이 좋습니다.</li>
  <li>TypeScript에서는 <code class="highlighter-rouge">never</code> type을 사용하여, 처리되지 않은 <code class="highlighter-rouge">enum</code> member가 있을 경우 compile 타임에 error를 발생시키는 완전성 검사를 할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">assertNever</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">never</span><span class="p">):</span> <span class="nx">never</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">Unexpected object: </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">getColorName</span><span class="p">(</span><span class="nx">color</span><span class="p">:</span> <span class="nx">Color</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="nx">color</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">Color</span><span class="p">.</span><span class="nx">Red</span><span class="p">:</span>
            <span class="k">return</span> <span class="dl">'</span><span class="s1">Red Color Name</span><span class="dl">'</span><span class="p">;</span>
        <span class="k">case</span> <span class="nx">Color</span><span class="p">.</span><span class="nx">Green</span><span class="p">:</span>
            <span class="k">return</span> <span class="dl">'</span><span class="s1">Green Color Name</span><span class="dl">'</span><span class="p">;</span>
        <span class="k">case</span> <span class="nx">Color</span><span class="p">.</span><span class="nx">Blue</span><span class="p">:</span>
            <span class="k">return</span> <span class="dl">'</span><span class="s1">Blue Color Name</span><span class="dl">'</span><span class="p">;</span>
        <span class="nl">default</span><span class="p">:</span>
            <span class="k">return</span> <span class="nx">assertNever</span><span class="p">(</span><span class="nx">color</span><span class="p">);</span>    <span class="c1">// 모든 경우를 처리했다면 이 line은 실행되지 않음</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">assertNever</code> 함수는 <code class="highlighter-rouge">never</code> type의 인자를 받으며, 만약 <code class="highlighter-rouge">switch</code> 문에서 모든 <code class="highlighter-rouge">case</code>가 처리되지 않아 <code class="highlighter-rouge">default</code>로 넘어온 경우, 예상치 못한 상태임을 알리는 error를 발생시킵니다.</li>
</ul>

<h3 id="enum-확장하기"><code class="highlighter-rouge">enum</code> 확장하기</h3>

<ul>
  <li>TypeScript에서 <code class="highlighter-rouge">enum</code>은 직접적으로 확장할 수 없습니다.</li>
  <li>즉, 다른 <code class="highlighter-rouge">enum</code>에서 상속받거나 상속을 주는 것은 불가능합니다.</li>
  <li>하지만 <code class="highlighter-rouge">enum</code> 값을 다른 <code class="highlighter-rouge">enum</code>에 복사하여 확장하는 것은 가능합니다.</li>
  <li>이는 때때로 <code class="highlighter-rouge">enum</code>의 값을 다른 <code class="highlighter-rouge">enum</code>으로 “확장”하는 데 사용될 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">FirstEnum</span> <span class="p">{</span>
    <span class="nx">A</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nx">B</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="kr">enum</span> <span class="nx">SecondEnum</span> <span class="p">{</span>
    <span class="nx">C</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="nx">D</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="c1">// FirstEnum의 값 포함</span>
    <span class="nx">A</span> <span class="o">=</span> <span class="nx">FirstEnum</span><span class="p">.</span><span class="nx">A</span><span class="p">,</span>
    <span class="nx">B</span> <span class="o">=</span> <span class="nx">FirstEnum</span><span class="p">.</span><span class="nx">B</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="enum-type의-고급-기능-활용"><code class="highlighter-rouge">enum</code> Type의 고급 기능 활용</h2>

<ul>
  <li><code class="highlighter-rouge">enum</code> type에는 추가적인 특성과 고급 사용 방법이 있습니다.</li>
</ul>

<h3 id="reverse-mapping">Reverse Mapping</h3>

<ul>
  <li>
    <p>reverse mapping 기능은 <code class="highlighter-rouge">enum</code>의 값으로부터 그에 해당하는 이름을 찾아낼 수 있게 해주는 기능입니다.</p>
  </li>
  <li>
    <p>TypeScript <code class="highlighter-rouge">enum</code> type의 reverse mapping 기능은 숫자 <code class="highlighter-rouge">enum</code>만을 지원합니다.</p>
    <ul>
      <li>문자열 <code class="highlighter-rouge">enum</code>은 reverse mapping이 지원되지 않습니다.</li>
      <li>숫자 <code class="highlighter-rouge">enum</code>의 경우, 값으로부터 이름을 얻는 것이 가능하지만, 문자열 <code class="highlighter-rouge">enum</code>에서는 그렇지 않습니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Example</span> <span class="p">{</span>
    <span class="nx">A</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">exampleName</span> <span class="o">=</span> <span class="nx">Example</span><span class="p">[</span><span class="nx">Example</span><span class="p">.</span><span class="nx">A</span><span class="p">];</span>    <span class="c1">// "A"</span>
<span class="kd">let</span> <span class="nx">exampleValue</span> <span class="o">=</span> <span class="nx">Example</span><span class="p">[</span><span class="dl">"</span><span class="s2">A</span><span class="dl">"</span><span class="p">];</span>    <span class="c1">// 0</span>
</code></pre></div></div>

<ul>
  <li>reverse mapping 기능은 <code class="highlighter-rouge">enum</code>의 값과 이름 사이를 쉽게 전환할 수 있게 해주어, debugging과 logging 작업을 용이하게 합니다.</li>
</ul>

<h3 id="const-enum"><code class="highlighter-rouge">const enum</code></h3>

<ul>
  <li><code class="highlighter-rouge">const enum</code>은 <code class="highlighter-rouge">enum</code>을 선언할 때 앞에 <code class="highlighter-rouge">const</code>를 붙여 정의합니다.</li>
  <li><code class="highlighter-rouge">const enum</code>은 <code class="highlighter-rouge">enum</code>의 값이 inline으로 치환되어, 최종 JavaScript 출력에서 <code class="highlighter-rouge">enum</code> 객체를 제거하여 bundle 크기를 줄일 수 있습니다.
    <ul>
      <li>성능 최적화에 유용합니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="kr">enum</span> <span class="nx">Directions</span> <span class="p">{</span>
    <span class="nx">Up</span><span class="p">,</span>
    <span class="nx">Down</span><span class="p">,</span>
    <span class="nx">Left</span><span class="p">,</span>
    <span class="nx">Right</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">directions</span> <span class="o">=</span> <span class="p">[</span><span class="nx">Directions</span><span class="p">.</span><span class="nx">Up</span><span class="p">,</span> <span class="nx">Directions</span><span class="p">.</span><span class="nx">Down</span><span class="p">,</span> <span class="nx">Directions</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">Directions</span><span class="p">.</span><span class="nx">Right</span><span class="p">];</span>
</code></pre></div></div>

<ul>
  <li>compile된 JavaScript에서는 <code class="highlighter-rouge">Directions</code>에 대한 참조가 해당 값으로 직접 치환됩니다.</li>
  <li>build 과정에서 참조 값만 남기기 때문에 tree-shaking이 된다는 장점이 있습니다.
    <ul>
      <li>tree-shaking이란 나무를 흔들면 죽은 나뭇잎이 떨어지는 것처럼 사용하지 않는 code를 삭제하는 방식입니다.</li>
    </ul>
  </li>
  <li>하지만 <code class="highlighter-rouge">enum</code>과 다르게 직접적인 값으로 치환되기 때문에, 전체 namespace에 접근하지 못하고 순회할 수도 없다는 단점이 있습니다.</li>
</ul>

<h3 id="enum의-계산된-member-computed-member"><code class="highlighter-rouge">enum</code>의 계산된 Member (Computed Member)</h3>

<ul>
  <li><code class="highlighter-rouge">enum</code> 내의 항목(member)는 주로 ‘상수 member’와 ‘계산된 member’ 두 가지 유형으로 나뉩니다.
    <ul>
      <li>상수(constant) member은 compile time에 그 값이 확정되는 <code class="highlighter-rouge">enum</code> member입니다.
        <ul>
          <li>상수 member의 값은 compile time에 결정되므로, compiler가 더 강력한 type check를 수행할 수 있고, 실행 결과를 쉽게 예측할 수 있습니다.</li>
          <li><code class="highlighter-rouge">enum</code> type에서 일반적으로 사용하는 member 유형입니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>계산된(computed) member runtime에 평가되어야 하는 값을 가지는 <code class="highlighter-rouge">enum</code> member입니다.
    <ul>
      <li>runtime에 함수 호출 결과나 표현식 평가를 통해 동적으로 값을 할당받을 수 있습니다.</li>
      <li>상수 member와 달리 compile time이 아닌 runtime에 값이 결정됩니다.
        <ul>
          <li>따라서 계산된 member의 값은 실행 전까지 실제 값을 알 수 없습니다.</li>
        </ul>
      </li>
      <li>compile time에 값을 알 수 없기 때문에 compiler의 최적화에 한계가 있습니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">RandomValues</span> <span class="p">{</span>
    <span class="nx">A</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">(),</span>    <span class="c1">// runtime에 값 결정</span>
    <span class="nx">B</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">(),</span>    <span class="c1">// runtime에 값 결정</span>
    <span class="nx">C</span> <span class="o">=</span> <span class="nx">A</span> <span class="o">+</span> <span class="nx">B</span><span class="p">,</span>    <span class="c1">// runtime에 A와 B의 결과를 사용하여 계산</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>계산된 member는 runtime 의존성으로 인해 예측 가능성과 유지보수성이 감소할 수 있으므로, 사용 시 해당 <code class="highlighter-rouge">enum</code>의 목적과 program의 전체적인 구조를 고려하여 신중하게 결정해야 합니다.
    <ul>
      <li>계산된 member는 program의 다른 부분과의 명확한 계약(contract)을 형성하는 <code class="highlighter-rouge">enum</code>의 본질과 대비될 수 있습니다.
        <ul>
          <li><code class="highlighter-rouge">enum</code>의 본질에 가까운 것은 compile time에 값이 확정되는 상수 member이기 때문에, <code class="highlighter-rouge">enum</code> 사용 pattern에서 상수 member를 사용하는 것이 더 일반적입니다.</li>
        </ul>
      </li>
      <li>하지만 계산된 member는 특정 상황에서 필요한 동적 값 할당을 가능하게 하여, 필요 시에 program에 유연성을 제공합니다.</li>
    </ul>
  </li>
</ul>

<h3 id="enum과-bit-flag"><code class="highlighter-rouge">enum</code>과 Bit Flag</h3>

<ul>
  <li><code class="highlighter-rouge">enum</code>을 사용하여 ‘bit flag’ 또는 ‘bit field’를 구현할 수 있습니다.</li>
  <li>bit 연산을 사용하여 여러 <code class="highlighter-rouge">enum</code> member를 조합하는 방식은, 설정 값이나 권한 관리와 같이 여러 option을 조합해야 하는 경우 유용합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Permissions</span> <span class="p">{</span>
    <span class="nx">Read</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>    <span class="c1">// 1</span>
    <span class="nx">Write</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>    <span class="c1">// 2</span>
    <span class="nx">Execute</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>    <span class="c1">// 4</span>
<span class="p">}</span>

<span class="c1">// 여러 권한 조합</span>
<span class="kd">const</span> <span class="nx">myPermissions</span> <span class="o">=</span> <span class="nx">Permissions</span><span class="p">.</span><span class="nx">Read</span> <span class="o">|</span> <span class="nx">Permissions</span><span class="p">.</span><span class="nx">Write</span><span class="p">;</span>

<span class="c1">// 특정 권한 검사</span>
<span class="kd">const</span> <span class="nx">canExecute</span> <span class="o">=</span> <span class="p">(</span><span class="nx">myPermissions</span> <span class="o">&amp;</span> <span class="nx">Permissions</span><span class="p">.</span><span class="nx">Execute</span><span class="p">)</span> <span class="o">===</span> <span class="nx">Permissions</span><span class="p">.</span><span class="nx">Execute</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">canExecute</span><span class="p">);</span>    <span class="c1">// false</span>
</code></pre></div></div>

<h3 id="enum과-namespace의-결합"><code class="highlighter-rouge">enum</code>과 <code class="highlighter-rouge">namespace</code>의 결합</h3>

<ul>
  <li><code class="highlighter-rouge">enum</code>은 <code class="highlighter-rouge">namespace</code>와 결합하여 사용될 수 있습니다.</li>
  <li>이를 통해 <code class="highlighter-rouge">enum</code>에 method를 추가하거나, <code class="highlighter-rouge">enum</code> 내부에 추가적인 정보를 저장할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Animal</span> <span class="p">{</span>
    <span class="nx">Dog</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">DOG</span><span class="dl">"</span><span class="p">,</span>
    <span class="nx">Cat</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">CAT</span><span class="dl">"</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="nx">Animal</span> <span class="p">{</span>
    <span class="k">export</span> <span class="kd">function</span> <span class="nx">info</span><span class="p">(</span><span class="nx">animal</span><span class="p">:</span> <span class="nx">Animal</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="nx">animal</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nx">Animal</span><span class="p">.</span><span class="nx">Dog</span><span class="p">:</span>
                <span class="k">return</span> <span class="dl">"</span><span class="s2">Dogs are domesticated mammals.</span><span class="dl">"</span><span class="p">;</span>
            <span class="k">case</span> <span class="nx">Animal</span><span class="p">.</span><span class="nx">Cat</span><span class="p">:</span>
                <span class="k">return</span> <span class="dl">"</span><span class="s2">Cats are domesticated mammals.</span><span class="dl">"</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Animal</span><span class="p">.</span><span class="nx">info</span><span class="p">(</span><span class="nx">Animal</span><span class="p">.</span><span class="nx">Dog</span><span class="p">));</span>    <span class="c1">// "Dogs are domesticated mammals."</span>
</code></pre></div></div>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-special-type-특수-type">TypeScript Special Type (특수 Type)</h1>

<h2 id="특수-type--독특한-역할을-수행하는-type">특수 Type : 독특한 역할을 수행하는 Type</h2>

<ul>
  <li>TypeScript의 특수 type은 <strong>type system에서 독특한 역할을 수행</strong>하는 type들을 말합니다.
    <ul>
      <li>특수 type은 type system에서 각각의 고유하고 특별한 역할을 맡고 있으며, code의 의도를 명확하게 표현하고, type 안전성을 향상시키는 데 도움이 됩니다.</li>
    </ul>
  </li>
  <li>특수 type에는 <code class="highlighter-rouge">any</code>, <code class="highlighter-rouge">void</code>, <code class="highlighter-rouge">unknown</code>, <code class="highlighter-rouge">never</code> type이 있습니다.</li>
</ul>

<h3 id="any-type"><code class="highlighter-rouge">any</code> Type</h3>

<ul>
  <li><code class="highlighter-rouge">any</code> type은 TypeScript의 <strong>type check를 회피할 수 있는 우회로(탈출구)</strong>를 제공합니다.</li>
  <li><strong>어떤 type의 값이든 할당할 수 있으며</strong>, compiler는 <code class="highlighter-rouge">any</code> type에 대한 type check를 수행하지 않습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">notSure</span><span class="p">:</span> <span class="kr">any</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="nx">notSure</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">maybe a string instead</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">notSure</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>    <span class="c1">// okay, definitely a boolean</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">any</code> type을 사용하면 type 안전성이 저하될 수 있으므로, 가능한 한 사용을 피하는 것이 좋습니다.</li>
</ul>

<h3 id="void-type"><code class="highlighter-rouge">void</code> Type</h3>

<ul>
  <li><code class="highlighter-rouge">void</code> type은 함수가 값을 반환하지 않을 때 사용됩니다.</li>
  <li>주로 함수의 반환 type으로 사용됩니다.</li>
  <li><code class="highlighter-rouge">undefined</code> 또는 <code class="highlighter-rouge">null</code>만 할당할 수 있습니다.
    <ul>
      <li>이는 TypeScript 설정에 따라 다를 수 있습니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">warnUser</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">This is my warning message</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">warnUser</code> 함수는 아무것도 반환하지 않으므로, 반환 type으로 <code class="highlighter-rouge">void</code>를 사용합니다.</li>
</ul>

<h3 id="unknown-type"><code class="highlighter-rouge">unknown</code> Type</h3>

<ul>
  <li><code class="highlighter-rouge">unknown</code> type은 <strong><code class="highlighter-rouge">any</code> type의 type-safe한 대안</strong>이 됩니다.</li>
  <li><code class="highlighter-rouge">any</code> type과 마찬가지로 어떤 type의 값이든 할당할 수 있지만, <strong>해당 값에 대해 연산을 수행하기 전에 type을 좁혀야</strong>(type을 확인하거나 단언해야) 합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">notSure</span><span class="p">:</span> <span class="nx">unknown</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="nx">notSure</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">maybe a string instead</span><span class="dl">"</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">notSure</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">notSure</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">());</span>    <span class="c1">// OK</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">unknown</code> type 변수는 type guard를 사용하여 안전하게 접근합니다.</li>
</ul>

<h3 id="never-type"><code class="highlighter-rouge">never</code> Type</h3>

<ul>
  <li><code class="highlighter-rouge">never</code> type은 <strong>절대 발생할 수 없는 type</strong>을 나타냅니다.</li>
  <li>주로 도달할 수 없는 code 영역을 나타내거나, 항상 예외를 발생시키는 함수의 반환 type으로 사용됩니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">error</span><span class="p">(</span><span class="nx">message</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nx">never</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">fail</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">error</span><span class="p">(</span><span class="dl">"</span><span class="s2">Something failed</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">error</code> 함수는 반환되지 않으므로 <code class="highlighter-rouge">never</code> type을 반환 type으로 사용합니다.</li>
</ul>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-special-type---any-type-check-우회하기">TypeScript Special Type - Any (Type Check 우회하기)</h1>

<h2 id="any-type--typescript의-type-check-기능-우회하기"><code class="highlighter-rouge">any</code> Type : TypeScript의 Type Check 기능 우회하기</h2>

<ul>
  <li>TypeScript에서 <code class="highlighter-rouge">any</code> type은 <strong>가장 유연한 type</strong>으로, <strong>어떤 종류의 값도 할당할 수 있습니다.</strong>
    <ul>
      <li>문자열, 숫자, 배열, 객체 등 어떤 type이든 <code class="highlighter-rouge">any</code> type 변수에 할당 가능합니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">any</code> type을 사용하면, 해당 변수에 대한 <strong>compile time type check를 compiler가 수행하지 않습니다.</strong>
    <ul>
      <li>TypeScript의 type 검사 기능을 일시적으로 끌 수 있습니다.</li>
      <li>이는 동적 type 언어의 특징을 유지하면서 TypeScript를 사용하고자 할 때 유용합니다.
        <ul>
          <li>e.g., JavaScript와의 호환성을 유지하면서 점진적으로 TypeScript를 도입하거나, type 정보가 없는 library를 사용할 때.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>그러나 <code class="highlighter-rouge">any</code> type은 TypeScript의 <strong>핵심 가치인 type 안정성을 손상</strong>시킬 수 있기 때문에, 가능한 <strong>사용을 최소화</strong>하는 것이 좋습니다.
    <ul>
      <li><code class="highlighter-rouge">any</code> type은 TypeScript의 type system을 우회하기 때문에, code 내에서 type 관련 오류가 발생할 가능성을 증가시킵니다.</li>
      <li>code의 type 안정성과 유지보수성을 유지하기 위해서는 <code class="highlighter-rouge">any</code> type 대신 더 구체적이고 명확한 type(<code class="highlighter-rouge">unknown</code>, generic, union type 등)을 사용하는 것이 바람직합니다.
        <ul>
          <li>특히 type 안정성이 중요한 project에서는 <code class="highlighter-rouge">any</code> type의 사용을 피하는 것이 좋습니다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">notSure</span><span class="p">:</span> <span class="kr">any</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="nx">notSure</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">maybe a string instead</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">notSure</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>    <span class="c1">// okay, definitely a boolean</span>

<span class="kd">let</span> <span class="nx">looselyTyped</span><span class="p">:</span> <span class="kr">any</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">let</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">looselyTyped</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">c</span><span class="p">.</span><span class="nx">d</span><span class="p">;</span>    <span class="c1">// any type을 사용하면, 모든 하위 속성도 자동으로 any type이 됨</span>
</code></pre></div></div>

<hr />

<h2 id="any-type-사용-최소화-전략"><code class="highlighter-rouge">any</code> Type 사용 최소화 전략</h2>

<ul>
  <li><code class="highlighter-rouge">any</code> type은 TypeScript의 type check를 우회할 수 있는 유연한 도구이지만, type 안정성을 저해할 수 있으므로 신중하게 사용해야 합니다.</li>
  <li>TypeScript의 다양한 type system 기능을 활용하여 <code class="highlighter-rouge">any</code> 사용을 최소화하고, project의 type 안정성과 가독성을 향상시키는 것이 좋습니다.</li>
  <li><code class="highlighter-rouge">any</code> type을 사용하고 있다면 점진적으로 구체적인 type으로 변경해 나가야 합니다.</li>
</ul>

<h3 id="any-type-대신-고려할-수-있는-type들"><code class="highlighter-rouge">any</code> Type 대신 고려할 수 있는 Type들</h3>

<h4 id="unknown-type-1"><code class="highlighter-rouge">unknown</code> Type</h4>

<ul>
  <li><code class="highlighter-rouge">unknown</code> type은 <code class="highlighter-rouge">any</code>와 비슷하게 모든 종류의 값을 할당할 수 있지만, <code class="highlighter-rouge">unknown</code> type에 할당된 변수는 사용하기 전에 해당 변수의 type을 확인해야 합니다.
    <ul>
      <li><code class="highlighter-rouge">unknown</code> type 변수 사용 전 type을 확인하는 과정은, type 안정성을 높이는 데 도움이 됩니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">value</span><span class="p">:</span> <span class="nx">unknown</span><span class="p">;</span>
<span class="nx">value</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello</span><span class="dl">"</span><span class="p">;</span>    <span class="c1">// OK</span>
<span class="nx">value</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>    <span class="c1">// OK</span>

<span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">());</span>    <span class="c1">// type check 후 사용</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="generic-type">Generic Type</h4>

<ul>
  <li>함수나 class 등에서 입력 type을 미리 정의하지 않고, 사용 시점에 type을 결정할 수 있습니다.</li>
  <li>generic을 사용하면 유연함을 유지하면서도 type 안정성을 향상시킬 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">identity</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">arg</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">arg</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">identity</span><span class="p">(</span><span class="dl">"</span><span class="s2">myString</span><span class="dl">"</span><span class="p">);</span>    <span class="c1">// output은 string type</span>
</code></pre></div></div>

<h4 id="union-type">Union Type</h4>

<ul>
  <li>두 개 이상의 type 중 하나일 수 있는 변수의 type을 지정할 때 사용합니다.</li>
  <li>union type은 <code class="highlighter-rouge">any</code> type보다 type을 더 명확하게 제한할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">myVar</span><span class="p">:</span> <span class="kr">number</span> <span class="o">|</span> <span class="kr">string</span><span class="p">;</span>
<span class="nx">myVar</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello</span><span class="dl">"</span><span class="p">;</span>    <span class="c1">// OK</span>
<span class="nx">myVar</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>    <span class="c1">// OK</span>
</code></pre></div></div>

<h3 id="any-type-사용을-막는-compiler-option--noimplicitany"><code class="highlighter-rouge">any</code> Type 사용을 막는 Compiler Option : <code class="highlighter-rouge">noImplicitAny</code></h3>

<ul>
  <li><code class="highlighter-rouge">noImplicitAny</code> option은 TypeScript의 type checker가 변수, 매개 변수, 반환 값 등의 type을 자동으로 <code class="highlighter-rouge">any</code>로 추론하지 못하게 막습니다.
    <ul>
      <li>개발자가 명시적으로 type을 선언하지 않았을 때, compiler가 오류를 발생시킵니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">noImplicitAny</code> option을 통해 <code class="highlighter-rouge">any</code> type의 사용을 줄이고, TypeScript의 type 추론(type inferenece) 기능에 의존하지 않는 명확한 type 선언을 장려할 수 있습니다.</li>
</ul>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"compilerOptions"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"noImplicitAny"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">tsconfig.json</code> file에서 <code class="highlighter-rouge">noImplicitAny</code> option을 <code class="highlighter-rouge">true</code>로 설정하여 활성화할 수 있습니다.</li>
</ul>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-special-type---void-함수가-값을-반환하지-않을-때">TypeScript Special Type - Void (함수가 값을 반환하지 않을 때)</h1>

<h2 id="void-type--함수가-명시적으로-값을-반환하지-않을-때"><code class="highlighter-rouge">void</code> Type : 함수가 명시적으로 값을 반환하지 않을 때</h2>

<ul>
  <li><code class="highlighter-rouge">void</code> type은 함수가 명시적으로 값을 반환하지 않을 때 사용하는 type입니다.
    <ul>
      <li>함수가 실행된 후에 <strong>어떠한 값도 반환하지 않음을 명시적으로 표시</strong>하는 방법입니다.</li>
      <li>이는 함수의 목적이 반환 값이 아닌 어떤 동작을 수행하는 것임을 나타냅니다.</li>
    </ul>
  </li>
  <li>함수 type signature의 <code class="highlighter-rouge">void</code> 반환 type을 보고 함수의 목적을 더 쉽게 이해할 수 있으며, 실수로 반환 값을 기대하는 code를 작성하는 것을 방지할 수 있습니다.
    <ul>
      <li><code class="highlighter-rouge">void</code> type은 <strong>함수의 의도(동작을 수행하되, 호출자에게 값을 반환하지 않을 것임)를 명확히 표현</strong>합니다.</li>
    </ul>
  </li>
</ul>

<h3 id="기본적인-void-사용">기본적인 <code class="highlighter-rouge">void</code> 사용</h3>

<ul>
  <li>함수가 값을 반환하지 않고 종료될 때, 반환 type으로 <code class="highlighter-rouge">void</code>를 지정합니다.
    <ul>
      <li>이는 함수가 단순히 작업을 수행하고 명시적인 반환 값 없이 종료됨을 나타냅니다.</li>
    </ul>
  </li>
  <li>
    <p>가장 흔한 <code class="highlighter-rouge">void</code> 사용 사례입니다.</p>
  </li>
  <li>이런 함수는 작업을 실행하긴 하지만, 호출자에게 반환 값을 돌려주지 않습니다.
    <ul>
      <li>주로 logging, message 출력, event triggering 등의 부수 효과(side effects)를 위해 수행합니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">printMessage</span><span class="p">(</span><span class="nx">message</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">greet</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hello, </span><span class="p">${</span><span class="nx">name</span><span class="p">}</span><span class="s2">!`</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">logError</span> <span class="o">=</span> <span class="p">(</span><span class="nx">error</span><span class="p">:</span> <span class="nb">Error</span><span class="p">):</span> <span class="k">void</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">error</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="void-callback-함수를-매개-변수로-사용하는-경우"><code class="highlighter-rouge">void</code> Callback 함수를 매개 변수로 사용하는 경우</h3>

<ul>
  <li>함수가 callback 함수를 매개 변수로 받을 때, 해당 callback의 반환 type으로 <code class="highlighter-rouge">void</code>를 사용할 수 있습니다.</li>
  <li>이는 callback이 어떤 작업을 수행하기는 하지만, 그 결과를 호출자에게 반환하지 않고, 단지 동작을 수행하기만 한다는 것을 명시합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">processUserInput</span><span class="p">(</span><span class="nx">callback</span><span class="p">:</span> <span class="p">(</span><span class="nx">input</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">input</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Some input</span><span class="dl">"</span><span class="p">;</span>
    <span class="nx">callback</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>이 함수는 사용자 입력을 처리하고, callback 함수에 그 입력을 전달합니다.</li>
  <li>callback 함수는 입력을 사용해 작업을 수행하지만, 값은 반환하지 않습니다.</li>
</ul>

<h3 id="interface나-type-alias에서의-void-사용">Interface나 Type Alias에서의 <code class="highlighter-rouge">void</code> 사용</h3>

<ul>
  <li><code class="highlighter-rouge">void</code> type은 interface나 type alias 내의 함수 signature에서도 사용될 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">ILogger</span> <span class="p">{</span>
    <span class="nl">log</span><span class="p">:</span> <span class="p">(</span><span class="nx">message</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>
    <span class="nl">error</span><span class="p">:</span> <span class="p">(</span><span class="nx">error</span><span class="p">:</span> <span class="nb">Error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Callback</span> <span class="o">=</span> <span class="p">(</span><span class="nx">success</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">ILogger</code> interface는 log와 error를 출력하는 두 method를 정의하며, 모두 반환 값 없이 동작합니다.</li>
  <li><code class="highlighter-rouge">Callback</code> type은 <code class="highlighter-rouge">boolean</code> 매개 변수를 받고, 반환 값 없이 동작하는 함수의 type을 나타냅니다.</li>
</ul>

<h3 id="promise와-void-type">Promise와 <code class="highlighter-rouge">void</code> type</h3>

<ul>
  <li><code class="highlighter-rouge">Promise&lt;void&gt;</code>는 비동기 작업이 성공적으로 완료되었지만, 특정 값을 반환하지 않음을 나타낼 때 유용합니다.
    <ul>
      <li>e.g., database에 data를 저장하는 비동기 함수는 작업이 완료된 후 반환 값 없이 성공적으로 완료되었다는 사실만 알립니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">saveToDatabase</span><span class="p">(</span><span class="nx">data</span><span class="p">:</span> <span class="kr">any</span><span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// database에 data를 저장하는 logic</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="void와-undefined-null의-관계"><code class="highlighter-rouge">void</code>와 <code class="highlighter-rouge">undefined</code>, <code class="highlighter-rouge">null</code>의 관계</h2>

<ul>
  <li><code class="highlighter-rouge">void</code> type은 다른 type과는 달리, 변수에 할당할 수 있는 값이 매우 제한적입니다.</li>
  <li>TypeScript에서 <code class="highlighter-rouge">void</code> type의 변수에 할당할 수 있는 유일한 값은 <code class="highlighter-rouge">undefined</code>와 <code class="highlighter-rouge">null</code>입니다.
    <ul>
      <li><code class="highlighter-rouge">null</code>은 <code class="highlighter-rouge">strictNullChecks</code> option이 비활성화된 경우에만 할당할 수 있습니다.</li>
    </ul>
  </li>
  <li>하지만, 일반적으로 <code class="highlighter-rouge">void</code> type을 변수에 사용하는 것보다는 함수의 반환 type으로 사용하는 경우가 훨씬 더 많습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">logMessage</span><span class="p">(</span><span class="nx">message</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">unusable</span><span class="p">:</span> <span class="k">void</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">void</code>를 반환 type으로 사용하는 함수가 <code class="highlighter-rouge">undefined</code>를 명시적으로 반환하는 것도 일반적이지 않습니다.</li>
  <li><code class="highlighter-rouge">void</code> type을 가진 함수에서 <code class="highlighter-rouge">return</code>문을 사용할 수는 있지만, 어떤 값도 반환하지 않아야 합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">doNothing</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>    <span class="c1">// OK</span>
    <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>    <span class="c1">// OK, but not recommended</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>    <span class="c1">// Error if strictNullChecks is enabled</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="void와-undefined"><code class="highlighter-rouge">void</code>와 <code class="highlighter-rouge">undefined</code></h3>

<ul>
  <li><code class="highlighter-rouge">void</code> type 함수는 기술적으로 <code class="highlighter-rouge">undefined</code>를 반환할 수 있습니다.
    <ul>
      <li>TypeScript에서 함수가 반환 값을 명시하지 않으면 자동으로 <code class="highlighter-rouge">undefined</code>를 반환합니다.</li>
    </ul>
  </li>
  <li>그러나 <code class="highlighter-rouge">void</code>를 반환 type으로 명시한 함수에서 <code class="highlighter-rouge">return undefined;</code>를 사용하는 것은 권장되지 않습니다.
    <ul>
      <li><code class="highlighter-rouge">undefined</code> 값을 반환하는 것은 <code class="highlighter-rouge">void</code>의 의도와 상충될 수 있으며, 함수의 반환 값에 대한 의도를 혼란스럽게 만들 수 있습니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">void</code> 함수에서는 가능한 <code class="highlighter-rouge">return;</code>만 사용하거나, <code class="highlighter-rouge">return</code>문을 전혀 사용하지 않는 것이 좋습니다.</li>
</ul>

<h3 id="void와-null"><code class="highlighter-rouge">void</code>와 <code class="highlighter-rouge">null</code></h3>

<ul>
  <li><code class="highlighter-rouge">void</code> type은 <code class="highlighter-rouge">undefined</code>와 <code class="highlighter-rouge">null</code>을 엄격하게 구분합니다.
    <ul>
      <li>두 type에 대한 <code class="highlighter-rouge">void</code>의 동작이 다릅니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">strictNullChecks</code> option이 활성화된 TypeScript 환경에서는 <code class="highlighter-rouge">void</code> type 함수에서 <code class="highlighter-rouge">null</code>을 반환하려고 시도하면 type error가 발생합니다.
    <ul>
      <li>반대로 <code class="highlighter-rouge">strictNullChecks</code> option이 비활성화된 경우에는 <code class="highlighter-rouge">null</code> 반환이 가능합니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">strictNullChecks</code>가 활성화되면, <code class="highlighter-rouge">null</code>은 <code class="highlighter-rouge">void</code> type에 할당할 수 없으며, 이는 type 안전성을 강화하는 데 도움을 줍니다.</li>
</ul>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-special-type---unknown-type-안전성이-있는-any-type">TypeScript Special Type - Unknown (Type 안전성이 있는 Any Type)</h1>

<h2 id="unknown-type--type-safe하게-모든-type의-값-할당하기"><code class="highlighter-rouge">unknown</code> Type : Type-safe하게 모든 Type의 값 할당하기</h2>

<ul>
  <li><code class="highlighter-rouge">unknown</code> type은 TypeScript 3.0 version에서 도입되었습니다.</li>
  <li>
    <p><code class="highlighter-rouge">any</code> type과 유사하게, <code class="highlighter-rouge">unknown</code> type의 변수에는 <strong>어떤 종류의 값도 할당할 수 있습니다.</strong></p>
  </li>
  <li>그러나 <code class="highlighter-rouge">unknown</code>은 <strong><code class="highlighter-rouge">any</code>보다 type 안전성 측면에서 더 엄격</strong>합니다.
    <ul>
      <li><code class="highlighter-rouge">unknown</code> type의 주된 목적은 개발자가 type을 좀 더 명확하게 확인하거나 좁혀나가도록 강제하는 것입니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">unknown</code> type은 <strong><code class="highlighter-rouge">any</code> type의 안전한 대안</strong>으로, TypeScript에서 type 안전성을 높이고자 할 때 유용하게 사용됩니다.
    <ul>
      <li><code class="highlighter-rouge">unknown</code> type의 변수는 사용하기 전에 type 검사 등의 과정을 통해 해당 변수의 type을 좁혀야(type narrowing) 합니다.
        <ul>
          <li>이는 type check 없이 사용할 수 있는 <code class="highlighter-rouge">any</code> type과 대조적입니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">unknown</code> type의 변수를 사용하기 위해서는 해당 변수가 특정 type인지 확인하는 type guard가 필요합니다.
    <ul>
      <li><code class="highlighter-rouge">unknown</code> type을 사용할 때는 해당 값의 실제 type을 확인하지 않고 직접적으로 사용하려는 시도를 피해야 합니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">value</span><span class="p">:</span> <span class="nx">unknown</span><span class="p">;</span>

<span class="nx">value</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">;</span>    <span class="c1">// 문자열 할당</span>
<span class="nx">value</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>    <span class="c1">// 숫자 할당</span>
<span class="nx">value</span> <span class="o">=</span> <span class="p">[];</span>    <span class="c1">// 배열 할당</span>

<span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>    <span class="c1">// type guard</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">());</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>    <span class="c1">// type guard</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">unknown</code> type은 <strong>type 정보 없이 data를 처리해야 하는 경우</strong> 유용하게 사용됩니다.
    <ul>
      <li>e.g., <strong>외부 API로부터 받은 data의 type이 미리 정의되지 않은 경우</strong>, <code class="highlighter-rouge">unknown</code> type을 사용하여 초기 변수를 선언할 수 있습니다.
        <ul>
          <li>이후, type guard를 통해 data의 type을 좁혀나갑니다.</li>
        </ul>
      </li>
      <li>e.g., library 개발 시 <strong>type 정보 없이 data를 처리해야 하는 경우</strong>, library 사용자가 type을 명확하게 지정하도록 강제하기 위해 <code class="highlighter-rouge">unknown</code> type을 사용할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="unknown과-any의-차이점"><code class="highlighter-rouge">unknown</code>과 <code class="highlighter-rouge">any</code>의 차이점</h3>

<ul>
  <li><code class="highlighter-rouge">unknown</code>과 <code class="highlighter-rouge">any</code> type 모두 유연성을 제공하지만, <strong><code class="highlighter-rouge">unknown</code>은 type 안전성을 보장</strong>하는 데 더 유리하며, <strong><code class="highlighter-rouge">any</code>는 편의성을 제공하지만 type 안전성 측면에서는 단점</strong>이 있습니다.
    <ul>
      <li><code class="highlighter-rouge">any</code> type을 사용할 때는 type 검사를 수동으로 수행할 수 있지만, TypeScript compiler가 type 오류를 자동으로 감지하거나 알려주지 않습니다.</li>
      <li><code class="highlighter-rouge">unknown</code> type을 사용하면 compiler가 type을 확인하거나 확정하지 않고는 사용할 수 없게 함으로써, 더 안전한 code를 작성하도록 강제합니다.
        <ul>
          <li><code class="highlighter-rouge">unknown</code> type을 사용하면 type 안전성을 유지하면서도 동적 type data를 다룰 수 있으며, code의 다른 부분에서 예기치 않은 type 오류가 발생하는 것을 방지할 수 있습니다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="any-type-1"><code class="highlighter-rouge">any</code> Type</h4>

<ul>
  <li><code class="highlighter-rouge">any</code> type은 TypeScript의 type check system을 완전히 무시할 수 있게 해줍니다.
    <ul>
      <li><code class="highlighter-rouge">any</code> type의 변수는 어떤 종류의 값이든 할당할 수 있으며, 할당된 값에 대해 어떠한 type의 연산이나 method 호출도 수행할 수 있습니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">any</code> type을 사용하면 type 안전성이 손상될 수 있으며, 이는 runtime error로 이어질 수 있습니다.</li>
  <li><code class="highlighter-rouge">any</code>를 사용하면 TypeScript compiler가 type check를 수행하지 않으므로, 개발자가 직접 type 검사를 수행해야 합니다.</li>
</ul>

<h4 id="unknown-type-2"><code class="highlighter-rouge">unknown</code> Type</h4>

<ul>
  <li><code class="highlighter-rouge">unknown</code> type은 어떤 값이든 할당할 수 있지만, <code class="highlighter-rouge">unknown</code> type의 변수를 사용하기 전에 해당 변수의 type을 검사하거나 확정(assert)해야 합니다.
    <ul>
      <li>개발자가 변수의 실제 type을 확인하거나 변환하지 않고는 해당 변수에 대해 아무런 연산도 수행할 수 없게 함으로써, 잠재적인 runtime error를 줄일 수 있습니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">unknown</code> type은 type을 사전에 알 수 없는 경우나 외부 data source로부터 data를 받아올 때 유용하게 사용될 수 있으며, 이후에 적절한 type 검사를 통해 안전하게 사용할 수 있습니다.</li>
</ul>

<hr />

<h2 id="다양한-unknown-type-사용-방법">다양한 <code class="highlighter-rouge">unknown</code> Type 사용 방법</h2>

<h3 id="unknown과-union-type"><code class="highlighter-rouge">unknown</code>과 Union Type</h3>

<ul>
  <li><code class="highlighter-rouge">unknown</code> type과 union type을 함께 사용하면, 여러 다른 type 중 하나가 될 수 있는 값을 안전하게 처리할 수 있는 유연성을 제공합니다.
    <ul>
      <li>union type이란 변수가 여러 type 중 하나를 가질 수 있음을 나타내는 방법입니다.
        <ul>
          <li>e.g., <code class="highlighter-rouge">string | number</code> union type은 해당 변수가 문자열 또는 숫자 type의 값을 가질 수 있음을 의미합니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">unknown</code> type을 union type과 함께 사용할 때, <code class="highlighter-rouge">unknown</code> type의 변수에 대해 진행할 수 있는 연산은 해당 union type의 모든 member에 공통적으로 적용될 수 있는 연산에만 제한됩니다.
    <ul>
      <li>특정 type에만 적용 가능한 연산을 수행하기 전에, 해당 변수의 type을 좁혀주는 type guard를 사용하여 변수의 실제 type을 확인해야 합니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">processValue</span><span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="nx">unknown</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 이 block 내에서, value는 string type으로 처리됨</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">());</span>    <span class="c1">// 문자열 method를 안전하게 호출</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">number</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 이 block 내에서, value는 number type으로 처리됨</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>    <span class="c1">// 숫자 method를 안전하게 호출</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Other type</span><span class="dl">'</span><span class="p">);</span>    <span class="c1">// value가 string 또는 number type이 아닌 경우</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">processValue</code> 함수는 <code class="highlighter-rouge">unknown</code> type의 <code class="highlighter-rouge">value</code> 매개 변수를 받습니다.</li>
  <li>함수 내에서 <code class="highlighter-rouge">typeof</code> 연산자를 사용하여 <code class="highlighter-rouge">value</code>의 type을 check하는 type guard를 적용합니다.</li>
  <li>이를 통해 <code class="highlighter-rouge">value</code>가 문자열인지, 숫자인지를 안전하게 확인한 후, 해당 type에 특화된 method(<code class="highlighter-rouge">toUpperCase</code> 또는 <code class="highlighter-rouge">toFixed</code>)를 호출합니다.
    <ul>
      <li>만약 <code class="highlighter-rouge">value</code>가 문자열이나 숫자가 아니라면, “Other type”이 출력됩니다.</li>
    </ul>
  </li>
</ul>

<h3 id="unknown과-type-단언"><code class="highlighter-rouge">unknown</code>과 Type 단언</h3>

<ul>
  <li><code class="highlighter-rouge">unknown</code> type의 값을 다룰 때, 해당 값의 구체적인 type에 대해 개발자가 확신할 수 있는 경우가 있습니다.</li>
  <li>이런 경우, type 단언(type assertion)을 사용하여 <code class="highlighter-rouge">unknown</code> type을 더 구체적인 type으로 변환할 수 있습니다.</li>
  <li>하지만, type 단언은 주의해서 사용해야 하며, 가능한 type guard를 사용하는 것이 더 안전한 방법입니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">value</span><span class="p">:</span> <span class="nx">unknown</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, TypeScript</span><span class="dl">"</span><span class="p">;</span>

<span class="c1">// type 단언을 사용하여 unknown을 string type으로 변환</span>
<span class="kd">let</span> <span class="nx">someString</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="nx">value</span> <span class="k">as</span> <span class="kr">string</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">someString</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">());</span>    <span class="c1">// "HELLO, TYPESCRIPT"</span>
</code></pre></div></div>

<h3 id="unknown과-generic-기본-type"><code class="highlighter-rouge">unknown</code>과 Generic 기본 Type</h3>

<ul>
  <li>generic 함수나 generic type을 정의할 때, <code class="highlighter-rouge">unknown</code>을 기본 type으로 사용하면 함수나 type의 사용성을 높이면서도 type 안전성을 유지할 수 있습니다.</li>
  <li>이 방법은 함수나 type이 다양한 type의 값을 처리할 수 있도록 하면서도, 호출하는 측에서 명시적인 type 정보를 제공하도록 강제합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">processValue</span><span class="o">&lt;</span><span class="nx">T</span> <span class="o">=</span> <span class="nx">unknown</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// value에 대한 처리 logic</span>
<span class="p">}</span>

<span class="nx">processValue</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>    <span class="c1">// T는 number</span>
<span class="nx">processValue</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello</span><span class="dl">"</span><span class="p">);</span>    <span class="c1">// T는 string</span>
</code></pre></div></div>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-special-type---never-절대-발생할-수-없는-값">TypeScript Special Type - Never (절대 발생할 수 없는 값)</h1>

<h2 id="never-type-1"><code class="highlighter-rouge">never</code> Type</h2>

<ul>
  <li>TypeScript의 <code class="highlighter-rouge">never</code> type은 함수나 method가 정상적으로 종료되지 않을 때 사용되는 type입니다.
    <ul>
      <li><strong>함수가 값을 반환하지 않거나, 항상 예외를 던지거나, 혹은 무한 loop에 빠지는 경우</strong>에 해당합니다.</li>
      <li><code class="highlighter-rouge">never</code> type은 변수에 할당 가능한 어떤 값도 존재하지 않는, <strong>절대 발생할 수 없는 값의 type</strong>을 의미합니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">never</code> type은 <strong>어떠한 값도 가질 수 없습니다.</strong>
    <ul>
      <li>함수가 정상적으로 종료되지 않거나 도달할 수 없는 code 영역을 나타낼 때 사용됩니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">never</code> type은 <strong>모든 type의 하위 type</strong>입니다.
    <ul>
      <li>어떤 type도 <code class="highlighter-rouge">never</code> type의 하위 type이 될 수 없습니다.</li>
      <li>이 특징은 <code class="highlighter-rouge">never</code> type이 union type에서 자동으로 제거되는 성질을 가지게 합니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">never</code> type을 <strong>type guard의 종점</strong>으로 사용하면, code의 특정 부분이 절대 실행되지 않음을 type system에 알릴 수 있습니다.
    <ul>
      <li>이는 exhaustive check(완전 검사)에 유용하게 사용됩니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">never</code> type의 사용은 code의 논리적 흐름을 분석하는 데 도움을 주며, type 안전성을 강화하고 compiler 최적화에 도움이 됩니다.
    <ol>
      <li><strong>type 안전성 향상</strong> : <code class="highlighter-rouge">never</code> type을 사용함으로써, code의 특정 부분이 실행될 수 없음을 명확히 하여 type 안전성을 향상시킬 수 있습니다.</li>
      <li><strong>code의 의도 명확화</strong> : 함수가 예외만을 발생시키거나 무한 loop에 빠지는 등, 특정 동작만을 수행함을 명확히 표현할 수 있습니다.</li>
      <li><strong>compiler 최적화</strong> : <code class="highlighter-rouge">never</code> type을 통해 compiler는 code의 도달할 수 없는 영역을 더 쉽게 식별하고, 최적화할 수 있습니다.</li>
    </ol>
  </li>
</ul>

<hr />

<h2 id="never-type의-주요-사용-사례"><code class="highlighter-rouge">never</code> Type의 주요 사용 사례</h2>

<h3 id="절대-반환되지-않는-함수">절대 반환되지 않는 함수</h3>

<ul>
  <li>함수가 무한 loop에 빠지거나, 항상 예외를 발생시키는 경우 해당 함수의 반환 type으로 <code class="highlighter-rouge">never</code>를 사용할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">throwError</span><span class="p">(</span><span class="nx">errorMsg</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nx">never</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">errorMsg</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">infiniteLoop</span><span class="p">():</span> <span class="nx">never</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="완전-검사-exhaustive-check">완전 검사 (Exhaustive Check)</h3>

<ul>
  <li><code class="highlighter-rouge">never</code> type을 사용하여 특정 조건에서 code가 도달할 수 없음을 명시적으로 표현할 수 있습니다.
    <ul>
      <li>type guard에서 type 좁히기(narrowing)를 적용해, <strong>모든 가능한 case를 처리했는지 확인</strong>합니다.</li>
      <li>모든 case를 처리한 후 남는 code 영역에 도달했다면(논리적 오류), <code class="highlighter-rouge">never</code> type을 통해 오류 상황을 감지할 수 있습니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">switch</code> 문의 <code class="highlighter-rouge">default</code> 영역에서 <code class="highlighter-rouge">never</code> type을 사용하여, 모든 가능한 case를 처리했음을 compiler에게 보장할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Shape</span> <span class="o">=</span> <span class="nx">Circle</span> <span class="o">|</span> <span class="nx">Square</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">getArea</span><span class="p">(</span><span class="nx">shape</span><span class="p">:</span> <span class="nx">Shape</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="nx">shape</span><span class="p">.</span><span class="nx">kind</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="dl">"</span><span class="s2">circle</span><span class="dl">"</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">radius</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">case</span> <span class="dl">"</span><span class="s2">square</span><span class="dl">"</span><span class="p">:</span>
            <span class="k">return</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">sideLength</span> <span class="o">*</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">sideLength</span><span class="p">;</span>
        <span class="nl">default</span><span class="p">:</span>
            <span class="c1">// 여기에 도달했다면, 모든 가능한 case를 처리했음을 의미함</span>
            <span class="c1">// 이 경우, shape는 never type이 됨</span>
            <span class="kd">const</span> <span class="nx">exhaustiveCheck</span><span class="p">:</span> <span class="nx">never</span> <span class="o">=</span> <span class="nx">shape</span><span class="p">;</span>
            <span class="k">return</span> <span class="nx">exhaustiveCheck</span><span class="p">;</span>    <span class="c1">// 이 code는 실행되지 않음 (compiler error)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Action</span> <span class="o">=</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">INCREMENT</span><span class="dl">'</span> <span class="p">}</span> <span class="o">|</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">DECREMENT</span><span class="dl">'</span> <span class="p">}</span> <span class="o">|</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">RESET</span><span class="dl">'</span> <span class="p">};</span>

<span class="kd">function</span> <span class="nx">performAction</span><span class="p">(</span><span class="nx">action</span><span class="p">:</span> <span class="nx">Action</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="dl">'</span><span class="s1">INCREMENT</span><span class="dl">'</span><span class="p">:</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Incrementing</span><span class="dl">'</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="dl">'</span><span class="s1">DECREMENT</span><span class="dl">'</span><span class="p">:</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Decrementing</span><span class="dl">'</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="dl">'</span><span class="s1">RESET</span><span class="dl">'</span><span class="p">:</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Resetting</span><span class="dl">'</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="nl">default</span><span class="p">:</span>
            <span class="kd">const</span> <span class="nx">exhaustiveCheck</span><span class="p">:</span> <span class="nx">never</span> <span class="o">=</span> <span class="nx">action</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">performAction</span><span class="p">({</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">INCREMENT</span><span class="dl">'</span> <span class="p">});</span>
<span class="nx">performAction</span><span class="p">({</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">DECREMENT</span><span class="dl">'</span> <span class="p">});</span>
<span class="nx">performAction</span><span class="p">({</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">RESET</span><span class="dl">'</span> <span class="p">});</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">default</code> case에 도달하는 것은 <code class="highlighter-rouge">Action</code> type에 정의되지 않은 새로운 행동 type이 추가되었고, 해당 case를 처리하지 않았음을 의미합니다.</li>
  <li><code class="highlighter-rouge">default</code> case에서 <code class="highlighter-rouge">action</code> 변수의 type을 <code class="highlighter-rouge">never</code>로 명시함으로써, 모든 가능한 행동 type을 처리했다는 것을 compile time에 보장합니다.</li>
  <li>만약 새로운 행동 type이 <code class="highlighter-rouge">Action</code> union type에 추가되면, <code class="highlighter-rouge">exhaustiveCheck</code>에 할당하는 과정에서 compile 오류가 발생하여, 개발자가 이를 인지하고 적절한 처리 logic을 추가할 수 있도록 돕습니다.</li>
</ul>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-object-type-객체-type">TypeScript Object Type (객체 Type)</h1>

<h2 id="object-type--객체-type">Object Type : 객체 Type</h2>

<ul>
  <li>
    <p>TypeScript의 객체 type을 활용하여, type system 안에서 <strong>복잡한 data 구조를 설계</strong>할 수 있습니다.</p>
  </li>
  <li>
    <p>TypeScript(및 JavaScript)에서 <code class="highlighter-rouge">Object</code>와 <code class="highlighter-rouge">object</code> type은 다른 의미를 가지고 구분되어 사용됩니다.</p>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th><code class="highlighter-rouge">Object</code> type (대문자 ‘O’)</th>
      <th><code class="highlighter-rouge">object</code> type (소문자 ‘o’)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>JavaScript의 <strong>모든 객체가 기본적으로 상속받는 최상위 class</strong>입니다.<br />JavaScript에서 생성할 수 있는 <strong>모든 값(원시 값과 객체)을 포함</strong>합니다.</td>
      <td><strong>원시 type을 제외한 모든 객체</strong> type입니다.<br /><strong><code class="highlighter-rouge">null</code>을 제외한 모든 객체</strong>, 즉 배열, 함수, class instance 등 JavaScript에서 생성할 수 있는 거의 모든 구조체를 포함합니다.</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>여기서 말하는 모든 ‘객체(object)’는 소문자 ‘o’로 시작하는 <code class="highlighter-rouge">object</code>를 의미합니다.</li>
</ul>

<h3 id="객체-type">객체 Type</h3>

<ul>
  <li>객체 type(소문자로 시작하는 <code class="highlighter-rouge">object</code>)은 <strong>원시 type을 제외한 모든 객체 type</strong>을 나타내며, <strong><code class="highlighter-rouge">null</code>을 제외한 모든 객체를 포함</strong>합니다.
    <ul>
      <li>객체, 배열, 함수, class instance 등 JavaScript에서 생성할 수 있는 거의 모든 구조를 포함할 수 있습니다.</li>
    </ul>
  </li>
  <li>객체 type을 사용하면 가장 일반적인 형태의 객체를 다룰 수 있지만, 구체적인 구조를 명시하지 않기 때문에 더 세밀한 type checking을 위해서는 다른 구체적인 객체 type을 사용하는 것이 좋습니다.
    <ul>
      <li>객체 type을 사용하는 것보다 더 구체적인 객체 type(<code class="highlighter-rouge">Array&lt;T&gt;</code>, <code class="highlighter-rouge">function</code>, <code class="highlighter-rouge">class</code>, <code class="highlighter-rouge">interface</code> 등)을 사용하여 type의 세부 사항을 명시하는 것이 type 안정성을 향상시키는 데에 도움이 됩니다.</li>
      <li>e.g., 배열을 다룰 때 <code class="highlighter-rouge">Array&lt;number&gt;</code> 또는 <code class="highlighter-rouge">number[]</code>와 같이 명시적으로 type을 선언함으로써 배열 내부의 모든 요소가 숫자 type임을 보장할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="배열-type">배열 Type</h3>

<ul>
  <li>배열은 <strong>동일한 type의 값들을 순서대로 저장하는 collection</strong>입니다.</li>
  <li>TypeScript에서 배열 type은 <code class="highlighter-rouge">type[]</code> 또는 <code class="highlighter-rouge">Array&lt;type&gt;</code>의 형태로 표현됩니다.
    <ul>
      <li>배열 내부의 모든 요소가 동일한 type을 가진다는 것을 명시할 수 있으며, type 안정성을 보장할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="함수-type">함수 Type</h3>

<ul>
  <li>함수 type은 <strong>함수의 signature를 정의</strong>하는 데에 사용됩니다.
    <ul>
      <li>함수의 매개 변수 type, 반환 type을 포함하여 함수의 전체적인 구조를 명확하게 설명할 수 있습니다.</li>
    </ul>
  </li>
  <li>함수 type을 정의함으로써, 함수가 호출될 때의 type 안정성을 보장받을 수 있습니다.</li>
</ul>

<h3 id="class-type">Class Type</h3>

<ul>
  <li>class는 실제 구현을 포함하며 <strong>instance를 생성할 수 있는 template</strong>(class instance spec)을 제공합니다.
    <ul>
      <li>class type을 사용하여 instance가 가질 수 있는 property(속성)과 method, 그리고 그 type들을 명시합니다.</li>
    </ul>
  </li>
  <li>class는 상속(inheritance), 캡슐화(encapsulation), 다형성(polymorphism)과 같은 객체 지향 programming의 중요한 개념을 TypeScript에서 효과적으로 사용할 수 있게 합니다.</li>
</ul>

<h3 id="interface-type">Interface Type</h3>

<ul>
  <li>interface는 <strong>객체의 구조를 정의</strong>하는 데 사용됩니다.
    <ul>
      <li>interface를 통해 객체가 가져야 할 property(속성)과 method, 그리고 그 type들을 명시합니다.</li>
    </ul>
  </li>
  <li>interface는 class와 함께 사용하여 특정 구조를 갖춘 객체를 생성할 수 있도록 강제할 수 있습니다.
    <ul>
      <li>interface는 type checking을 위한 구조적 계약을 정의하며, 실제 구현은 포함하지 않습니다.</li>
      <li>객체가 “interface를 구현하겠다”는 것은 “특정 구조를 따르도록 강제하는 계약을 따르겠다”는 말과 같습니다.</li>
    </ul>
  </li>
  <li>interface는 확장 가능하며, code의 재사용성과 유지보수성을 향상시키는 데 유용하게 사용됩니다.</li>
</ul>

<h3 id="tuple-type">Tuple Type</h3>

<ul>
  <li>tuple은 <strong>고정된 길이의 배열 type으로, 배열 내 각 요소의 type이 정해져 있습니다.</strong>
    <ul>
      <li>tuple은 다양한 type의 요소를 포함할 수 있으며, 각 요소의 정확한 type을 사전에 알 수 있어야 할 때 유용합니다.</li>
    </ul>
  </li>
  <li>e.g., 두 개의 요소를 갖는 tuple <code class="highlighter-rouge">let x: [string, number] = ['hello', 10];</code>은 첫 번째 요소가 문자열이고 두 번째 요소가 숫자인 배열을 나타냅니다.</li>
</ul>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-object-type---object-객체">TypeScript Object Type - Object (객체)</h1>

<h2 id="object-type--all-non-primitive-type">Object Type : All Non-Primitive Type</h2>

<ul>
  <li>TypeScript에서 <code class="highlighter-rouge">object</code> type은 <strong>원시 type을 제외한 값</strong>(배열, 함수, 객체 등)을 포함합니다.
    <ul>
      <li>원시 type에는 <code class="highlighter-rouge">number</code>, <code class="highlighter-rouge">string</code>, <code class="highlighter-rouge">boolean</code>, <code class="highlighter-rouge">bigint</code>, <code class="highlighter-rouge">symbol</code>, <code class="highlighter-rouge">null</code>, <code class="highlighter-rouge">undefined</code>가 있으며, 이 type들을 제외한 모든 type이 <code class="highlighter-rouge">object</code> type에 속합니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">object</code> type을 사용하여 변수를 선언할 수 있으며, 이는 해당 변수가 원시 type이 아닌 값을 가질 수 있음을 의미합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 객체 literal (이름과 값을 가진 속성의 집합) */</span>
<span class="kd">let</span> <span class="nx">user</span><span class="p">:</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">John</span><span class="dl">"</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">30</span> <span class="p">};</span>

<span class="cm">/* 배열 (순서가 있는 값의 집합) */</span>
<span class="kd">let</span> <span class="nx">numbers</span><span class="p">:</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>

<span class="cm">/* 함수 (실행 가능한 code block) */</span>
<span class="kd">let</span> <span class="nx">greet</span><span class="p">:</span> <span class="nx">object</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello World!</span><span class="dl">"</span><span class="p">);</span> <span class="p">};</span>
<span class="nx">greet</span><span class="p">({</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">30</span> <span class="p">});</span>    <span class="c1">// 정상 작동</span>
<span class="nx">greet</span><span class="p">({</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Bob</span><span class="dl">"</span> <span class="p">});</span>    <span class="c1">// Error: Property 'age' is missing in type '{ name: string; }'</span>

<span class="cm">/* class instances (특정 class의 생성자를 통해 생성된 객체) */</span>
<span class="kd">class</span> <span class="nx">Car</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="k">public</span> <span class="nx">make</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="k">public</span> <span class="nx">model</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">myCar</span><span class="p">:</span> <span class="nx">object</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Car</span><span class="p">(</span><span class="dl">"</span><span class="s2">Toyota</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Corolla</span><span class="dl">"</span><span class="p">);</span>

<span class="cm">/* built-in 객체 (JavaScript에 내장된 객체) */</span>
<span class="kd">let</span> <span class="nx">today</span><span class="p">:</span> <span class="nx">object</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">pattern</span><span class="p">:</span> <span class="nx">object</span> <span class="o">=</span> <span class="sr">/d+/g</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">map</span><span class="p">:</span> <span class="nx">object</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
<span class="kd">let</span> <span class="kd">set</span><span class="p">:</span> <span class="nx">object</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span>

<span class="cm">/* promise (비동기 작업 완료 결과 값) */</span>
<span class="kd">let</span> <span class="nx">promise</span><span class="p">:</span> <span class="nx">object</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
 <span class="nx">resolve</span><span class="p">(</span><span class="dl">"</span><span class="s2">Success</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>

<span class="cm">/* tuple (각 요소의 type을 지정할 수 있는 고정된 길이의 배열) */</span>
<span class="kd">let</span> <span class="nx">tuple</span><span class="p">:</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">,</span> <span class="mi">100</span><span class="p">];</span>

<span class="cm">/* 복잡한 중첩 객체 (내부에 다른 객체, 배열, 함수 등이 중첩된 구조를 가진 객체) */</span>
<span class="kd">let</span> <span class="nx">complex</span><span class="p">:</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">data</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
    <span class="na">func</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Complex</span><span class="dl">"</span><span class="p">);</span> <span class="p">},</span>
    <span class="na">object</span><span class="p">:</span> <span class="p">{</span> <span class="na">key</span><span class="p">:</span> <span class="dl">"</span><span class="s2">value</span><span class="dl">"</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">object</code> type에 원시 type의 값을 할당받으려고 하면 TypeScript compiler가 오류를 발생시킵니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span><span class="p">:</span> <span class="nx">object</span><span class="p">;</span>

<span class="nx">obj</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>    <span class="c1">// Error: Type 'number' is not assignable to type 'object'.</span>
<span class="nx">obj</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">;</span>    <span class="c1">// Error: Type 'string' is not assignable to type 'object'.</span>
<span class="nx">obj</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>    <span class="c1">// Error: Type 'boolean' is not assignable to type 'object'.</span>
</code></pre></div></div>

<hr />

<h2 id="지나치게-유연한-object-type">지나치게 유연한 <code class="highlighter-rouge">object</code> Type</h2>

<ul>
  <li>TypeScript에서 <code class="highlighter-rouge">object</code> type은 원시 type을 제외한 모든 비원시(non-primitive) type의 객체를 포함할 수 있는 유연한 type입니다.</li>
  <li><code class="highlighter-rouge">object</code> type의 유연성은 다양한 객체를 하나의 type으로 처리할 수 있게 해주지만, 과도한 유연성은 code 품질에 부정적인 영향을 줄 수 있습니다.
    <ol>
      <li><strong>type 안정성 감소</strong> : <code class="highlighter-rouge">object</code> type은 구체적인 구조를 정의하지 않기 때문에, 객체가 예측 가능한 속성을 가지고 있는지, 또는 올바른 type의 값을 가지고 있는지 compile time에 확인할 수 없습니다.</li>
      <li><strong>가독성 저하</strong> : <code class="highlighter-rouge">object</code> type을 사용하면 해당 변수가 어떤 구조를 가지고 있는지 code만으로는 명확하게 알 수 없습니다.</li>
      <li><strong>유지보수성 저하</strong> : <code class="highlighter-rouge">object</code> type의 변수를 수정하거나 확장해야 할 경우, 해당 변수가 어떤 속성이나 method를 지원하는지 알기 어렵습니다.</li>
    </ol>
  </li>
  <li>따라서, code의 명확성과 안정성을 보장하기 위해 가능한 한 <strong><code class="highlighter-rouge">object</code> type 대신 더 구체적인 type을 선언하여 사용하는 것을 권장</strong>합니다.
    <ul>
      <li>구체적인 type을 사용함으로써, type 안정성을 높이고, code의 가독성 및 유지보수성을 향상시킬 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="구체적인-type-사용하기">구체적인 Type 사용하기</h3>

<ul>
  <li><code class="highlighter-rouge">object</code> type의 지나친 유연성 때문에 발생하는 문제를 해결하기 위해, 가능한 한 <code class="highlighter-rouge">object</code> type 대신 구체적인 type을 사용해야 합니다.</li>
</ul>

<h4 id="interface와-type-alias">Interface와 Type Alias</h4>

<ul>
  <li>구체적인 객체 구조를 정의하는 가장 일반적인 방법은 interface와 type alias을 사용하는 것입니다.</li>
  <li>이 방법을 통해 객체가 가질 수 있는 속성과 그 type을 명시적으로 선언할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">User</span> <span class="p">{</span>
    <span class="nl">id</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">email</span><span class="p">?:</span> <span class="kr">string</span><span class="p">;</span>    <span class="c1">// optional property</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Product</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">id</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">price</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h4 id="class">Class</h4>

<ul>
  <li>class를 사용하면 type과 함께 객체의 구조와 행위를 정의할 수 있습니다.</li>
  <li>class는 type checking과 함께 instance 생성 logic을 포함할 수 있으므로, 객체 지향 programming paradigm을 따르는 application에 적합합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Car</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="k">public</span> <span class="nx">make</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="k">public</span> <span class="nx">model</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="k">public</span> <span class="nx">year</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">myCar</span><span class="p">:</span> <span class="nx">Car</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Car</span><span class="p">(</span><span class="dl">"</span><span class="s2">Toyota</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Corolla</span><span class="dl">"</span><span class="p">,</span> <span class="mi">2020</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="배열과-tuple">배열과 Tuple</h4>

<ul>
  <li>배열과 tuple에 대해서도, 가능한 한 구체적인 type을 사용해야 합니다.</li>
  <li>이는 배열 내의 요소 type을 명확히 함으로써 type 안정성을 향상시킵니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">numbers</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="kd">type</span> <span class="nx">StringNumberPair</span> <span class="o">=</span> <span class="p">[</span><span class="kr">string</span><span class="p">,</span> <span class="kr">number</span><span class="p">];</span>
<span class="nx">et</span> <span class="nx">pair</span><span class="p">:</span> <span class="nx">StringNumberPair</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">one</span><span class="dl">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>
</code></pre></div></div>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-object-type---array-배열">TypeScript Object Type - Array (배열)</h1>

<h2 id="배열-type--type이-같은-값들의-집합">배열 Type : Type이 같은 값들의 집합</h2>

<ul>
  <li>
    <p>TypeScript의 배열 type은 강력한 type checking 기능을 제공하여, <strong>배열 내의 모든 요소가 동일한 type</strong>을 갖도록 합니다.</p>
  </li>
  <li>
    <p>배열 type의 정의는 <code class="highlighter-rouge">type[]</code>과 <code class="highlighter-rouge">Array&lt;type&gt;</code> 두 가지 방식 중 상황에 맞는 방식을 선택하여 사용할 수 있습니다.</p>
  </li>
</ul>

<h3 id="type을-사용한-배열-type-정의"><code class="highlighter-rouge">type[]</code>을 사용한 배열 type 정의</h3>

<ul>
  <li>가장 간단하고 일반적인 방법으로, 배열이 담을 요소의 type 뒤에 대괄호(<code class="highlighter-rouge">[]</code>)를 붙여 배열 type을 정의합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">numbers</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">names</span><span class="p">:</span> <span class="kr">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Bob</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Charlie</span><span class="dl">"</span><span class="p">];</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">numbers</code> 배열은 <code class="highlighter-rouge">number</code> type의 요소만을 포함할 수 있으며, <code class="highlighter-rouge">names</code> 배열은 <code class="highlighter-rouge">string</code> type의 요소만을 포함할 수 있습니다.</li>
</ul>

<h3 id="arraytype을-사용한-배열-type-정의"><code class="highlighter-rouge">Array&lt;type&gt;</code>을 사용한 배열 type 정의</h3>

<ul>
  <li>generic 배열 type <code class="highlighter-rouge">Array&lt;type&gt;</code>을 사용하여 배열 type을 정의할 수도 있습니다.</li>
  <li>generic 방식은 특히 type이 복잡하거나 다중 type을 다룰 때 유용할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">scores</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="mi">85</span><span class="p">,</span> <span class="mi">92</span><span class="p">,</span> <span class="mi">88</span><span class="p">,</span> <span class="mi">76</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">fruits</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">Apple</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Orange</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Banana</span><span class="dl">"</span><span class="p">];</span>
</code></pre></div></div>

<hr />

<h2 id="다양한-형태의-배열">다양한 형태의 배열</h2>

<h3 id="다차원-배열">다차원 배열</h3>

<ul>
  <li>다차원 배열은 배열의 배열을 의미합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">matrix</span><span class="p">:</span> <span class="kr">number</span><span class="p">[][]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="p">];</span>
</code></pre></div></div>

<h3 id="읽기-전용-배열">읽기 전용 배열</h3>

<ul>
  <li>읽기 전용 배열은 배열이 생성된 후에 수정할 수 없습니다.</li>
  <li><code class="highlighter-rouge">readonly</code> keyword를 사용하여 읽기 전용 배열을 정의할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">readonlyNumbers</span><span class="p">:</span> <span class="k">readonly</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="nx">readonlyNumbers</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>    <span class="c1">// Compile Error: readonly 배열에는 push 메서드를 사용할 수 없습니다.</span>
</code></pre></div></div>

<h3 id="객체-배열">객체 배열</h3>

<ul>
  <li>배열 내의 객체에 대한 type도 정의할 수 있습니다.</li>
  <li>이는 복잡한 data 구조를 안전하게 다루는 데 유용합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">User</span> <span class="p">{</span>
    <span class="nl">id</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">users</span><span class="p">:</span> <span class="nx">User</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span> <span class="p">},</span>
    <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Bob</span><span class="dl">"</span> <span class="p">}</span>
<span class="p">];</span>
</code></pre></div></div>

<h3 id="union-type을-사용한-배열">Union Type을 사용한 배열</h3>

<ul>
  <li>배열이 여러 type의 요소를 포함할 수 있도록 union type을 사용하여 배열 type을 정의할 수도 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">mixed</span><span class="p">:</span> <span class="p">(</span><span class="kr">number</span> <span class="o">|</span> <span class="kr">string</span><span class="p">)[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="dl">"</span><span class="s2">two</span><span class="dl">"</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="dl">"</span><span class="s2">four</span><span class="dl">"</span><span class="p">];</span>
</code></pre></div></div>

<hr />

<h2 id="배열-활용하기">배열 활용하기</h2>

<ul>
  <li>TypeScript과 배열의 특성을 활용한 기능들을 사용하여, 더 편리하게 개발할 수 있습니다.</li>
</ul>

<h3 id="일관된-type의-요소">일관된 Type의 요소</h3>

<ul>
  <li>배열 type을 활용하면 compiler가 배열의 요소에 대한 type을 check하여, type이 일치하지 않는 요소가 배열에 추가되는 것을 방지할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">numbers</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="nx">numbers</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="c1">// numbers.push("five");    // Compile Error: 'string' type은 'number' type 배열에 할당할 수 없습니다.</span>
</code></pre></div></div>

<h3 id="배열-method와-type-추론">배열 Method와 Type 추론</h3>

<ul>
  <li>TypeScript는 표준 배열 method를 사용할 때도 ‘type 추론’을 제공합니다.
    <ul>
      <li>type 추론(type inference)은 TypeScript가 code에서 변수나 함수의 type을 자동으로 결정하는 과정입니다.</li>
    </ul>
  </li>
  <li>e.g., <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">filter</code>, <code class="highlighter-rouge">reduce</code> 같은 method에 대한 callback 함수의 매개 변수 type도 자동으로 추론됩니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">numbers</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">doubled</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="kr">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">number</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
<span class="c1">// doubled는 number[] type으로 추론됩니다.</span>
</code></pre></div></div>

<h3 id="배열과-비구조화-할당">배열과 비구조화 할당</h3>

<ul>
  <li>배열의 비구조화 할당에 대한 type 정의 방법은 code를 더욱 간결하고 읽기 쉽게 만들어 줍니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="p">[</span><span class="nx">first</span><span class="p">,</span> <span class="nx">second</span><span class="p">]:</span> <span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="kr">number</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
</code></pre></div></div>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-object-type---function-함수-signature">TypeScript Object Type - Function (함수 Signature)</h1>

<h2 id="함수-type--함수의-signature-정의하기">함수 Type : 함수의 Signature 정의하기</h2>

<ul>
  <li>함수 type은 <strong>함수의 매개 변수와 반환 값의 type을 정의</strong>하는 데 사용합니다.
    <ul>
      <li>함수의 매개 변수와 반환 type을 정의한 것을 <strong>‘함수의 signature’</strong>라 부릅니다.</li>
      <li>함수 type을 통해 명시적으로 선언된 signature를 갖는 함수는 compile 시점에 TypeScript에 의해 검사됩니다.</li>
      <li>함수가 올바르게 사용되고 있는지 확인함으로써, code의 안정성과 가독성을 향상시킬 수 있습니다.</li>
    </ul>
  </li>
  <li>함수 type은 매개 변수의 type과 반환 type을 명시하여 정의합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">myFunction</span><span class="p">:</span> <span class="p">(</span><span class="nx">param1</span><span class="p">:</span> <span class="nx">type1</span><span class="p">,</span> <span class="nx">param2</span><span class="p">:</span> <span class="nx">type2</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">returnType</span><span class="p">;</span>
</code></pre></div></div>

<hr />

<h2 id="함수-type의-다양한-사용-예시">함수 Type의 다양한 사용 예시</h2>

<ul>
  <li>TypeScript는 다양한 형태의 함수를 지원하므로, 함수 type 역시 다양한 상황에서 유연하게 활용할 수 있습니다.</li>
</ul>

<h3 id="1-단순-함수-type-선언">1. 단순 함수 Type 선언</h3>

<ul>
  <li>수학 연산을 수행하는 함수 type을 선언합니다.</li>
  <li>“함수 type을 먼저 선언하고 함수를 나중에 할당”해도 되고, “함수 type을 inline으로 정의(화살표 함수 사용)하고 함수를 바로 할당”해도 됩니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">add</span><span class="p">:</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">number</span><span class="p">;</span>

<span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">add</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span>    <span class="c1">// 30</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">multiply</span><span class="p">:</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">number</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">multiply</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>    <span class="c1">// 15</span>
</code></pre></div></div>

<h3 id="2-선택적-매개-변수와-기본-매개-변수">2. 선택적 매개 변수와 기본 매개 변수</h3>

<ul>
  <li>선택적 매개 변수를 함수 type을 정의할 때 사용할 수 있습니다.
    <ul>
      <li>선택적 매개 변수(optional parameter)는 함수 호출 시 반드시 제공하지 않아도 되는 매개 변수를 의미합니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">greet</span><span class="p">:</span> <span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">greeting</span><span class="p">?:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">string</span><span class="p">;</span>

<span class="nx">greet</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">greeting</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello</span><span class="dl">"</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">`</span><span class="p">${</span><span class="nx">greeting</span><span class="p">}</span><span class="s2">, </span><span class="p">${</span><span class="nx">name</span><span class="p">}</span><span class="s2">!`</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">greet</span><span class="p">(</span><span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span><span class="p">));</span>    <span class="c1">// Hello, Alice!</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">greet</span><span class="p">(</span><span class="dl">"</span><span class="s2">Bob</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Hi</span><span class="dl">"</span><span class="p">));</span>    <span class="c1">// Hi, Bob!</span>
</code></pre></div></div>

<h3 id="3-callback-함수-type">3. Callback 함수 Type</h3>

<ul>
  <li>함수 type은 콜백(callback) 함수의 type을 정의하는 데에도 사용될 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">processString</span><span class="p">:</span> <span class="p">(</span><span class="nx">input</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">callback</span><span class="p">:</span> <span class="p">(</span><span class="nx">result</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>

<span class="nx">processString</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">input</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">callback</span><span class="p">:</span> <span class="p">(</span><span class="nx">result</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="nx">callback</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">());</span>
<span class="p">};</span>

<span class="nx">processString</span><span class="p">(</span><span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">,</span> <span class="nx">result</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">));</span>    <span class="c1">// HELLO</span>
</code></pre></div></div>

<h3 id="4-함수-type과-interface">4. 함수 Type과 Interface</h3>

<ul>
  <li>인터페이스에 함수 type을 사용하여, 복잡한 객체의 구조를 명확하게 정의할 수 있습니다.
    <ul>
      <li>함수 type을 interface 내에서 정의함으로써, 함수가 받아야 할 매개 변수의 type과 반환해야 할 값의 type을 지정합니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">StringProcessor</span> <span class="p">{</span>
    <span class="p">(</span><span class="nx">input</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">stringReverser</span><span class="p">:</span> <span class="nx">StringProcessor</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">input</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">input</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">""</span><span class="p">).</span><span class="nx">reverse</span><span class="p">().</span><span class="nx">join</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">stringReverser</span><span class="p">(</span><span class="dl">"</span><span class="s2">TypeScript</span><span class="dl">"</span><span class="p">));</span>    <span class="c1">// tpircSepyT</span>
</code></pre></div></div>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-object-type---class-객체-설계도">TypeScript Object Type - Class (객체 설계도)</h1>

<h2 id="class-1">Class</h2>

<ul>
  <li>TypeScript가 지원하는 class는 <strong>JavaScript ES6의 class와 유사</strong>하지만, 몇 가지 <strong>TypeScript만의 고유한 확장 기능</strong>이 있습니다.
    <ul>
      <li>TypeScript의 class는 정적 typing과 몇 가지 추가 기능을 제공하여 class를 더욱 강력하고 안전하게 만듭니다.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="class-definition">Class Definition</h2>

<ul>
  <li>JavaScript와 TypeScript의 class 정의 방식은 정적 typing 말고도, <strong>class property(member 변수) 선언 여부</strong>에서도 차이가 있습니다.</li>
</ul>

<h3 id="typescript에서-class-정의하기">TypeScript에서 Class 정의하기</h3>

<ul>
  <li>JavaScript ES6의 class는 class body에 method만을 포함할 수 있습니다.</li>
  <li>class body에 class property를 선언할 수 없고, 반드시 생성자 내부에서 class property를 선언하고 초기화합니다.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// person.js</span>
<span class="kd">class</span> <span class="nx">Person</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>    <span class="c1">// class property의 선언과 초기화</span>
    <span class="p">}</span>

    <span class="nx">walk</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2"> is walking.`</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>JavaScript ES6에서는 문제없이 실행되는 code이지만, file의 확장자를 <code class="highlighter-rouge">ts</code>로 바꾸어 TypeScript file로 변경한 후 compile하면 compile error가 발생합니다.</li>
</ul>

<pre><code class="language-log">person.ts(4,10): error TS2339: Property 'name' does not exist on type 'Person'.
person.ts(8,25): error TS2339: Property 'name' does not exist on type 'Person'.
</code></pre>

<h3 id="typescript에서-class-정의하기-1">TypeScript에서 Class 정의하기</h3>

<ul>
  <li>TypeScript class는 class body에 <strong>class property를 사전에 선언</strong>해야 합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// person.ts</span>
<span class="kd">class</span> <span class="nx">Person</span> <span class="p">{</span>
    <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>    <span class="c1">// class property 사전 선언</span>

    <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>    <span class="c1">// class property에 값 할당</span>
    <span class="p">}</span>

    <span class="nx">walk</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2"> is walking.`</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">'</span><span class="s1">Lee</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">walk</span><span class="p">();</span>    <span class="c1">// Lee is walking</span>
</code></pre></div></div>

<hr />

<h2 id="접근-제한자-access-modifier">접근 제한자 (Access Modifier)</h2>

<ul>
  <li>TypeScript class는 class 기반 객체 지향 언어가 지원하는 접근 제한자 <code class="highlighter-rouge">public</code>, <code class="highlighter-rouge">private</code>, <code class="highlighter-rouge">protected</code>를 지원하며, 의미 또한 기본적으로 동일합니다.
    <ul>
      <li>접근 제한자는 class 내부의 property과 method의 접근성을 제어하는 keyword입니다.</li>
      <li>접근 제한자는 class를 사용하는 외부 code에서 class 내부의 특정 member에 접근할 수 있는지 여부를 결정합니다.</li>
    </ul>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th>접근 가능성</th>
      <th>public</th>
      <th>protected</th>
      <th>private</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Class 내부</td>
      <td>O</td>
      <td>O</td>
      <td>O</td>
    </tr>
    <tr>
      <td>자식 Class 내부</td>
      <td>O</td>
      <td>O</td>
      <td>x</td>
    </tr>
    <tr>
      <td>Class Instance</td>
      <td>O</td>
      <td>x</td>
      <td>x</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><code class="highlighter-rouge">public</code>으로 지정하고자 하는 member 변수와 method는 접근 제한자를 생략하면 됩니다.
    <ul>
      <li>TypeScript의 경우, 접근 제한자를 생략한 class property와 method는 암묵적으로 <code class="highlighter-rouge">public</code>이 선언됩니다.</li>
      <li>다른 class 기반 언어의 경우, 접근 제한자를 명시하지 않으면 암묵적으로 <code class="highlighter-rouge">protected</code>로 지정되어 package level로 공개됩니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="k">public</span> <span class="nx">x</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="k">protected</span> <span class="nx">y</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="k">private</span> <span class="nx">z</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>

    <span class="kd">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">z</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// public, protected, private 접근 제한자 모두 class 내부에서 참조 가능함</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">z</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">(</span><span class="dl">'</span><span class="s1">x</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">y</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">z</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// public 접근 제한자는 class instance를 통해 class 외부에서 참조 가능함</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>

<span class="c1">// protected 접근 제한자는 class instance를 통해 class 외부에서 참조할 수 없음</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">y</span><span class="p">);</span>    <span class="c1">// error TS2445: Property 'y' is protected and only accessible within class 'Foo' and its subclasses.</span>

<span class="c1">// private 접근 제한자는 class instance를 통해 class 외부에서 참조할 수 없음</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">z</span><span class="p">);</span>    <span class="c1">// error TS2341: Property 'z' is private and only accessible within class 'Foo'.</span>

<span class="kd">class</span> <span class="nx">Bar</span> <span class="kd">extends</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">z</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">);</span>

        <span class="c1">// public 접근 제한자는 자식 class 내부에서 참조 가능함</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>

        <span class="c1">// protected 접근 제한자는 자식 class 내부에서 참조 가능함</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="p">);</span>

        <span class="c1">// private 접근 제한자는 자식 class 내부에서 참조할 수 없음</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">z</span><span class="p">);</span>    <span class="c1">// error TS2341: Property 'z' is private and only accessible within class 'Foo'.</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="생성자-parameter에-접근-제한자-선언">생성자 Parameter에 접근 제한자 선언</h3>

<ul>
  <li>생성자(constructor) parameter에도 접근 제한자를 선언할 수 있습니다.</li>
  <li><strong>접근 제한자가 사용된 생성자 parameter</strong>는 <strong>암묵적으로 class property로 선언</strong>되고, 생성자 내부에서 별도의 초기화가 없어도 <strong>암묵적으로 초기화가 수행</strong>됩니다.</li>
</ul>

<h4 id="생성자-parameter에-private-public-접근-제한자-선언">생성자 Parameter에 <code class="highlighter-rouge">private</code>, <code class="highlighter-rouge">public</code> 접근 제한자 선언</h4>

<ul>
  <li><code class="highlighter-rouge">private</code> 접근 제한자가 사용되면, class 내부에서만 참조 가능하고, <code class="highlighter-rouge">public</code> 접근 제한자가 사용되면 class 외부에서도 참조가 가능합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="c1">// 접근 제한자가 선언된 생성자 parameter 'x'는 class property로 선언되고 지동으로 초기화됨</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="k">public</span> <span class="nx">x</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>    <span class="c1">// Foo { x: 'Hello' }</span>

<span class="c1">// public이 선언된 'foo.x'는 class 외부에서도 참조가 가능함</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>    <span class="c1">// Hello</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Bar</span> <span class="p">{</span>
    <span class="c1">// 접근 제한자가 선언된 생성자 parameter 'x'는 class property로 선언되고 지동으로 초기화됨</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="k">private</span> <span class="nx">x</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">bar</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Bar</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">);</span>    <span class="c1">// Bar { x: 'Hello' }</span>

<span class="c1">// private이 선언된 'bar.x'는 class 내부에서만 참조 가능함</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>    <span class="c1">// Property 'x' is private and only accessible within class 'Bar'.</span>
</code></pre></div></div>

<h4 id="생성자-parameter에-접근-제한자를-선언하지-않은-경우">생성자 Parameter에 접근 제한자를 선언하지 않은 경우</h4>

<ul>
  <li>생성자 parameter에 접근 제한자를 선언하지 않으면, 생성자 parameter는 생성자 내부에서만 유효한 지역 변수가 되어, 생성자 외부에서 참조가 불가능합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="c1">// 'x'는 생성자 내부에서만 유효한 지역 변수임 (접근 제한자가 선언되지 않아 class property 선언과 초기화가 되지 않음)</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>    <span class="c1">// Foo {}</span>
</code></pre></div></div>

<hr />

<h2 id="읽기-전용-속성-readonly-property">읽기 전용 속성 (Readonly Property)</h2>

<ul>
  <li>TypeScript class의 <code class="highlighter-rouge">readonly</code> keyword는 변수 할당 시의 <code class="highlighter-rouge">const</code> keyword와 유사합니다.</li>
  <li><code class="highlighter-rouge">readonly</code>가 선언된 class property는 선언 시 또는 생성자 내부에서만 값을 할당할 수 있습니다.
    <ul>
      <li>이 외의 경우에는 값을 할당할 수 없고, 오직 읽기만 가능한 상태가 됩니다.</li>
    </ul>
  </li>
  <li>일반적으로 상수를 선언할 때 사용합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="nx">MAX_LEN</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="nx">MSG</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>

    <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">MSG</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">log</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// readonly가 선언된 property는 재할당이 금지됨</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">MAX_LEN</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>    <span class="c1">// Cannot assign to 'MAX_LEN' because it is a constant or a read-only property.</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">MSG</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Hi</span><span class="dl">'</span><span class="p">;</span>    <span class="c1">// Cannot assign to 'MSG' because it is a constant or a read-only property.</span>

        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`MAX_LEN : </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">MAX_LEN</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>    <span class="c1">// MAX_LEN : 5</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`MSG : </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">MSG</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>    <span class="c1">// MSG : hello</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">new</span> <span class="nx">Foo</span><span class="p">().</span><span class="nx">log</span><span class="p">();</span>
</code></pre></div></div>

<hr />

<h2 id="static-member">Static Member</h2>

<ul>
  <li>TypeScript에서 <strong><code class="highlighter-rouge">static</code> keyword를 사용하여 class member를 정적으로 선언</strong>할 수 있습니다.
    <ul>
      <li>class member에는 method(함수)와 property(속성)가 있으며, 따라서 <strong>static member도 static method와 static property로 나뉩니다.</strong></li>
    </ul>
  </li>
</ul>

<h3 id="static-method">Static Method</h3>

<ul>
  <li>JavaScript ES6의 class에서 <code class="highlighter-rouge">static</code> keyword는 class의 정적(static) method를 정의합니다.
    <ul>
      <li>TypeScript에서도 JavaScript ES6와 동일한 방식으로 사용할 수 있습니다.</li>
    </ul>
  </li>
  <li>정적 method는 class의 instance가 아닌 <strong>class 이름으로 호출</strong>하기 때문에, class의 instance를 생성하지 않아도 호출할 수 있습니다.
    <ul>
      <li>정적 method는 <code class="highlighter-rouge">this</code>를 사용할 수 없으며, 정적 method 내부의 <code class="highlighter-rouge">this</code>는 class의 instance가 아닌 class 자신을 가리킵니다.</li>
    </ul>
  </li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">prop</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="nx">prop</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">static</span> <span class="nx">staticMethod</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="dl">'</span><span class="s1">staticMethod</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">prototypeMethod</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">prop</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 정적 method는 class 이름으로 호출함</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Foo</span><span class="p">.</span><span class="nx">staticMethod</span><span class="p">());</span>    <span class="c1">// staticMethod</span>

<span class="c1">// 정적 method는 instance로 호출할 수 없음</span>
<span class="kd">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">staticMethod</span><span class="p">());</span>    <span class="c1">// Uncaught TypeError: foo.staticMethod is not a function.</span>
</code></pre></div></div>

<h3 id="static-property">Static Property</h3>

<ul>
  <li><strong>TypeScript에서는 static keyword를 class property에도 사용</strong>할 수 있습니다.</li>
  <li>정적 method와 마찬가지로, 정적 class property는 instance가 아닌 class 이름으로 호출하며, class의 instance를 생성하지 않아도 호출할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="c1">// 생성된 instance의 갯수</span>
    <span class="k">static</span> <span class="nx">instanceCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 생성자가 호출될 때마다 counter를 1씩 증가시킴</span>
        <span class="nx">Foo</span><span class="p">.</span><span class="nx">instanceCounter</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">foo1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">foo2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">();</span>

<span class="c1">// 정적 class property는 class 이름으로 호출함</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Foo</span><span class="p">.</span><span class="nx">instanceCounter</span><span class="p">);</span>    <span class="c1">// 2</span>

<span class="c1">// 정적 class property는 instance로 호출할 수 없음</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo2</span><span class="p">.</span><span class="nx">instanceCounter</span><span class="p">);</span>    <span class="c1">// error TS2339: Property 'instanceCounter' does not exist on type 'Foo'.</span>
</code></pre></div></div>

<hr />

<h2 id="추상-class-abstract-class">추상 Class (Abstract Class)</h2>

<ul>
  <li>추상 class는 <strong>하나 이상의 추상 method를 포함</strong>하며, 일반 method도 포함할 수 있습니다.
    <ul>
      <li>추상 method는 내용이 없이 method 이름과 type만이 선언된 method입니다.</li>
    </ul>
  </li>
  <li>
    <p>추상 class와 추상 method를 선언할 때는 <code class="highlighter-rouge">abstract</code> keyword를 사용합니다.</p>
  </li>
  <li>추상 class는 직접 instance를 생성할 수 없고 상속만을 위해 사용됩니다.
    <ul>
      <li>추상 class를 상속한 class는 추상 class의 추상 method를 반드시 구현해야 합니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">interface</code> type은 추상 class와 비슷하지만, 일반 method를 선언할 수 없다는 점에서 추상 class와 다릅니다.
    <ul>
      <li><code class="highlighter-rouge">interface</code> type은 모든 method가 추상 method입니다.</li>
      <li>추상 class는 하나 이상의 추상 method와 일반 method를 포함할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nx">Animal</span> <span class="p">{</span>
    <span class="c1">// 추상 method</span>
    <span class="kd">abstract</span> <span class="nx">makeSound</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
    <span class="c1">// 일반 method</span>
    <span class="nx">move</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">roaming the earth...</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 직접 instance를 생성할 수 없음</span>
<span class="k">new</span> <span class="nx">Animal</span><span class="p">();</span>    <span class="c1">// error TS2511: Cannot create an instance of the abstract class 'Animal'.</span>

<span class="kd">class</span> <span class="nx">Dog</span> <span class="kd">extends</span> <span class="nx">Animal</span> <span class="p">{</span>
    <span class="c1">// 추상 class를 상속한 class는 추상 class의 추상 method를 반드시 구현해야 함</span>
    <span class="nx">makeSound</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">bowwow~~</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">myDog</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Dog</span><span class="p">();</span>
<span class="nx">myDog</span><span class="p">.</span><span class="nx">makeSound</span><span class="p">();</span>
<span class="nx">myDog</span><span class="p">.</span><span class="nx">move</span><span class="p">();</span>
</code></pre></div></div>

<hr />

<h2 id="interface-구현-implements">Interface 구현 (<code class="highlighter-rouge">implements</code>)</h2>

<ul>
  <li>class는 <code class="highlighter-rouge">implements</code> keyword를 사용하여 특정 interface를 구현하겠다고 선언할 수 있습니다.
    <ul>
      <li>class가 interface의 계약을 준수하도록 강제합니다.</li>
    </ul>
  </li>
  <li>class가 interface를 구현하는 경우, class는 interface에 정의된 모든 property와 method를 구현해야 합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Vehicle</span> <span class="p">{</span>
    <span class="nl">model</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">year</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nx">displayDetails</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Car</span> <span class="k">implements</span> <span class="nx">Vehicle</span> <span class="p">{</span>
    <span class="nl">model</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">year</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>

    <span class="kd">constructor</span><span class="p">(</span><span class="nx">model</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">year</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">model</span> <span class="o">=</span> <span class="nx">model</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">year</span> <span class="o">=</span> <span class="nx">year</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">displayDetails</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Model: </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">}</span><span class="s2">, Year: </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">year</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">myCar</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Car</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hyundai Sonata</span><span class="dl">"</span><span class="p">,</span> <span class="mi">2020</span><span class="p">);</span>
<span class="nx">myCar</span><span class="p">.</span><span class="nx">displayDetails</span><span class="p">();</span>
</code></pre></div></div>

<ul>
  <li>하나 이상의 interface를 구현할 수도 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Chargeable</span> <span class="p">{</span>
    <span class="nl">batteryLevel</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nx">charge</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Connectable</span> <span class="p">{</span>
    <span class="nl">isConnected</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>
    <span class="nx">connect</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
    <span class="nx">disconnect</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Smartphone</span> <span class="k">implements</span> <span class="nx">Chargeable</span><span class="p">,</span> <span class="nx">Connectable</span> <span class="p">{</span>
    <span class="nl">batteryLevel</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">isConnected</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>

    <span class="kd">constructor</span><span class="p">(</span><span class="nx">batteryLevel</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">batteryLevel</span> <span class="o">=</span> <span class="nx">batteryLevel</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">isConnected</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">charge</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">batteryLevel</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Smartphone 충전 완료</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">connect</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">isConnected</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Smartphone 연결</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">disconnect</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">isConnected</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Smartphone 연결 해제</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">myPhone</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Smartphone</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
<span class="nx">myPhone</span><span class="p">.</span><span class="nx">charge</span><span class="p">();</span>
<span class="nx">myPhone</span><span class="p">.</span><span class="nx">connect</span><span class="p">();</span>
<span class="nx">myPhone</span><span class="p">.</span><span class="nx">disconnect</span><span class="p">();</span>
</code></pre></div></div>

<hr />

<h2 id="reference-6">Reference</h2>

<ul>
  <li><a href="https://poiemaweb.com/typescript-class">https://poiemaweb.com/typescript-class</a></li>
</ul>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-object-type---interface-객체-계약서">TypeScript Object Type - Interface (객체 계약서)</h1>

<h2 id="interface--객체-계약서">Interface : 객체 계약서</h2>

<ul>
  <li>TypeScript의 interface는 <strong>변수, 함수, class가 특정 구조와 type을 갖추도록 명시</strong>하는 데 사용됩니다.
    <ul>
      <li>여러 type의 property로 이루어진 새로운 type을 정의하는 것과 같습니다.
        <ul>
          <li>interface에 선언된 property 또는 method의 구현을 강제하여 일관성을 유지할 수 있도록 합니다.</li>
        </ul>
      </li>
      <li>interface는 <strong>객체가 구현해야 할 구체적인 사항을 지정하고, 지키도록 강제</strong>합니다.</li>
    </ul>
  </li>
  <li>interface는 compile time에 구조와 type을 검사하기 위해 사용되며, runtime에는 제거됩니다.
    <ul>
      <li>TypeScript file이 compile된 JavaScript file에는 interface에 대한 code가 없습니다.</li>
    </ul>
  </li>
  <li>JavaScript ES6는 interface를 지원하지 않지만, TypeScript는 interface를 지원합니다.
    <ul>
      <li>TypeScript는 interface를 통해 개발자가 더 명확하고 유지보수가 용이한 code를 작성할 수 있도록 합니다.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="변수와-interface">변수와 Interface</h2>

<ul>
  <li>interface는 변수의 type으로 사용할 수 있습니다.</li>
  <li>interface를 type으로 선언한 변수는 해당 interface를 준수하여야 합니다.</li>
  <li>interface를 정의하는 것은 새로운 type을 정의하는 것과 유사합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Todo</span> <span class="p">{</span>
    <span class="nl">id</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">content</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">completed</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 변수 'todo'의 type으로 'Todo' interface를 선언함</span>
<span class="kd">let</span> <span class="nx">todo</span><span class="p">:</span> <span class="nx">Todo</span><span class="p">;</span>

<span class="c1">// 변수 todo는 Todo interface를 준수해야 함</span>
<span class="nx">todo</span> <span class="o">=</span> <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">content</span><span class="p">:</span> <span class="dl">'</span><span class="s1">typescript</span><span class="dl">'</span><span class="p">,</span> <span class="na">completed</span><span class="p">:</span> <span class="kc">false</span> <span class="p">};</span>
</code></pre></div></div>

<ul>
  <li>interface를 사용하여 함수 parameter의 type을 선언할 수 있습니다.
    <ul>
      <li>해당 함수에는 함수 parameter의 type으로 지정한 interface를 준수하는 인수를 전달해야 합니다.</li>
      <li>함수에 객체를 전달할 때 복잡한 매개 변수 검사 과정이 필요 없어서 매우 유용합니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Todo</span> <span class="p">{</span>
    <span class="nl">id</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">content</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">completed</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">todos</span><span class="p">:</span> <span class="nx">Todo</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>

<span class="c1">// parameter 'todo'의 type으로 'Todo' interface를 선언함</span>
<span class="kd">function</span> <span class="nx">addTodo</span><span class="p">(</span><span class="nx">todo</span><span class="p">:</span> <span class="nx">Todo</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">todos</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">todos</span><span class="p">,</span> <span class="nx">todo</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// parameter 'todo'는 'Todo' interface를 준수해야 함</span>
<span class="kd">const</span> <span class="nx">newTodo</span><span class="p">:</span> <span class="nx">Todo</span> <span class="o">=</span> <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">content</span><span class="p">:</span> <span class="dl">'</span><span class="s1">typescript</span><span class="dl">'</span><span class="p">,</span> <span class="na">completed</span><span class="p">:</span> <span class="kc">false</span> <span class="p">};</span>
<span class="nx">addTodo</span><span class="p">(</span><span class="nx">newTodo</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">todos</span><span class="p">);</span>    <span class="c1">// [ { id: 1, content: 'typescript', completed: false } ]</span>
</code></pre></div></div>

<hr />

<h2 id="함수와-interface">함수와 Interface</h2>

<ul>
  <li>interface는 함수의 type으로 사용할 수 있습니다.</li>
  <li>함수의 interface에는 type이 선언된 parameter list와 return type을 정의합니다.</li>
  <li>함수 interface를 구현하는 함수는 interface를 준수하여야 한다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">SquareFunc</span> <span class="p">{</span>
    <span class="p">(</span><span class="nx">num</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 함수 interface를 구현하는 함수는 interface를 준수해야 함</span>
<span class="kd">const</span> <span class="nx">squareFunc</span><span class="p">:</span> <span class="nx">SquareFunc</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">num</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">num</span> <span class="o">*</span> <span class="nx">num</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">squareFunc</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>    <span class="c1">// 100</span>
</code></pre></div></div>

<hr />

<h2 id="class와-interface">Class와 Interface</h2>

<ul>
  <li>class 선언문의 <code class="highlighter-rouge">implements</code> 뒤에 interface를 선언하면, 해당 class는 지정된 interface를 반드시 구현해야 합니다.
    <ul>
      <li>이로써 interface를 구현하는 class들은 일관성을 유지할 수 있게 됩니다.</li>
    </ul>
  </li>
  <li>interface는 property와 method를 가질 수 있다는 점에서 class와 유사하나, 직접 instance를 생성할 수는 없습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">ITodo</span> <span class="p">{</span>
    <span class="nl">id</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">content</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">completed</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 'Todo' class는 'ITodo' interface를 구현해야 함</span>
<span class="kd">class</span> <span class="nx">Todo</span> <span class="k">implements</span> <span class="nx">ITodo</span> <span class="p">{</span>
    <span class="kd">constructor</span> <span class="p">(</span>
        <span class="k">public</span> <span class="nx">id</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span>
        <span class="k">public</span> <span class="nx">content</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span>
        <span class="k">public</span> <span class="nx">completed</span><span class="p">:</span> <span class="nx">boolean</span>
    <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">todo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Todo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Typescript</span><span class="dl">'</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">todo</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>interface는 property뿐만 아니라 method도 포함할 수 있으며, 추상 class와 달리 모든 method는 추상 method이어야 한다.
    <ul>
      <li>추상 class는 추상 method와 일반 method 모두 가질 수 있습니다.</li>
    </ul>
  </li>
  <li>interface를 구현하는 class는 interface에서 정의한 property와 추상 methdo를 반드시 구현해야 합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">IPerson</span> <span class="p">{</span>
    <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nx">sayHello</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 'Person' class는 'IPerson' interface에서 정의한 property와 추상 method를 반드시 구현해야 함</span>
<span class="kd">class</span> <span class="nx">Person</span> <span class="k">implements</span> <span class="nx">IPerson</span> <span class="p">{</span>
    <span class="c1">// interface에서 정의한 property 구현</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="k">public</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="c1">// interface에서 정의한 추상 method 구현</span>
    <span class="nx">sayHello</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hello </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">greeter</span><span class="p">(</span><span class="nx">person</span><span class="p">:</span> <span class="nx">IPerson</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="nx">person</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">'</span><span class="s1">Lee</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">greeter</span><span class="p">(</span><span class="nx">me</span><span class="p">);</span>    <span class="c1">// Hello Lee</span>
</code></pre></div></div>

<h3 id="비슷하지만-다른-interface와-추상-class">비슷하지만 다른 Interface와 추상 Class</h3>

<ul>
  <li>interface와 추상 class(abstract class)는 method, property의 구조와 type을 강제하고, 추상 method(구현 없이 선언만 한 method)를 가진다는 점에서 비슷하지만, 몇 가지 다른 점이 있습니다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Interface</th>
      <th>Abstract Class</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>주로 <strong>type check를 위해 사용</strong>됩니다.<br />객체의 구조를 정의하며, 이 구조에 따라 객체가 형성되어야 함을 명시합니다.</td>
      <td><strong>구현과 상속을 위해 사용</strong>됩니다.<br />일부 기능을 구현하고, 나머지 기능은 상속받는 class에서 구현하도록 강제할 수 있습니다.</td>
    </tr>
    <tr>
      <td>property과 method의 signature(추상 method 등)만을 정의할 수 있으며, <strong>구현을 포함할 수 없습니다.</strong></td>
      <td>추상 method뿐만 아니라 <strong>구현(일반 method 등)도 포함할 수 있습니다.</strong></td>
    </tr>
    <tr>
      <td>class는 <strong>여러 interface를 구현(implement)</strong>할 수 있습니다.<br />이를 통해 <strong>다중 상속</strong>과 유사한 효과를 낼 수 있습니다.</td>
      <td>class는 <strong>하나의 추상 class만 상속(extend)</strong>할 수 있습니다.<br />이는 JavaScript와 TypeScript에서 다중 상속을 지원하지 않기 때문입니다.</td>
    </tr>
    <tr>
      <td><strong>runtime에는 존재하지 않습니다.</strong><br />TypeScript를 JavaScript로 compile할 때 interface는 제거됩니다.</td>
      <td><strong>runtime에도 존재합니다.</strong><br />compile 후에도 JavaScript code에 추상 class는 남습니다.</td>
    </tr>
    <tr>
      <td>특별한 keyword 없이 추상 method를 정의합니다.</td>
      <td><code class="highlighter-rouge">abstract</code> keyword를 사용하여 추상 method를 정의합니다.</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><strong>다중 상속이 필요하거나 type check만이 목적이라면 interface</strong>를, <strong>구현을 공유하고 싶다면 추상 class</strong>를 사용하는 것이 좋습니다.</li>
</ul>

<hr />

<h2 id="선택적-속성-optional-property">선택적 속성 (Optional Property)</h2>

<ul>
  <li>선택적 속성(optional property)을 선언하여 <strong>interface의 property를 선택적으로 구현</strong>할 수 있습니다.
    <ul>
      <li>interface의 일반적인 property는 반드시 구현해야 합니다.</li>
    </ul>
  </li>
  <li>선택적 속성은 property 이름 뒤에 물음표(<code class="highlighter-rouge">?</code>)를 붙이며, 구현을 생략해도 오류가 발생하지 않습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">UserInfo</span> <span class="p">{</span>
    <span class="nl">username</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">password</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">age</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">address</span><span class="p">?:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">userInfo</span><span class="p">:</span> <span class="nx">UserInfo</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">username</span><span class="p">:</span> <span class="dl">'</span><span class="s1">simin@gmail.com</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">password</span><span class="p">:</span> <span class="dl">'</span><span class="s1">123456</span><span class="dl">'</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">userInfo</span><span class="p">);</span>
</code></pre></div></div>

<hr />

<h2 id="interface-상속-interface-확장">Interface 상속 (Interface 확장)</h2>

<ul>
  <li>interface는 <code class="highlighter-rouge">extends</code> keyword를 사용하여 interface 또는 class를 상속받을 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
    <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">age</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Student</span> <span class="kd">extends</span> <span class="nx">Person</span> <span class="p">{</span>
    <span class="nl">grade</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">student</span><span class="p">:</span> <span class="nx">Student</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Lee</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">age</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
    <span class="na">grade</span><span class="p">:</span> <span class="mi">3</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>복수의 interface를 상속받을 수도 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
    <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">age</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Developer</span> <span class="p">{</span>
    <span class="nl">skills</span><span class="p">:</span> <span class="kr">string</span><span class="p">[];</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">WebDeveloper</span> <span class="kd">extends</span> <span class="nx">Person</span><span class="p">,</span> <span class="nx">Developer</span> <span class="p">{}</span>

<span class="kd">const</span> <span class="nx">webDeveloper</span><span class="p">:</span> <span class="nx">WebDeveloper</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Lee</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">age</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
    <span class="na">skills</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">HTML</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">CSS</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">JavaScript</span><span class="dl">'</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>interface는 interface뿐만 아니라 class도 상속받을 수 있습니다.</li>
  <li>이때 class의 모든 member(<code class="highlighter-rouge">public</code>, <code class="highlighter-rouge">protected</code>, <code class="highlighter-rouge">private</code>)가 상속되지만, 구현까지 상속하지는 않습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Person</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="k">public</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="k">public</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Developer</span> <span class="kd">extends</span> <span class="nx">Person</span> <span class="p">{</span>
    <span class="nl">skills</span><span class="p">:</span> <span class="kr">string</span><span class="p">[];</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">developer</span><span class="p">:</span> <span class="nx">Developer</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Lee</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">age</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
    <span class="na">skills</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">HTML</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">CSS</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">JavaScript</span><span class="dl">'</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="reference-7">Reference</h2>

<ul>
  <li><a href="https://poiemaweb.com/typescript-interface">https://poiemaweb.com/typescript-interface</a></li>
</ul>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-object-type---tuple-고정-배열">TypeScript Object Type - Tuple (고정 배열)</h1>

<h2 id="tuple-type--갯수와-type이-정해진-배열-type">Tuple Type : 갯수와 Type이 정해진 배열 Type</h2>

<ul>
  <li>TypeScript에서 tuple은 고정된 개수의 요소와 각 요소의 type이 정해진 배열 type입니다.</li>
  <li>tuple을 사용하면 서로 다른 type의 data를 grouping하여 관리할 수 있으며, 각 요소의 정확한 type을 알 수 있어 type 안정성을 보장합니다.</li>
  <li>tuple은 배열과 유사하게 작동하지만, 배열 내의 각 위치에 특정 type을 지정할 수 있다는 점에서 차이가 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">tuple</span><span class="p">:</span> <span class="p">[</span><span class="kr">string</span><span class="p">,</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">boolean</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">""</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span><span class="p">];</span>
</code></pre></div></div>

<ul>
  <li>tuple을 정의할 때는 각 요소의 type을 괄호 안에 comma(<code class="highlighter-rouge">,</code>)로 구분하여 나열합니다.</li>
</ul>

<h3 id="비슷하지만-다른-배열과-tuple">비슷하지만 다른 배열과 Tuple</h3>

<ul>
  <li>배열(array)과 tuple은 TypeScript에서 data를 순서대로 저장하는 데 사용되는 구조이지만, 각각의 특성과 사용 목적이 다릅니다.
    <ul>
      <li>배열은 동일한 type의 data를 다룰 때 사용합니다.</li>
      <li>tuple은 고정된 수의 서로 다른 type의 data를 다룰 때 사용합니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Array */</span>
<span class="kd">let</span> <span class="nx">array</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">genericArray</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">Apple</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Banana</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Cherry</span><span class="dl">"</span><span class="p">];</span>

<span class="cm">/* Tuple */</span>
<span class="kd">let</span> <span class="nx">tuple1</span><span class="p">:</span> <span class="p">[</span><span class="kr">string</span><span class="p">,</span> <span class="kr">number</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">tuple2</span><span class="p">:</span> <span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">boolean</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Steve</span><span class="dl">"</span><span class="p">,</span> <span class="kc">true</span><span class="p">];</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>배열</th>
      <th>Tuple</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>동일한 type의 요소만 포함할 수 있음.</td>
      <td>각 요소가 서로 다른 type을 가질 수 있음.</td>
    </tr>
    <tr>
      <td>길이가 가변적임. 갯수 제한이 없음.</td>
      <td>길이가 고정적임. 정의된 요소의 개수만큼의 data가 저장됨.</td>
    </tr>
    <tr>
      <td>type이 동일한 많은 양의 data를 처리할 때 사용.</td>
      <td>여러 type의 data를 한 번에 관리할 필요가 있을 때 사용.</td>
    </tr>
    <tr>
      <td>동일한 type의 data 집합을 나타내는 데 사용</td>
      <td>각 요소의 type을 명시적으로 정의하여 data 구조의 의도를 명확하게 전달하기 위해 사용.</td>
    </tr>
  </tbody>
</table>

<h3 id="tuple-요소에-접근하기">Tuple 요소에 접근하기</h3>

<ul>
  <li>tuple 내의 각 요소에 접근하는 것은 배열과 유사하게, index를 통해 이루어집니다.</li>
  <li>다만, tuple에서는 각 요소가 특정 type으로 지정되어 있기 때문에, 해당 index에 접근하면 TypeScript는 자동으로 올바른 type을 추론합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">person</span><span class="p">:</span> <span class="p">[</span><span class="kr">string</span><span class="p">,</span> <span class="kr">number</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">];</span>

<span class="kd">let</span> <span class="nx">personName</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="nx">person</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>    <span class="c1">// Alice (string type으로 자동 추론됨)</span>
<span class="kd">let</span> <span class="nx">personAge</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="nx">person</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>    <span class="c1">// 30 (number type으로 자동 추론됨)</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">person</code> tuple은 첫 번째 요소로 문자열(<code class="highlighter-rouge">string</code>)을, 두 번째 요소로 숫자(<code class="highlighter-rouge">number</code>)를 가집니다.</li>
  <li>각 요소에 접근할 때 TypeScript는 해당 index의 type을 알고 있으므로, type 안전성이 보장됩니다.</li>
</ul>

<h3 id="tuple-요소-변경하기">Tuple 요소 변경하기</h3>

<ul>
  <li>tuple의 값은 각 요소의 index를 통해 직접 접근하여 변경할 수 있습니다.</li>
  <li>이때, 변경하려는 요소의 type은 tuple에서 정의된 해당 요소의 type과 일치해야만 합니다.</li>
  <li>또한 tuple은 고정된 길이를 가지므로, 새로운 요소를 추가하여 tuple의 길이를 변경하는 것은 type 정의에 위배됩니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">person</span><span class="p">:</span> <span class="p">[</span><span class="kr">string</span><span class="p">,</span> <span class="kr">number</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">];</span>

<span class="nx">person</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Bob</span><span class="dl">"</span><span class="p">;</span>    <span class="c1">// 첫 번째 요소(이름) 변경</span>
<span class="nx">person</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>    <span class="c1">// 두 번째 요소(나이) 변경</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">);</span>    <span class="c1">// ["Bob", 32]</span>
</code></pre></div></div>

<ul>
  <li>각 요소를 변경할 때는 tuple에서 해당 위치에 정의된 type에 맞는 값을 할당해야 합니다.
    <ul>
      <li>e.g., 숫자 type이 요구되는 위치에 문자열을 할당하려고 하면 TypeScript compiler는 type 오류를 발생시킵니다.</li>
    </ul>
  </li>
</ul>

<h4 id="tuple의-요소를-변경할-수-없는-경우">Tuple의 요소를 변경할 수 없는 경우</h4>

<ul>
  <li>읽기 전용 tuple은 변경할 수 없습니다.</li>
  <li><code class="highlighter-rouge">readonly</code>로 선언된 tuple은 그 요소를 변경할 수 없으며, 시도하면 compile time에 오류가 발생합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">readonlyPerson</span><span class="p">:</span> <span class="k">readonly</span> <span class="p">[</span><span class="kr">string</span><span class="p">,</span> <span class="kr">number</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">];</span>

<span class="nx">readonlyPerson</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Bob</span><span class="dl">"</span><span class="p">;</span>    <span class="c1">// Error: Index signature in type 'readonly [string, number]' only permits reading.</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">readonly</code> tuple은 data의 불변성을 유지해야 할 때 유용하며, 이러한 tuple의 요소는 생성 시에만 할당할 수 있고, 이후에는 변경할 수 없습니다.</li>
</ul>

<hr />

<h2 id="tuple-고급-기능">Tuple 고급 기능</h2>

<h3 id="선택적-tuple-요소">선택적 Tuple 요소</h3>

<ul>
  <li>TypeScript 3.0 이상에서는 tuple 내 요소를 선택적(optional)으로 만들 수 있습니다.</li>
  <li>선택적 요소는 type 뒤에 물음표 기호(<code class="highlighter-rouge">?</code>)를 붙여 표시하며, 해당 위치에 값이 있거나 없을 수 있음을 의미합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">optionalTuple</span><span class="p">:</span> <span class="p">[</span><span class="kr">string</span><span class="p">,</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">boolean</span><span class="p">?]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">Bob</span><span class="dl">"</span><span class="p">,</span> <span class="mi">25</span><span class="p">];</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">optionalTuple</code>은 세 번째 요소로 <code class="highlighter-rouge">boolean</code> type을 가질 수도 있고, 아예 없을 수도 있습니다.</li>
</ul>

<h3 id="나머지-요소와-tuple">나머지 요소와 Tuple</h3>

<ul>
  <li>tuple에서 나머지 요소(rest element)를 사용하여, 특정 위치 이후의 모든 요소에 대해 같은 type을 지정할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">restTuple</span><span class="p">:</span> <span class="p">[</span><span class="kr">string</span><span class="p">,</span> <span class="p">...</span><span class="kr">number</span><span class="p">[]]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">restTuple</code>은 첫 번째 요소로 <code class="highlighter-rouge">string</code>을, 그리고 나머지 요소로 <code class="highlighter-rouge">number</code> 배열을 가지는 tuple입니다.</li>
</ul>

<h3 id="tuple과-구조-분해-할당">Tuple과 구조 분해 할당</h3>

<ul>
  <li>tuple은 구조 분해 할당(destructuring assignment)과 함께 사용 가능합니다.
    <ul>
      <li>구조 분해를 사용하면 tuple의 각 요소를 개별 변수에 쉽게 할당할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">employee</span><span class="p">:</span> <span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="kr">string</span><span class="p">,</span> <span class="kr">string</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Steve</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Developer</span><span class="dl">"</span><span class="p">];</span>

<span class="c1">// 구조 분해 할당을 사용하여 tuple 요소를 변수에 할당</span>
<span class="kd">let</span> <span class="p">[</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">position</span><span class="p">]</span> <span class="o">=</span> <span class="nx">employee</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>    <span class="c1">// 1</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>    <span class="c1">// Steve</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">position</span><span class="p">);</span>    <span class="c1">// Developer</span>
</code></pre></div></div>

<h3 id="tuple-type에서의-spread-연산자">Tuple Type에서의 Spread 연산자</h3>

<ul>
  <li>spread 연산자(<code class="highlighter-rouge">...</code>)는 tuple type에서도 사용할 수 있습니다.</li>
  <li>spread 연산자로 tuple의 요소를 다른 tuple이나 배열에 쉽게 결합할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">part1</span><span class="p">:</span> <span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="kr">string</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Steve</span><span class="dl">"</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">part2</span><span class="p">:</span> <span class="p">[</span><span class="kr">string</span><span class="p">,</span> <span class="kr">number</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">Developer</span><span class="dl">"</span><span class="p">,</span> <span class="mi">50000</span><span class="p">];</span>

<span class="kd">let</span> <span class="nx">employee</span><span class="p">:</span> <span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="kr">string</span><span class="p">,</span> <span class="kr">string</span><span class="p">,</span> <span class="kr">number</span><span class="p">]</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">part1</span><span class="p">,</span> <span class="p">...</span><span class="nx">part2</span><span class="p">];</span>
</code></pre></div></div>

<h3 id="읽기-전용-tuple">읽기 전용 Tuple</h3>

<ul>
  <li>TypeScript는 읽기 전용 배열(<code class="highlighter-rouge">ReadonlyArray&lt;T&gt;</code>)과 유사하게, 읽기 전용 tuple(<code class="highlighter-rouge">readonly [T, U, ...]</code>)을 지원합니다.</li>
  <li>읽기 전용 tuple을 사용하면 tuple의 요소를 변경할 수 없게 만들 수 있어, 불변성을 보장할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">readOnlyTuple</span><span class="p">:</span> <span class="k">readonly</span> <span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="kr">string</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Steve</span><span class="dl">"</span><span class="p">];</span>
<span class="nx">readOnlyTuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>    <span class="c1">// 에러: 읽기 전용 속성이므로 '0'에 할당할 수 없습니다.</span>
</code></pre></div></div>

<h3 id="label이-있는-tuple-요소">Label이 있는 Tuple 요소</h3>

<ul>
  <li>TypeScript 4.0부터는 tuple 요소에 label을 지정할 수 있게 되었습니다.
    <ul>
      <li>label을 지정하여 코드의 가독성을 높이고, tuple의 구조를 더 명확하게 표현할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">person</span><span class="p">:</span> <span class="p">[</span><span class="nx">id</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Steve</span><span class="dl">"</span><span class="p">];</span>
</code></pre></div></div>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-combined-type-여러-type이-조합된-type">TypeScript Combined Type (여러 Type이 조합된 Type)</h1>

<h2 id="combined-type--두-개-이상의-type들이-조합된-type">Combined Type : 두 개 이상의 Type들이 조합된 Type</h2>

<ul>
  <li>TypeScript는 <strong>다양한 type들을 조합</strong>해 복잡한 type checking을 가능하게 하는 고급 type 기능을 제공합니다.</li>
  <li>이 중 intersection type과 union type은 type의 조합을 표현하는 데 사용되는 두 가지 주요한 방법입니다.
    <ul>
      <li>두 조합된 type은 서로 다른 방식으로 type을 조합합니다.</li>
    </ul>
  </li>
</ul>

<h3 id="intersection-type">Intersection Type</h3>

<ul>
  <li>intersection type은 <strong>여러 type을 결합해 모든 type의 특성을 포함하는 새로운 type을 생성</strong>합니다.</li>
  <li>이는 <code class="highlighter-rouge">&amp;</code> 연산자를 사용하여 표현되며, 다양한 interface 또는 type을 하나로 합쳐 새로운 type을 정의할 때 유용합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Employee</span> <span class="p">{</span>
    <span class="nl">employeeId</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Manager</span> <span class="p">{</span>
    <span class="nl">stockPlan</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">EmployeeManager</span> <span class="o">=</span> <span class="nx">Employee</span> <span class="o">&amp;</span> <span class="nx">Manager</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">john</span><span class="p">:</span> <span class="nx">EmployeeManager</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">employeeId</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
    <span class="na">age</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
    <span class="na">stockPlan</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">EmployeeManager</code> type은 <code class="highlighter-rouge">Employee</code>와 <code class="highlighter-rouge">Manager</code> interface의 모든 속성을 결합한 intersection type입니다.</li>
  <li><code class="highlighter-rouge">john</code> 객체는 이 intersection type에 따라 <code class="highlighter-rouge">Employee</code>와 <code class="highlighter-rouge">Manager</code>의 모든 특성을 갖추어야 합니다.</li>
</ul>

<h3 id="union-type-1">Union Type</h3>

<ul>
  <li>union type은 <strong>변수가 여러 type 중 하나를 가질 수 있음</strong>을 나타내며, <code class="highlighter-rouge">|</code> 연산자를 사용하여 type을 정의합니다.</li>
  <li>이는 함수가 다양한 type의 인자를 받거나, 다양한 type의 값을 반환할 때 유용하게 사용됩니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">StringOrNumber</span> <span class="o">=</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">logMessage</span><span class="p">(</span><span class="nx">message</span><span class="p">:</span> <span class="nx">StringOrNumber</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">message</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">String message:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">message</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Number message:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">message</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">logMessage</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello, TypeScript!</span><span class="dl">"</span><span class="p">);</span>    <span class="c1">// String message: Hello, TypeScript!</span>
<span class="nx">logMessage</span><span class="p">(</span><span class="mi">101</span><span class="p">);</span>    <span class="c1">// Number message: 101</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">StringOrNumber</code> union type은 <code class="highlighter-rouge">string</code> 또는 <code class="highlighter-rouge">number</code> type의 값을 가질 수 있습니다.</li>
  <li><code class="highlighter-rouge">logMessage</code> 함수는 이 union type을 매개 변수로 받아, type에 따라 다른 작업을 수행합니다.</li>
</ul>

<hr />

<h2 id="intersection-type과-union-type의-차이점">Intersection Type과 Union Type의 차이점</h2>

<ul>
  <li>intersection type은 복잡한 type을 정확하게 표현할 수 있게 하는 반면, union type은 함수나 변수가 더 다양한 type을 유연하게 처리할 수 있도록 합니다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Intersection Type</th>
      <th>Union Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>서로 다른 type들을 결합하여 모든 type의 특성을 포함하는 새로운 type을 정의함</td>
      <td>여러 type 중 하나의 type을 가질 수 있는 type을 정의함</td>
    </tr>
    <tr>
      <td><strong>‘그리고(And)’의 개념</strong>으로, 여러 type의 특성을 <strong>모두 만족</strong>해야 함</td>
      <td><strong>‘또는(Or)’의 개념</strong>으로, 정의된 type 중 <strong>하나만 만족</strong>하면 됨</td>
    </tr>
  </tbody>
</table>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-combined-type---intersection-객체-속성-합치기">TypeScript Combined Type - Intersection (객체 속성 합치기)</h1>

<h2 id="intersection-type---객체-합치기">Intersection Type - 객체 합치기</h2>

<ul>
  <li>TypeScript의 intersection type은 <strong>여러 type들을 결합해, 모든 type의 속성(property)을 포함하는 복합 type을 생성</strong>합니다.
    <ul>
      <li>다양한 interface나 type들의 특성을 통합하여, <strong>필요한 모든 속성을 가진 새로운 type을 정의</strong>할 때 사용됩니다.</li>
    </ul>
  </li>
  <li>intersection type은 복잡한 data 구조의 표현, 다양한 source의 data 통합, 여러 interface의 구현 등 다양한 상황에 활용될 수 있습니다.
    <ul>
      <li>특히 여러 type의 속성을 동시에 만족해야 하는 객체를 다룰 때 유용합니다.</li>
    </ul>
  </li>
  <li>여러 type들을 <code class="highlighter-rouge">&amp;</code> 연산자로 결합하여 intersection type을 만듭니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Type1</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">b</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Type2</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">c</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">IntersectionType</span> <span class="o">=</span> <span class="nx">Type1</span> <span class="o">&amp;</span> <span class="nx">Type2</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">intersectionType</span><span class="p">:</span> <span class="nx">IntersectionType</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="na">b</span><span class="p">:</span> <span class="dl">"</span><span class="s2">String</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">c</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="intersection-type-사용-주의사항--type-충돌">Intersection Type 사용 주의사항 : Type 충돌</h3>

<ul>
  <li>intersection type을 사용할 때는 주의가 필요합니다.</li>
  <li><strong>결합되는 type들 사이에 중복되는 속성이 없도록 해야</strong> 하며, 만약 <strong>중복된 속성이 있을 경우 해당 속성은 모든 결합된 type에서 공통으로 만족하는 type이 되어야</strong> 합니다.
    <ul>
      <li>서로 다른 type으로 정의된 동일한 이름의 속성을 가진 type들을 결합하려 하면, type 충돌이 발생합니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Product</span> <span class="p">{</span>
    <span class="nl">id</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Order</span> <span class="p">{</span>
    <span class="nl">id</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>    <span class="c1">// Product interface와 동일한 속성명이지만, type이 다름</span>
    <span class="nl">quantity</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ProductOrder</span> <span class="o">=</span> <span class="nx">Product</span> <span class="o">&amp;</span> <span class="nx">Order</span><span class="p">;</span>    <span class="c1">// Error : type 충돌</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">id</code> 속성은 <code class="highlighter-rouge">Product</code> interface에서는 <code class="highlighter-rouge">number</code> type이고, <code class="highlighter-rouge">Order</code> interface에서는 <code class="highlighter-rouge">string</code> type으로 정의되어 있어 type 충돌이 발생합니다.</li>
  <li>따라서, <code class="highlighter-rouge">ProductOrder</code> type을 사용하여 객체를 생성하려고 할 때, 오류가 발생합니다.</li>
</ul>

<hr />

<h2 id="intersection-type-활용하기">Intersection Type 활용하기</h2>

<ul>
  <li>type alias 외에도 함수 매개 변수, interface 확장, generic과 같은 여러 방식으로 적용할 수 있어, 상황에 따라 type의 유연성과 재사용성을 높일 수 있습니다.</li>
</ul>

<h3 id="type-alias-합치기">Type Alias 합치기</h3>

<ul>
  <li>두 개의 기본적인 type alias을 정의하고, 이를 합쳐서 intersection type을 만듭니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 첫 번째 type 별칭 정의</span>
<span class="kd">type</span> <span class="nx">Color</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">color</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 두 번째 type 별칭 정의</span>
<span class="kd">type</span> <span class="nx">Dimension</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">width</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="nl">height</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Color와 Dimension type을 결합하여 ColoredRectangle intersection type 생성</span>
<span class="kd">type</span> <span class="nx">ColoredRectangle</span> <span class="o">=</span> <span class="nx">Color</span> <span class="o">&amp;</span> <span class="nx">Dimension</span><span class="p">;</span>

<span class="c1">// ColoredRectangle type의 객체 생성 예시</span>
<span class="kd">const</span> <span class="nx">myRectangle</span><span class="p">:</span> <span class="nx">ColoredRectangle</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">color</span><span class="p">:</span> <span class="dl">"</span><span class="s2">blue</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">width</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
  <span class="na">height</span><span class="p">:</span> <span class="mi">10</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">myRectangle</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">ColoredRectangle</code> intersection type은 <code class="highlighter-rouge">Color</code> type의 <code class="highlighter-rouge">color</code> 속성과 <code class="highlighter-rouge">Dimension</code> type의 <code class="highlighter-rouge">width</code> 및 <code class="highlighter-rouge">height</code> 속성을 모두 포함합니다.</li>
</ul>

<h3 id="interface-확장하기">Interface 확장하기</h3>

<ul>
  <li>서로 다른 interface를 결합하여, 각 interface의 모든 속성을 포함하는 새로운 type을 만듭니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">User</span> <span class="p">{</span>
    <span class="nl">id</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Permissions</span> <span class="p">{</span>
    <span class="nl">permissions</span><span class="p">:</span> <span class="kr">string</span><span class="p">[];</span>
<span class="p">}</span>

<span class="c1">// User와 Permissions의 특성을 모두 갖는 AdminUser type</span>
<span class="kd">type</span> <span class="nx">AdminUser</span> <span class="o">=</span> <span class="nx">User</span> <span class="o">&amp;</span> <span class="nx">Permissions</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">admin</span><span class="p">:</span> <span class="nx">AdminUser</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Admin</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">permissions</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">create</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">read</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">update</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">delete</span><span class="dl">"</span><span class="p">]</span>
<span class="p">};</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">User</code>와 <code class="highlighter-rouge">Permissions</code> interface를 결합하여 <code class="highlighter-rouge">AdminUser</code> type을 생성합니다.</li>
</ul>

<h4 id="interface-확장하기--상속-version">Interface 확장하기 : 상속 Version</h4>

<ul>
  <li>interface의 상속(<code class="highlighter-rouge">extends</code>) 기능을 사용하면, intersection type(<code class="highlighter-rouge">&amp;</code>)을 사용하는 것과 같은 결과를 얻을 수 있습니다.
    <ul>
      <li><code class="highlighter-rouge">extends</code> keyword를 사용하여, 한 interface가 다른 하나 또는 여러 interface의 속성을 상속받도록 할 수 있습니다.</li>
    </ul>
  </li>
  <li>여러 interface를 확장하여 새 interface를 만들면, 확장된 interface는 모든 부모 interface의 속성을 포함하게 됩니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">User</span> <span class="p">{</span>
    <span class="nl">id</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Permissions</span> <span class="p">{</span>
    <span class="nl">permissions</span><span class="p">:</span> <span class="kr">string</span><span class="p">[];</span>
<span class="p">}</span>

<span class="c1">// User와 Permissions interface를 상속받아 AdminUser interface 정의</span>
<span class="kr">interface</span> <span class="nx">AdminUser</span> <span class="kd">extends</span> <span class="nx">User</span><span class="p">,</span> <span class="nx">Permissions</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">admin</span><span class="p">:</span> <span class="nx">AdminUser</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Admin</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">permissions</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">create</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">read</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">update</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">delete</span><span class="dl">"</span><span class="p">]</span>
<span class="p">};</span>
</code></pre></div></div>

<ul>
  <li>interface 상속을 사용하여 <code class="highlighter-rouge">User</code>와 <code class="highlighter-rouge">Permissions</code> interface의 특성을 모두 갖는 <code class="highlighter-rouge">AdminUser</code> interface를 정의합니다.
    <ul>
      <li><code class="highlighter-rouge">AdminUser</code> interface는 <code class="highlighter-rouge">User</code>와 <code class="highlighter-rouge">Permissions</code> interface의 모든 속성을 상속받습니다.</li>
      <li>따라서 <code class="highlighter-rouge">AdminUser</code> type의 객체를 생성할 때, <code class="highlighter-rouge">User</code>와 <code class="highlighter-rouge">Permissions</code> interface에서 정의된 모든 field를 포함해야 합니다.</li>
    </ul>
  </li>
</ul>

<h3 id="함수-매개-변수의-type-확장하기">함수 매개 변수의 Type 확장하기</h3>

<ul>
  <li>함수가 받는 매개 변수의 type을 더 상세하게 지정하고자 할 때, intersection type을 활용할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">User</span> <span class="p">{</span>
    <span class="nl">id</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">createUserSession</span><span class="p">(</span><span class="nx">user</span><span class="p">:</span> <span class="nx">User</span> <span class="o">&amp;</span> <span class="p">{</span> <span class="na">sessionId</span><span class="p">:</span> <span class="kr">string</span> <span class="p">})</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`User </span><span class="p">${</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2"> has session ID: </span><span class="p">${</span><span class="nx">user</span><span class="p">.</span><span class="nx">sessionId</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">createUserSession</span><span class="p">({</span> <span class="na">id</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Jane Doe</span><span class="dl">"</span><span class="p">,</span> <span class="na">sessionId</span><span class="p">:</span> <span class="dl">"</span><span class="s2">abc123</span><span class="dl">"</span> <span class="p">});</span>
</code></pre></div></div>

<h3 id="generic과-함께-사용하기">Generic과 함께 사용하기</h3>

<ul>
  <li>intersection type을 통해 generic을 사용한 기능을 확장하거나 결합할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">mergeObjects</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">obj1</span><span class="p">:</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">obj2</span><span class="p">:</span> <span class="nx">U</span><span class="p">):</span> <span class="nx">T</span> <span class="o">&amp;</span> <span class="nx">U</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">...</span><span class="nx">obj1</span><span class="p">,</span> <span class="p">...</span><span class="nx">obj2</span> <span class="p">};</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">merged</span> <span class="o">=</span> <span class="nx">mergeObjects</span><span class="p">({</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">John</span><span class="dl">"</span> <span class="p">},</span> <span class="p">{</span> <span class="na">age</span><span class="p">:</span> <span class="mi">30</span> <span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">merged</span><span class="p">);</span>    <span class="c1">// { name: "John", age: 30 }</span>
</code></pre></div></div>

<hr />

<h2 id="원시-type의-intersection--가능하지만-쓸모없음">원시 Type의 Intersection : 가능하지만 쓸모없음</h2>

<ul>
  <li>intersection type을 사용한 원시 type(primitive type)의 결합은 기술적으로 가능하긴 하지만, 유용하지 않습니다.
    <ul>
      <li>intersection type은 주로 여러 객체 type을 결합하여 새로운 type을 생성하는 데 사용됩니다.
        <ul>
          <li>객체 type이 다양한 속성과 method를 갖고 있기 때문에, 여러 type의 속성과 method를 결합하여 더 복합적인 객체 type을 만들 수 있기 때문입니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>원시 type의 intersection을 생성하면, 그 결과는 결합된 모든 type의 특성을 만족하는 type이어야 합니다.</li>
  <li>서로 다른 원시 type 간에는 공통된 특성이 없기 때문에, 원시 type 간의 결합은 실질적으로 의미가 없습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ImpossibleType</span> <span class="o">=</span> <span class="kr">string</span> <span class="o">&amp;</span> <span class="kr">number</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">ImpossibleType</code>은 <code class="highlighter-rouge">string</code> type과 <code class="highlighter-rouge">number</code> type의 공통된 특성을 갖는 type이어야 합니다.</li>
  <li>실제로 <code class="highlighter-rouge">string</code>과 <code class="highlighter-rouge">number</code>는 서로 호환되지 않는 type이므로, 이러한 type의 intersection은 어떠한 값도 만족시킬 수 없는 type이 됩니다.</li>
</ul>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-combined-type---union-여러-type-허용하기">TypeScript Combined Type - Union (여러 Type 허용하기)</h1>

<h2 id="union-type---여러-type-중-하나-선택하기">Union Type - 여러 Type 중 하나 선택하기</h2>

<ul>
  <li>union type은 <strong>서로 다른 여러 type 중 하나가 될 수 있는 값을 정의</strong>할 때 사용하는 고급 type입니다.
    <ul>
      <li><code class="highlighter-rouge">|</code> 연산자를 사용하여 정의되며, 이는 변수나 매개 변수가 지정된 type 중 하나의 type을 가질 수 있음을 의미합니다.</li>
    </ul>
  </li>
  <li>union type을 사용하면, 변수나 함수 매개 변수가 여러 다른 type 중 하나를 가질 수 있습니다.
    <ul>
      <li>e.g., <code class="highlighter-rouge">string | number</code> union type은 해당 변수나 매개 변수가 문자열 또는 숫자일 수 있음을 의미합니다.</li>
    </ul>
  </li>
  <li>union type은 program이 <strong>다양한 type의 값들을 유연하게 처리할 수 있게</strong> 하며, 다양한 상황에서 유용하게 사용됩니다.
    <ul>
      <li>e.g., 함수가 여러 type의 인자를 받아들일 수 있도록 하거나, 함수가 여러 type 중 하나의 type을 반환할 수 있도록 할 때 union type을 사용할 수 있습니다.</li>
    </ul>
  </li>
  <li><strong><code class="highlighter-rouge">|</code> 연산자</strong>로 여러 type들을 연결하여 union type을 정의합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">logMessage</span><span class="p">(</span><span class="nx">message</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">logMessage</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello, TypeScript!</span><span class="dl">"</span><span class="p">);</span>    <span class="c1">// 문자열을 인자로 전달</span>
<span class="nx">logMessage</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>    <span class="c1">// 숫자를 인자로 전달</span>
</code></pre></div></div>

<h3 id="union-type과-type-guard">Union Type과 Type Guard</h3>

<ul>
  <li>union type을 사용하면 변수가 여러 type 중 하나의 type을 가질 수 있음을 의미합니다.</li>
  <li>이렇게 여러 type 중 하나를 가질 수 있는 변수에 대해서는, 해당 변수가 실제로 어떤 type을 가지는지를 정확히 알아내고, 그에 맞는 method나 속성에 접근하기 위해 type guard가 필요합니다.</li>
  <li><strong>union type과 type guard를 함께 사용</strong>하면 다양한 type을 가진 변수들을 더 안전하게 처리할 수 있습니다.</li>
</ul>

<h4 id="union-type과-typeof-type-guard">Union Type과 <code class="highlighter-rouge">typeof</code> Type Guard</h4>

<ul>
  <li><code class="highlighter-rouge">typeof</code> 연산자는 변수의 type을 검사하는 데 사용됩니다.</li>
  <li><code class="highlighter-rouge">typeof</code> type guard는 주로 기본 type(<code class="highlighter-rouge">string</code>, <code class="highlighter-rouge">number</code>, <code class="highlighter-rouge">boolean</code>, <code class="highlighter-rouge">undefined</code>, <code class="highlighter-rouge">object</code>, <code class="highlighter-rouge">function</code>)을 검사하는 데 사용됩니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">combine</span><span class="p">(</span><span class="nx">input1</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">input2</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">input1</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">input2</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// input1과 input2는 문자열로 취급됨</span>
        <span class="k">return</span> <span class="nx">input1</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span> <span class="o">+</span> <span class="nx">input2</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>    <span class="c1">// 문자열 결합</span>
    <span class="p">}</span>
    <span class="c1">// input1과 input2는 숫자로 취급됨</span>
    <span class="k">return</span> <span class="nx">input1</span> <span class="o">+</span> <span class="nx">input2</span><span class="p">;</span>    <span class="c1">// 숫자 합산</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">{</span> <span class="na">key</span><span class="p">:</span> <span class="dl">'</span><span class="s1">value</span><span class="dl">'</span> <span class="p">};</span>

<span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">data</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">object</span><span class="dl">"</span> <span class="o">&amp;&amp;</span> <span class="nx">data</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">data는 객체입니다.</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Combined</span> <span class="o">=</span> <span class="nx">object</span> <span class="o">|</span> <span class="kd">function</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="nx">Combined</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">object</span><span class="dl">"</span> <span class="o">&amp;&amp;</span> <span class="nx">value</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 객체 관련 처리</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">function</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 함수 관련 처리</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="union-type과-instanceof-type-guard">Union Type과 <code class="highlighter-rouge">instanceof</code> Type Guard</h4>

<ul>
  <li><code class="highlighter-rouge">instanceof</code> 연산자는 객체의 type을 검사(class의 instance인지 여부를 판단)하는 데 사용됩니다.</li>
  <li><code class="highlighter-rouge">instanceof</code> type guard는 union type이 class instance를 포함할 때 사용됩니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Bird</span> <span class="p">{</span>
    <span class="nx">fly</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">bird flies</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Fish</span> <span class="p">{</span>
    <span class="nx">swim</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">fish swims</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">move</span><span class="p">(</span><span class="nx">pet</span><span class="p">:</span> <span class="nx">Bird</span> <span class="o">|</span> <span class="nx">Fish</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">pet</span> <span class="k">instanceof</span> <span class="nx">Bird</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">pet</span><span class="p">.</span><span class="nx">fly</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">pet</span><span class="p">.</span><span class="nx">swim</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="union-type과-사용자-정의-type-guard">Union Type과 사용자 정의 Type Guard</h4>

<ul>
  <li>사용자 정의 type guard는 더 복잡한 type 검사 logic을 구현할 때 사용됩니다.
    <ul>
      <li>사용자 정의 type guard는 <code class="highlighter-rouge">parameter is Type</code> 형태의 type 예측을 반환하는 함수입니다.</li>
    </ul>
  </li>
  <li>사용자 정의 type guard 함수를 통해 특정 type이 확실한 경우에만 해당 type의 속성이나 method에 접근할 수 있도록 합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Fish와 Bird interface 정의</span>
<span class="kr">interface</span> <span class="nx">Fish</span> <span class="p">{</span>
    <span class="nl">swim</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">interface</span> <span class="nx">Bird</span> <span class="p">{</span>
    <span class="nl">fly</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">isFish</span><span class="p">(</span><span class="nx">pet</span><span class="p">:</span> <span class="nx">Fish</span> <span class="o">|</span> <span class="nx">Bird</span><span class="p">):</span> <span class="nx">pet</span> <span class="k">is</span> <span class="nx">Fish</span> <span class="p">{</span>
    <span class="c1">// Fish type의 객체인지 여부를 판단하는 logic</span>
    <span class="k">return</span> <span class="p">(</span><span class="nx">pet</span> <span class="k">as</span> <span class="nx">Fish</span><span class="p">).</span><span class="nx">swim</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">pet</span><span class="p">:</span> <span class="nx">Fish</span> <span class="o">|</span> <span class="nx">Bird</span> <span class="o">=</span> <span class="cm">/* Fish 또는 Bird type의 객체 */</span><span class="p">;</span>

<span class="c1">// 사용자 정의 type guard를 사용하여 type을 좁힘</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">isFish</span><span class="p">(</span><span class="nx">pet</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">pet</span><span class="p">.</span><span class="nx">swim</span><span class="p">();</span>    <span class="c1">// pet이 Fish로 취급됨</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">pet</span><span class="p">.</span><span class="nx">fly</span><span class="p">();</span>    <span class="c1">// pet이 Bird로 취급됨</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="다양한-조합의-union-type">다양한 조합의 Union Type</h2>

<ul>
  <li>union type 자체는 특정 “종류”가 있는 것이 아니라, 필요에 따라 어떤 type들을 조합해 사용할 수 있는지에 대한 개념입니다.
    <ul>
      <li>즉, union type의 “종류”는 개발자가 정의하는 type들의 조합에 의해 결정됩니다.</li>
    </ul>
  </li>
  <li>union type을 사용하면 다양한 type의 조합을 생성할 수 있습니다.</li>
</ul>

<h3 id="기본-type-조합">기본 Type 조합</h3>

<ul>
  <li>기본적인 type(<code class="highlighter-rouge">string</code>, <code class="highlighter-rouge">number</code>, <code class="highlighter-rouge">boolean</code> 등)을 조합하여 사용할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">value</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">;</span>
<span class="nx">value</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">value</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>    <span class="c1">// 유효</span>
</code></pre></div></div>

<h3 id="literal-type-조합">Literal Type 조합</h3>

<ul>
  <li>literal type(특정 문자열, 숫자 등의 literal)을 union으로 조합하여, 제한된 값을 갖는 type을 정의할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Status</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">success</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">failure</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">pending</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>literal type을 조합한 union type을 ‘literal union type’이라고 부릅니다.</li>
</ul>

<h4 id="literal-union-type">Literal Union Type</h4>

<ul>
  <li>literal union type은 여러 literal type(주로 문자열 또는 숫자)을 <code class="highlighter-rouge">|</code> 연산자를 사용해 결합한 것입니다.</li>
  <li>이를 통해 변수나 parameter가 특정 값들 중 하나를 가져야 함을 명시적으로 선언할 수 있습니다.
    <ul>
      <li>e.g., 함수가 받을 수 있는 특정 문자열이나 숫자의 집합을 제한하고 싶을 때 유용합니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Direction</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">up</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">down</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">left</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">right</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">move</span><span class="p">(</span><span class="nx">direction</span><span class="p">:</span> <span class="nx">Direction</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="nx">move</span><span class="p">(</span><span class="dl">"</span><span class="s2">up</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">move</span><span class="p">(</span><span class="dl">"</span><span class="s2">forward</span><span class="dl">"</span><span class="p">);</span>    <span class="c1">// Error: Argument of type '"forward"' is not assignable to parameter of type 'Direction'.</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">Direction</code> type은 <code class="highlighter-rouge">"up"</code>, <code class="highlighter-rouge">"down"</code>, <code class="highlighter-rouge">"left"</code>, <code class="highlighter-rouge">"right"</code> 중 하나의 값을 가질 수 있습니다.
    <ul>
      <li>함수 인자 등에 사용하여, type system을 통해 잘못된 값이 할당되는 것을 compile 시점에 방지할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="객체-type-조합">객체 Type 조합</h3>

<ul>
  <li>union type은 객체 type에도 적용될 수 있으며, 이를 통해 함수나 component가 다양한 형태의 객체를 처리할 수 있도록 할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Bird</span> <span class="p">{</span>
  <span class="nx">fly</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Fish</span> <span class="p">{</span>
  <span class="nx">swim</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">pet</span><span class="p">:</span> <span class="nx">Bird</span> <span class="o">|</span> <span class="nx">Fish</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Bird</span> <span class="p">{</span>
    <span class="nl">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bird</span><span class="dl">"</span><span class="p">;</span>
    <span class="nl">flyingSpeed</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Horse</span> <span class="p">{</span>
    <span class="nl">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">horse</span><span class="dl">"</span><span class="p">;</span>
    <span class="nl">runningSpeed</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Animal</span> <span class="o">=</span> <span class="nx">Bird</span> <span class="o">|</span> <span class="nx">Horse</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">moveAnimal</span><span class="p">(</span><span class="nx">animal</span><span class="p">:</span> <span class="nx">Animal</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">speed</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="nx">animal</span><span class="p">.</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="dl">"</span><span class="s2">bird</span><span class="dl">"</span><span class="p">:</span>
            <span class="nx">speed</span> <span class="o">=</span> <span class="nx">animal</span><span class="p">.</span><span class="nx">flyingSpeed</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="dl">"</span><span class="s2">horse</span><span class="dl">"</span><span class="p">:</span>
            <span class="nx">speed</span> <span class="o">=</span> <span class="nx">animal</span><span class="p">.</span><span class="nx">runningSpeed</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Moving at speed:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">speed</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">moveAnimal</span><span class="p">({</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bird</span><span class="dl">"</span><span class="p">,</span> <span class="na">flyingSpeed</span><span class="p">:</span> <span class="mi">10</span> <span class="p">});</span>    <span class="c1">// "Moving at speed: 10"</span>
</code></pre></div></div>

<h4 id="객체-type-조합-주의사항">객체 Type 조합 주의사항</h4>

<ul>
  <li>객체를 union type을 통해서 사용할 때, union type에 속한 모든 type에 공통으로 존재하는 속성에만 접근할 수 있습니다.</li>
  <li>만약 공통 속성이 없다면, type guard를 사용하여 각 type에 맞는 처리를 해야 합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Bird</span> <span class="p">{</span>
    <span class="nx">fly</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
    <span class="nx">layEggs</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Fish</span> <span class="p">{</span>
    <span class="nx">swim</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
    <span class="nx">layEggs</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Pet</span> <span class="o">=</span> <span class="nx">Fish</span> <span class="o">|</span> <span class="nx">Bird</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">getPet</span><span class="p">():</span> <span class="nx">Pet</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">pet</span> <span class="o">=</span> <span class="nx">getPet</span><span class="p">();</span>
<span class="nx">pet</span><span class="p">.</span><span class="nx">layEggs</span><span class="p">();</span>    <span class="c1">// OK: 모든 Pet은 layEggs method를 가지고 있음</span>
<span class="nx">pet</span><span class="p">.</span><span class="nx">swim</span><span class="p">();</span>    <span class="c1">// Error: union type에서는 공통된 속성만 바로 접근할 수 있음</span>
</code></pre></div></div>

<h3 id="배열과-tuple의-조합">배열과 Tuple의 조합</h3>

<ul>
  <li>배열(array)이나 tuple type을 union으로 조합할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">arr</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">|</span> <span class="kr">string</span><span class="p">[];</span>
<span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">one</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">two</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">three</span><span class="dl">"</span><span class="p">];</span>
</code></pre></div></div>

<h3 id="함수-type-조합">함수 Type 조합</h3>

<ul>
  <li>함수 signature(함수의 매개 변수와 반환 type을 정의한 것)를 union으로 조합할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">myFunction</span><span class="p">:</span> <span class="p">((</span><span class="nx">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">number</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="nx">b</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">string</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="고급-type-조합">고급 Type 조합</h3>

<ul>
  <li>generic type, 조건부(conditional) type 등과 같은 고급(advanced) type과 함께 union type을 사용할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Container</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="o">|</span> <span class="nx">T</span><span class="p">[];</span>
</code></pre></div></div>

<hr />

<h2 id="union-type-활용하기">Union Type 활용하기</h2>

<h3 id="mapped-type에서의-union-type">Mapped Type에서의 Union Type</h3>

<ul>
  <li>mapped type을 사용하여 union type을 기반으로 새로운 type을 동적으로 생성할 수 있습니다.</li>
  <li>이 방법은 union type의 각 member를 변환하거나 수정하여 새로운 type을 생성할 때 유용합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Keys</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">firstName</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">lastName</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">type</span> <span class="nx">PersonRecord</span> <span class="o">=</span> <span class="nb">Record</span><span class="o">&lt;</span><span class="nx">Keys</span><span class="p">,</span> <span class="kr">string</span><span class="o">&gt;</span><span class="p">;</span>
<span class="c1">// PersonRecord type은 { firstName: string, lastName: string } type과 동일함</span>
</code></pre></div></div>

<h3 id="오류-처리에서의-union-type">오류 처리에서의 Union Type</h3>

<ul>
  <li>함수가 여러 type의 error를 반환할 수 있을 때, union type은 각기 다른 error type들을 하나의 type으로 표현하는 데 사용될 수 있습니다.</li>
  <li>이를 통해 오류 처리 logic을 보다 명확하게 구성할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">NetworkError</span> <span class="o">=</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">network</span><span class="dl">"</span><span class="p">;</span> <span class="nl">status</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span> <span class="nl">message</span><span class="p">:</span> <span class="kr">string</span> <span class="p">};</span>
<span class="kd">type</span> <span class="nx">TimeoutError</span> <span class="o">=</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">timeout</span><span class="dl">"</span><span class="p">;</span> <span class="nl">timeout</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span> <span class="nl">message</span><span class="p">:</span> <span class="kr">string</span> <span class="p">};</span>

<span class="c1">// network 요청을 simulation하는 함수</span>
<span class="kd">function</span> <span class="nx">fetchWithTimeout</span><span class="p">(</span><span class="nx">url</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nx">NetworkError</span> <span class="o">|</span> <span class="nx">TimeoutError</span> <span class="p">{</span>
    <span class="c1">// 예제를 단순화하기 위해, 무작위로 error type을 선택</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// network error simulation</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">network</span><span class="dl">"</span><span class="p">,</span>
            <span class="na">status</span><span class="p">:</span> <span class="mi">404</span><span class="p">,</span>
            <span class="na">message</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Not Found</span><span class="dl">"</span>
        <span class="p">};</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// timeout error simulation</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">timeout</span><span class="dl">"</span><span class="p">,</span>
            <span class="na">timeout</span><span class="p">:</span> <span class="mi">5000</span><span class="p">,</span>
            <span class="na">message</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Request timed out</span><span class="dl">"</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// fetchWithTimeout 함수 사용</span>
<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">fetchWithTimeout</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://example.com</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// error type에 따라 다른 처리를 수행</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">network</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Network Error: status code </span><span class="p">${</span><span class="nx">result</span><span class="p">.</span><span class="nx">status</span><span class="p">}</span><span class="s2">, Message: </span><span class="p">${</span><span class="nx">result</span><span class="p">.</span><span class="nx">message</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`TimeOut Error: timeout </span><span class="p">${</span><span class="nx">result</span><span class="p">.</span><span class="nx">timeout</span><span class="p">}</span><span class="s2">ms, Message: </span><span class="p">${</span><span class="nx">result</span><span class="p">.</span><span class="nx">message</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="함수-overloading에서의-union-type">함수 Overloading에서의 Union Type</h3>

<ul>
  <li>함수 overloading은 함수가 다양한 type의 인자를 받아, 각 type에 따라 다른 동작을 할 수 있도록 하는 기능입니다.</li>
  <li>union type은 함수 overloading을 구현할 때, 인자나 반환 type의 다양성을 제공하는 데 유용합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">padLeft</span><span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">padding</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">padding</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">padding</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)</span> <span class="o">+</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">padding</span> <span class="o">+</span> <span class="nx">value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="조건부-type에서의-union-type">조건부 Type에서의 Union Type</h3>

<ul>
  <li>조건부 type(conditional type)은 입력된 type에 따라 다른 type을 반환할 수 있도록 하는 TypeScript 고급 기능입니다.</li>
  <li>union type과 결합하면, 더 동적이고 유연한 type 변환을 정의할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Wrapped</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kd">extends</span> <span class="nx">infer</span> <span class="nx">U</span><span class="p">[]</span> <span class="p">?</span> <span class="nx">U</span> <span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
<span class="kd">type</span> <span class="nx">Unwrapped</span> <span class="o">=</span> <span class="nx">Wrapped</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">[]</span> <span class="o">|</span> <span class="kr">number</span><span class="o">&gt;</span><span class="p">;</span>    <span class="c1">// string | number</span>
</code></pre></div></div>

<h3 id="react-component와-props에서의-union-type">React Component와 Props에서의 union type</h3>

<ul>
  <li>React에서 union type은 다양한 종류의 props를 받을 수 있는 component를 정의할 때 유용합니다.</li>
  <li>이를 통해 단일 component가 다양한 형태의 data를 처리할 수 있도록 할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">ImageProps</span> <span class="p">{</span>
    <span class="nl">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">image</span><span class="dl">"</span><span class="p">;</span>
    <span class="nl">src</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">alt</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">TextProps</span> <span class="p">{</span>
    <span class="nl">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">text</span><span class="dl">"</span><span class="p">;</span>
    <span class="nl">text</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Props</span> <span class="o">=</span> <span class="nx">ImageProps</span> <span class="o">|</span> <span class="nx">TextProps</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Content</span><span class="p">(</span><span class="nx">props</span><span class="p">:</span> <span class="nx">Props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">props</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">image</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">&lt;</span><span class="nx">img</span> <span class="nx">src</span><span class="o">=</span><span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">src</span><span class="p">}</span> <span class="nx">alt</span><span class="o">=</span><span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">alt</span><span class="p">}</span> <span class="sr">/&gt;</span><span class="err">;
</span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">text</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/p&gt;</span><span class="err">;
</span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="discriminated-union-pattern">Discriminated Union Pattern</h2>

<ul>
  <li>discriminated union(또는 tagged union) pattern은 TypeScript에서 union type을 사용하여 type 안전성을 높이는 design pattern입니다.
    <ul>
      <li>discriminated union pattern을 사용하면 compile 시점에 각 type을 정확히 구분할 수 있어, type 관련 오류를 방지할 수 있습니다.</li>
      <li>discriminator(type 구분 값)를 통해 각 type의 목적과 사용 방법이 명확해져, code 가독성이 좋아집니다.</li>
      <li>다양한 type을 안전하게 처리하면서도, 각 type에 대한 구체적인 구현을 유연하게 관리할 수 있습니다.</li>
    </ul>
  </li>
  <li>이 pattern은 union type 내의 각 type이 공통된 property(discriminator)를 가지고 있으며, 이 discriminator를 사용하여 compile time에 type을 구분할 수 있게 합니다.
    <ul>
      <li>서로 다른 여러 type을 하나의 union type으로 결합할 때, 각 type을 구분할 수 있는 공통 속성(discriminator)을 포함시킵니다.</li>
      <li>‘discriminator’는 각각의 type을 명확하게 식별할 수 있게 하는 literal type의 property이며, ‘tag’라고도 불립니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Circle</span> <span class="p">{</span>
    <span class="nl">kind</span><span class="p">:</span> <span class="dl">"</span><span class="s2">circle</span><span class="dl">"</span><span class="p">;</span>
    <span class="nl">radius</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Square</span> <span class="p">{</span>
    <span class="nl">kind</span><span class="p">:</span> <span class="dl">"</span><span class="s2">square</span><span class="dl">"</span><span class="p">;</span>
    <span class="nl">sideLength</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Shape</span> <span class="o">=</span> <span class="nx">Circle</span> <span class="o">|</span> <span class="nx">Square</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">getArea</span><span class="p">(</span><span class="nx">shape</span><span class="p">:</span> <span class="nx">Shape</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="nx">shape</span><span class="p">.</span><span class="nx">kind</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="dl">"</span><span class="s2">circle</span><span class="dl">"</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">radius</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">case</span> <span class="dl">"</span><span class="s2">square</span><span class="dl">"</span><span class="p">:</span>
            <span class="k">return</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">sideLength</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>discriminated union pattern을 적용하기 위해 3가지 단계가 필요합니다.</li>
</ul>

<ol>
  <li>discriminator(tag) 정의 : union에 속한 각 type을 구별할 수 있는 literal type의 고유한 속성(discriminator)을 정의합니다.
    <ul>
      <li><code class="highlighter-rouge">Circle</code>과 <code class="highlighter-rouge">Square</code> 두 type은 <code class="highlighter-rouge">kind</code>라는 discriminator를 포함하고 있으며, 각각 <code class="highlighter-rouge">"circle"</code>과 <code class="highlighter-rouge">"square"</code>라는 고유한 값을 가집니다.</li>
    </ul>
  </li>
  <li>union type 정의 : discriminator를 포함한 type들을 union으로 결합합니다.
    <ul>
      <li><code class="highlighter-rouge">Circle</code>과 <code class="highlighter-rouge">Square</code> 두 type을 결합하여 <code class="highlighter-rouge">Shape</code> union type을 정의합니다.</li>
    </ul>
  </li>
  <li>type guard를 이용한 type 구분 : 함수 내에서 type의 discriminator를 검사하여, 각 type에 맞는 적절한 처리를 수행합니다.
    <ul>
      <li><code class="highlighter-rouge">getArea</code> 함수는 <code class="highlighter-rouge">Shape</code> type의 객체를 인자로 받고, 인자의 <code class="highlighter-rouge">kind</code> 속성을 검사하여 적절한 type의 면적 계산식을 적용합니다.</li>
    </ul>
  </li>
</ol>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-advanced-type-고급-type">TypeScript Advanced Type (고급 Type)</h1>

<h2 id="고급-type--typescript의-고급-type-system">고급 Type : TypeScript의 고급 Type System</h2>

<ul>
  <li>TypeScript의 고급 type system은 code의 재사용성, 유지보수성, 그리고 type 안전성을 향상시키는 다양한 기능을 제공합니다.</li>
  <li>고급 type에는 generic type, utility type, conditional type, mapped type이 포함됩니다.</li>
  <li>각각의 type은 TypeScript에서 보다 복잡한 type 관계를 표현하고 다루기 위한 강력한 도구를 제공합니다.</li>
</ul>

<h3 id="generic-type-1">Generic Type</h3>

<ul>
  <li>generic type은 <strong>type을 parameter처럼 사용</strong>하여, 다양한 type에 대해 작동할 수 있는 component(함수, class, interface 등)를 생성할 수 있게 해줍니다.</li>
  <li>이를 통해 code의 재사용성을 높이며, type 안전성을 유지할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">identity</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">arg</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">arg</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">identity</code> 함수는 어떤 type의 값이든 받아 동일한 type의 값을 반환합니다.</li>
  <li>generic을 사용함으로써, 이 함수는 다양한 type에 대해 유연하게 사용될 수 있습니다.</li>
</ul>

<h3 id="utility-type">Utility Type</h3>

<ul>
  <li>TypeScript는 <strong>기존 type을 변환하여 새로운 type을 생성</strong>하는 데 도움을 주는 <strong>여러 내장(built-in) utility type</strong>을 제공합니다.</li>
  <li>이는 code의 중복을 줄이고, type 변환의 편의성을 향상시킵니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">PartialPoint</span> <span class="o">=</span> <span class="nb">Partial</span><span class="o">&lt;</span><span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span> <span class="nl">y</span><span class="p">:</span> <span class="kr">number</span> <span class="p">}</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">Partial</code> utility type은 모든 property를 선택적으로 만듭니다.</li>
  <li><code class="highlighter-rouge">PartialPoint</code> type은 <code class="highlighter-rouge">x</code>와 <code class="highlighter-rouge">y</code> property가 모두 선택적인 새로운 type입니다.</li>
</ul>

<h3 id="conditional-type">Conditional Type</h3>

<ul>
  <li>conditional(조건부) type은 <strong>type의 조건부 logic을 표현</strong>할 수 있게 해주며, <strong>입력된 type에 따라 다른 type을 반환</strong>할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">IsNumber</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kd">extends</span> <span class="kr">number</span> <span class="p">?</span> <span class="dl">"</span><span class="s2">yes</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">no</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">IsNumber</code> type은 <code class="highlighter-rouge">T</code>가 <code class="highlighter-rouge">number</code> type에 할당 가능한 경우 “yes” type을, 그렇지 않은 경우 “no” type을 반환합니다.</li>
</ul>

<h3 id="mapped-type">Mapped Type</h3>

<ul>
  <li>mapped type은 <strong>기존 type의 property를 반복하여 새로운 type을 생성하거나 변형</strong>할 수 있게 해줍니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ReadonlyPoint</span> <span class="o">=</span> <span class="nb">Readonly</span><span class="o">&lt;</span><span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span> <span class="nl">y</span><span class="p">:</span> <span class="kr">number</span> <span class="p">}</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">Readonly</code> mapped type은 모든 property를 읽기 전용(readonly)으로 만듭니다.</li>
  <li><code class="highlighter-rouge">ReadonlyPoint</code> type은 <code class="highlighter-rouge">x</code>와 <code class="highlighter-rouge">y</code>가 읽기 전용인 새로운 type입니다.</li>
</ul>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-advanced-type---generic-type-type을-parameter처럼-사용하기">TypeScript Advanced Type - Generic Type (Type을 Parameter처럼 사용하기)</h1>

<h2 id="generic-type--type을-parameter처럼-사용하기">Generic Type : Type을 Parameter처럼 사용하기</h2>

<ul>
  <li>generic type은 <strong>type을 parameter처럼 사용</strong>하여, 다양한 type에 대해 작동할 수 있는 함수, class, interface 등을 생성할 수 있게 해주는 기능입니다.
    <ul>
      <li>generic을 사용함으로써 type 안전성을 유지하면서, code를 재사용 가능하고 유연하게 만들 수 있스빈다.</li>
    </ul>
  </li>
  <li><strong>generic을 사용하면, 하나의 함수나 class가 여러 type에 대해 작동할 수 있게 됩니다.</strong>
    <ul>
      <li>code를 작성할 때 구체적인 type을 명시하는 대신, <strong>type 변수(T)를 사용하여 함수나 class를 정의</strong>합니다.</li>
      <li>type 변수는 함수나 class가 호출되거나 instance를 생성할 때 구체적인 type으로 대체됩니다.</li>
    </ul>
  </li>
</ul>

<h3 id="함수의-generic">함수의 Generic</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">identity</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">arg</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">arg</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">output1</span> <span class="o">=</span> <span class="nx">identity</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">(</span><span class="dl">"</span><span class="s2">myString</span><span class="dl">"</span><span class="p">);</span>    <span class="c1">// output1의 type은 'string'</span>
<span class="kd">let</span> <span class="nx">output2</span> <span class="o">=</span> <span class="nx">identity</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>    <span class="c1">// output2의 type은 'number'</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">identity</code> 함수는 어떤 type의 인자도 받을 수 있고, 받은 인자와 동일한 type으로 값을 반환합니다.
    <ul>
      <li><code class="highlighter-rouge">T</code>는 type 변수로, 함수가 호출될 때 결정됩니다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">identity</code> 함수 호출 시, <code class="highlighter-rouge">&lt;string&gt;</code>, <code class="highlighter-rouge">&lt;number&gt;</code>와 같이 type 인자를 제공하여 <code class="highlighter-rouge">T</code>의 구체적인 type을 지정합니다.
    <ul>
      <li>이를 통해 compiler는 반환 값의 type을 정확히 알 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="interface의-generic">Interface의 Generic</h3>

<ul>
  <li>generic은 interface에도 사용될 수 있으며, 이를 통해 다양한 type을 가질 수 있는 객체를 정의할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">GenericIdentityFn</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">(</span><span class="na">arg</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">identity</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">arg</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">arg</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">myIdentity</span><span class="p">:</span> <span class="nx">GenericIdentityFn</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">identity</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">GenericIdentityFn</code> interface는 generic을 사용하여 정의되었습니다.</li>
  <li><code class="highlighter-rouge">myIdentity</code> 함수는 이 interface의 구현체로, <code class="highlighter-rouge">number</code> type의 인자를 받고 <code class="highlighter-rouge">number</code> type을 반환하는 함수로 지정됩니다.</li>
</ul>

<h3 id="class의-generic">Class의 Generic</h3>

<ul>
  <li>generic은 class 정의에도 사용될 수 있으며, 이를 통해 다양한 type을 가질 수 있는 class instance를 생성할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">GenericNumber</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="na">zeroValue</span><span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
    <span class="nl">add</span><span class="p">:</span> <span class="p">(</span><span class="na">x</span><span class="p">:</span> <span class="nx">T</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">myGenericNumber</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">GenericNumber</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">();</span>
<span class="nx">myGenericNumber</span><span class="p">.</span><span class="nx">zeroValue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">myGenericNumber</span><span class="p">.</span><span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span> <span class="p">};</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">GenericNumber</code> class는 type <code class="highlighter-rouge">T</code>에 대해 generic입니다.</li>
  <li><code class="highlighter-rouge">myGenericNumber</code> instance는 <code class="highlighter-rouge">number</code> type을 사용하여 생성되며, 이로 인해 해당 instance의 <code class="highlighter-rouge">zeroValue</code> property와 <code class="highlighter-rouge">add</code> method는 모두 <code class="highlighter-rouge">number</code> type을 사용하게 됩니다.</li>
</ul>

<hr />

<h2 id="generic-constraint--제약-조건-extends">Generic Constraint : 제약 조건 (<code class="highlighter-rouge">extends</code>)</h2>

<ul>
  <li>generic type을 사용할 때, 특정 property나 method에 접근하고 싶을 수 있습니다.</li>
  <li>이럴 때 generic type에 제약 조건(constraint)을 사용하여, <strong>특정 type이 가져야 할 구조를 명시</strong>할 수 있습니다.</li>
  <li>
    <p>generic type에 제약 조건을 추가하면, <strong>generic type이 특정 속성이나 method를 가지고 있음을 강제</strong>할 수 있습니다.</p>
  </li>
  <li>제약 조건을 통해, 함수나 class 내부에서 generic type에 대해 보다 안전하게 연산을 수행할 수 있습니다.
    <ul>
      <li>e.g., generic type이 특정 interface를 구현하도록 강제할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">Type</span><span class="o">&gt;</span>
</code></pre></div></div>

<ul>
  <li>제약 조건은 <code class="highlighter-rouge">extends</code> keyword를 사용하여 정의합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Lengthwise</span> <span class="p">{</span>
    <span class="nl">length</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">loggingIdentity</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">Lengthwise</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">arg</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arg</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>    <span class="c1">// `.length` property를 안전하게 사용할 수 있음</span>
    <span class="k">return</span> <span class="nx">arg</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="intersection-type으로-제약-조건-추가하기">Intersection Type으로 제약 조건 추가하기</h3>

<ul>
  <li>intersection type(<code class="highlighter-rouge">&amp;</code>)과 함께 generic을 사용하여, 여러 type의 특성을 모두 가진 새로운 type을 생성할 수 있습니다.</li>
  <li>이 방식은 generic type이 여러 interface를 구현하거나, 여러 type의 특성을 조합해야 할 때 유용합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Identifiable</span> <span class="p">{</span>
    <span class="nl">id</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Nameable</span> <span class="p">{</span>
    <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">createItem</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">Identifiable</span> <span class="o">&amp;</span> <span class="nx">Nameable</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">item</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Item </span><span class="p">${</span><span class="nx">item</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2"> has ID: </span><span class="p">${</span><span class="nx">item</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">item</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="generic-default-type-parameter--기본-값">Generic Default Type Parameter : 기본 값</h2>

<ul>
  <li><strong>generic type 기본 값(generic default type parameter)</strong>은 TypeScript에서 <strong>generic을 사용할 때 제공되지 않은 type 인자에 대해, 기본 type을 설정할 수 있게 해주는 기능</strong>입니다.
    <ul>
      <li>generic type 기본 값을 통해 개발자는 generic 함수나 class를 더 유연하게 사용할 수 있으며, <strong>type 인자를 생략했을 때의 동작을 명시적으로 정의</strong>할 수 있습니다.</li>
    </ul>
  </li>
  <li>generic type 기본 값을 사용하면 TypeScript의 type 추론(type inference) 기능이 동작합니다.
    <ul>
      <li>type 인자를 명시적으로 제공하지 않아도, TypeScript compiler는 제공된 값의 type을 기반으로 적절한 type을 추론하거나, 기본 값을 사용하여 type을 결정합니다.</li>
    </ul>
  </li>
  <li>generic type 기본 값은 code를 더욱 간결하고 유연하게 만듭니다.
    <ul>
      <li>type 인자가 생략됐을 때 사용될 type을 명시적으로 지정함으로써, code의 가독성과 이해도를 높일 수 있습니다.</li>
      <li>함수나 class를 호출할 때마다 다른 type을 지정할 수 있는 option을 제공하면서도, 특정 상황에서는 기본 type을 자동으로 사용하게 함으로써 code의 유연성을 향상시킵니다.</li>
      <li>기본 값을 통해 안전하게 type을 지정함으로써, 잘못된 type 사용으로 인한 오류를 줄일 수 있습니다.</li>
    </ul>
  </li>
  <li>generic type 기본 값은 <code class="highlighter-rouge">T = DefaultType</code> 형식을 사용하여 정의됩니다.
    <ul>
      <li><code class="highlighter-rouge">T</code>는 generic type 매개 변수이며, <code class="highlighter-rouge">DefaultType</code>은 해당 매개 변수가 생략됐을 때 사용될 기본 type입니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">createContainer</span><span class="o">&lt;</span><span class="nx">T</span> <span class="o">=</span> <span class="kr">string</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="p">{</span><span class="nl">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">}</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span><span class="nx">value</span><span class="p">};</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">container</span> <span class="o">=</span> <span class="nx">createContainer</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">createContainer</code> 함수는 generic type 매개 변수 <code class="highlighter-rouge">T</code>에 대한 기본 값으로 <code class="highlighter-rouge">string</code>을 사용합니다.</li>
  <li>이는 함수를 호출할 때 type 인자를 명시하지 않아도, 자동으로 <code class="highlighter-rouge">T</code>가 <code class="highlighter-rouge">string</code>으로 설정됨을 의미합니다.</li>
  <li>따라서, <code class="highlighter-rouge">container</code> 변수는 <code class="highlighter-rouge">{value: string}</code> type의 객체를 가지게 됩니다.</li>
</ul>

<h3 id="기본-값이-있는-generic-함수">기본 값이 있는 Generic 함수</h3>

<ul>
  <li>배열을 받아 그 배열의 첫 번째 요소를 반환하는, generic type 기본 값을 사용한 함수입니다.</li>
  <li>type 인자가 제공되지 않은 경우, 기본적으로 <code class="highlighter-rouge">number[]</code> type의 배열을 처리하도록 합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">getFirstElement</span><span class="o">&lt;</span><span class="nx">T</span> <span class="o">=</span> <span class="kr">number</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">arr</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]):</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">firstNumber</span> <span class="o">=</span> <span class="nx">getFirstElement</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]);</span>    <span class="c1">// type 인자를 생략 (기본 값 number 사용)</span>
<span class="kd">const</span> <span class="nx">firstString</span> <span class="o">=</span> <span class="nx">getFirstElement</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">([</span><span class="dl">'</span><span class="s1">apple</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">banana</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">cherry</span><span class="dl">'</span><span class="p">]);</span>    <span class="c1">// type 인자로 string 명시</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">firstNumber</span><span class="p">);</span>    <span class="c1">// 출력: 10</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">firstString</span><span class="p">);</span>    <span class="c1">// 출력: apple</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">getFirstElement</code> 함수는 generic type <code class="highlighter-rouge">T</code>에 대한 기본 값으로 <code class="highlighter-rouge">number</code>를 가집니다.</li>
  <li>따라서 type 인자를 생략하고 숫자 배열을 인자로 전달하면, 함수는 숫자를 반환합니다.</li>
  <li>반면, type 인자로 <code class="highlighter-rouge">string</code>을 명시하면, 문자열 배열을 처리합니다.</li>
</ul>

<h3 id="기본-값이-있는-generic-class">기본 값이 있는 Generic class</h3>

<ul>
  <li>generic type 기본 값을 사용하는, data wrapper class입니다.
    <ul>
      <li>data wrapper class는 data를 저장하고, 저장된 data를 반환하는 기능을 가집니다.</li>
    </ul>
  </li>
  <li>type 인자가 제공되지 않은 경우, 기본적으로 <code class="highlighter-rouge">string</code> type을 다룹니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">DataWrapper</span><span class="o">&lt;</span><span class="nx">T</span> <span class="o">=</span> <span class="kr">string</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">private</span> <span class="na">data</span><span class="p">:</span> <span class="nx">T</span><span class="p">;</span>

    <span class="kd">constructor</span><span class="p">(</span><span class="na">data</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">getData</span><span class="p">():</span> <span class="nx">T</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">stringWrapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DataWrapper</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello, World!</span><span class="dl">'</span><span class="p">);</span>    <span class="c1">// type 인자를 생략 (기본 값 string 사용)</span>
<span class="kd">const</span> <span class="nx">numberWrapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DataWrapper</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">12345</span><span class="p">);</span>    <span class="c1">// type 인자로 number 명시</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">stringWrapper</span><span class="p">.</span><span class="nx">getData</span><span class="p">());</span>    <span class="c1">// 출력: Hello, World!</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">numberWrapper</span><span class="p">.</span><span class="nx">getData</span><span class="p">());</span>    <span class="c1">// 출력: 12345</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">DataWrapper</code> class는 generic type <code class="highlighter-rouge">T</code>에 대한 기본 값으로 <code class="highlighter-rouge">string</code>을 가집니다.</li>
  <li>생성자를 통해 data를 instance에 저장하고, <code class="highlighter-rouge">getData</code> method를 사용하여 저장된 data를 반환합니다.</li>
  <li>type 인자를 생략하면 문자열을 다루는 것으로 간주되며, 명시적으로 다른 type을 지정하면 해당 type의 data를 다룹니다.</li>
</ul>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-advanced-type---utility-type-type을-조작하기-위한-내장-type">TypeScript Advanced Type - Utility Type (Type을 조작하기 위한 내장 Type)</h1>

<h2 id="utility-type-1">Utility Type</h2>

<ul>
  <li>TypeScript의 utility type은 type system 내에서 <strong>type을 효과적으로 재사용하고 조작하기 위해 설계된 built-in(내장) type 집합</strong>입니다.
    <ul>
      <li>개발자가 보다 선언적이고 간결한 방식으로 type을 정의하고, type 조작을 통해 새로운 type을 생성할 수 있게 해줍니다.</li>
    </ul>
  </li>
  <li>utility type은 일반적인 type 변환을 쉽게 수행할 수 있도록, TypeScript에서 기본으로 제공하는 미리 정의된 type 집합을 제공합니다.
    <ul>
      <li>utility type들을 사용하면, 기존 type을 변형하여 새로운 type을 생성하는 등의 작업을 간편하게 할 수 있습니다.
        <ul>
          <li>TypeScript type system의 강력한 type 변환 기능을 활용하여, 복잡한 type 조작을 보다 간편하고 안전하게 수행할 수 있습니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>utility type에는 <code class="highlighter-rouge">Partial</code>, <code class="highlighter-rouge">Readonly</code>, <code class="highlighter-rouge">Record</code>, <code class="highlighter-rouge">Pick</code>, <code class="highlighter-rouge">Omit</code> 등, 특정한 type 변환 작업을 위해 설계된 다양한 type이 있습니다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Utility Type</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">Partial&lt;T&gt;</code></td>
      <td>type <code class="highlighter-rouge">T</code>의 모든 속성을 선택적으로 만듦.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Readonly&lt;T&gt;</code></td>
      <td>type <code class="highlighter-rouge">T</code>의 모든 속성을 읽기 전용으로 만듦.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Record&lt;K,T&gt;</code></td>
      <td>key의 type이 <code class="highlighter-rouge">K</code>이고 값의 type이 <code class="highlighter-rouge">T</code>인 객체 type을 생성함.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Pick&lt;T,K&gt;</code></td>
      <td>type <code class="highlighter-rouge">T</code>에서 속성 <code class="highlighter-rouge">K</code>만을 선택하여 구성된 type을 생성함.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Omit&lt;T,K&gt;</code></td>
      <td>type <code class="highlighter-rouge">T</code>에서 속성 <code class="highlighter-rouge">K</code>를 제외한 type을 생성함.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Exclude&lt;T,U&gt;</code></td>
      <td>type <code class="highlighter-rouge">T</code>에서 <code class="highlighter-rouge">U</code>에 할당할 수 있는 모든 속성을 제외함.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Extract&lt;T,U&gt;</code></td>
      <td>type <code class="highlighter-rouge">T</code>에서 <code class="highlighter-rouge">U</code>에 할당할 수 있는 모든 속성만을 추출함.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">NonNullable&lt;T&gt;</code></td>
      <td>type <code class="highlighter-rouge">T</code>에서 <code class="highlighter-rouge">null</code>과 <code class="highlighter-rouge">undefined</code>를 제외한 type을 생성함.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Parameters&lt;T&gt;</code></td>
      <td>함수 type <code class="highlighter-rouge">T</code>의 매개 변수 type들을 tuple type으로 생성함.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ConstructorParameters&lt;T&gt;</code></td>
      <td>class 생성자 type <code class="highlighter-rouge">T</code>의 매개 변수 type들을 tuple type으로 생성함.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ReturnType&lt;T&gt;</code></td>
      <td>함수 type <code class="highlighter-rouge">T</code>의 반환 type을 생성함.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InstanceType&lt;T&gt;</code></td>
      <td>생성자 함수 type <code class="highlighter-rouge">T</code>의 instance type을 생성함.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Required&lt;T&gt;</code></td>
      <td>type <code class="highlighter-rouge">T</code>의 모든 속성을 필수로 만듦.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ThisParameterType</code></td>
      <td>함수 type의 <code class="highlighter-rouge">this</code> 매개 변수의 type을 추출함. TypeScript 3.2에서 추가됨.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">OmitThisParameter</code></td>
      <td>함수 type에서 <code class="highlighter-rouge">this</code> 매개 변수 type을 제거함. TypeScript 3.0에서 추가됨.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ThisType&lt;T&gt;</code></td>
      <td>객체 literal이나 interface에서 <code class="highlighter-rouge">this</code>의 type을 지정함. TypeScript 2.0에서 추가됨. <code class="highlighter-rouge">--noImplicitThis</code> flag 필요.</td>
    </tr>
  </tbody>
</table>

<h3 id="utility-type을-사용하는-이유">Utility Type을 사용하는 이유</h3>

<ol>
  <li><strong>type 안전성 향상</strong> : utility type을 사용함으로써 개발자는 기존 type의 구조를 유지하면서, 특정 속성을 수정하거나 추가하는 등의 type 조작을 안전하게 수행할 수 있습니다.
    <ul>
      <li>code 전반에 걸쳐 일관된 type 안전성을 보장합니다.</li>
    </ul>
  </li>
  <li><strong>code 재사용성 증대</strong> : utility type을 활용하면, 기존 type을 기반으로 새로운 type을 쉽게 생성하고 조작할 수 있습니다.
    <ul>
      <li>비슷한 type pattern이 반복될 때 code 중복을 줄이고, 재사용성을 높이는 데 도움이 됩니다.</li>
    </ul>
  </li>
  <li><strong>개발 생산성 향상</strong> : utility type을 사용하면 복잡한 type 조작을 간단한 선언으로 해결할 수 있어, 개발 과정이 간소화됩니다.
    <ul>
      <li>개발자가 보다 신속하게 type-safe한 code를 작성할 수 있게 해주며, 결과적으로 생산성을 증대시킵니다.</li>
    </ul>
  </li>
  <li><strong>유연성과 확장성 제공</strong> : utility type들은 다양한 type 조작을 위한 기능을 제공하여, 변경에 유연하게 대처할 수 있게 합니다.
    <ul>
      <li>project의 요구 사항이 변경되어 type을 수정하거나 확장해야 할 때 유연하게 대응할 수 있도록 해줍니다.</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="utility-type의-종류">Utility Type의 종류</h2>

<h3 id="partialt"><code class="highlighter-rouge">Partial&lt;T&gt;</code></h3>

<ul>
  <li>type <code class="highlighter-rouge">T</code>의 모든 속성을 선택적으로 만듭니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Todo</span> <span class="p">{</span>
    <span class="nl">title</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">description</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">updateTodo</span><span class="p">:</span> <span class="nb">Partial</span><span class="o">&lt;</span><span class="nx">Todo</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="na">title</span><span class="p">:</span> <span class="dl">"</span><span class="s2">new title</span><span class="dl">"</span> <span class="p">};</span>
</code></pre></div></div>

<h3 id="readonlyt"><code class="highlighter-rouge">Readonly&lt;T&gt;</code></h3>

<ul>
  <li>type <code class="highlighter-rouge">T</code>의 모든 속성을 읽기 전용(readonly)으로 만듭니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Todo</span> <span class="p">{</span>
    <span class="nl">title</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">myTodo</span><span class="p">:</span> <span class="nb">Readonly</span><span class="o">&lt;</span><span class="nx">Todo</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="na">title</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Readonly title</span><span class="dl">"</span> <span class="p">};</span>
<span class="nx">myTodo</span><span class="p">.</span><span class="nx">title</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">new title</span><span class="dl">"</span><span class="p">;</span>        <span class="c1">// 오류: 'title'은 읽기 전용 속성이므로 할당할 수 없습니다.</span>
</code></pre></div></div>

<h3 id="recordk-t"><code class="highlighter-rouge">Record&lt;K, T&gt;</code></h3>

<ul>
  <li>key의 type이 <code class="highlighter-rouge">K</code>이고 값의 type이 <code class="highlighter-rouge">T</code>인 객체 type을 생성합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Page</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">home</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">about</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">contact</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">pageinfo</span><span class="p">:</span> <span class="nb">Record</span><span class="o">&lt;</span><span class="nx">Page</span><span class="p">,</span> <span class="kr">string</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">home</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Welcome</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">about</span><span class="p">:</span> <span class="dl">"</span><span class="s2">About us</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">contact</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Contact us</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="pickt-k"><code class="highlighter-rouge">Pick&lt;T, K&gt;</code></h3>

<ul>
  <li>type <code class="highlighter-rouge">T</code>에서 속성 <code class="highlighter-rouge">K</code>만을 선택하여 구성된 type을 생성합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Todo</span> <span class="p">{</span>
    <span class="nl">title</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">description</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">completed</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">TodoPreview</span> <span class="o">=</span> <span class="nb">Pick</span><span class="o">&lt;</span><span class="nx">Todo</span><span class="p">,</span> <span class="dl">"</span><span class="s2">title</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">completed</span><span class="dl">"</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="omitt-k"><code class="highlighter-rouge">Omit&lt;T, K&gt;</code></h3>

<ul>
  <li>type <code class="highlighter-rouge">T</code>에서 속성 <code class="highlighter-rouge">K</code>를 제외한 type을 생성합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Todo</span> <span class="p">{</span>
    <span class="nl">title</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">description</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">completed</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">TodoPreview</span> <span class="o">=</span> <span class="nx">Omit</span><span class="o">&lt;</span><span class="nx">Todo</span><span class="p">,</span> <span class="dl">"</span><span class="s2">description</span><span class="dl">"</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="excludet-u"><code class="highlighter-rouge">Exclude&lt;T, U&gt;</code></h3>

<ul>
  <li>type <code class="highlighter-rouge">T</code>에서 <code class="highlighter-rouge">U</code>에 할당할 수 있는 모든 속성을 제외합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">T</span> <span class="o">=</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span> <span class="o">|</span> <span class="nx">boolean</span><span class="p">;</span>
<span class="kd">type</span> <span class="nx">TWithoutBoolean</span> <span class="o">=</span> <span class="nx">Exclude</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">boolean</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="extractt-u"><code class="highlighter-rouge">Extract&lt;T, U&gt;</code></h3>

<ul>
  <li>type <code class="highlighter-rouge">T</code>에서 <code class="highlighter-rouge">U</code>에 할당할 수 있는 모든 속성만을 추출합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">T</span> <span class="o">=</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span> <span class="o">|</span> <span class="nx">boolean</span><span class="p">;</span>
<span class="kd">type</span> <span class="nx">TOnlyNumber</span> <span class="o">=</span> <span class="nx">Extract</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="kr">number</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="nonnullablet"><code class="highlighter-rouge">NonNullable&lt;T&gt;</code></h3>

<ul>
  <li>type <code class="highlighter-rouge">T</code>에서 <code class="highlighter-rouge">null</code>과 <code class="highlighter-rouge">undefined</code>를 제외한 type을 생성합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">T</span> <span class="o">=</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">;</span>
<span class="kd">type</span> <span class="nx">NonNullableT</span> <span class="o">=</span> <span class="nx">NonNullable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="parameterst"><code class="highlighter-rouge">Parameters&lt;T&gt;</code></h3>

<ul>
  <li>함수 type <code class="highlighter-rouge">T</code>의 매개 변수 type들을 tuple type으로 생성합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="k">void</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">Params</span> <span class="o">=</span> <span class="nx">Parameters</span><span class="o">&lt;</span><span class="k">typeof</span> <span class="nx">doSomething</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="constructorparameterst"><code class="highlighter-rouge">ConstructorParameters&lt;T&gt;</code></h3>

<ul>
  <li>class 생성자 type <code class="highlighter-rouge">T</code>의 매개 변수 type들을 tuple type으로 생성합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Todo</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="k">public</span> <span class="nx">title</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="k">public</span> <span class="nx">description</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">CtorParams</span> <span class="o">=</span> <span class="nx">ConstructorParameters</span><span class="o">&lt;</span><span class="k">typeof</span> <span class="nx">Todo</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="returntypet"><code class="highlighter-rouge">ReturnType&lt;T&gt;</code></h3>

<ul>
  <li>함수 type <code class="highlighter-rouge">T</code>의 반환 type을 생성합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">getAge</span><span class="p">():</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">30</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Age</span> <span class="o">=</span> <span class="nx">ReturnType</span><span class="o">&lt;</span><span class="k">typeof</span> <span class="nx">getAge</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="instancetypet"><code class="highlighter-rouge">InstanceType&lt;T&gt;</code></h3>

<ul>
  <li>생성자 함수 type <code class="highlighter-rouge">T</code>의 instance type을 생성합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Todo</span> <span class="p">{</span>
    <span class="nl">title</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">title</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">title</span> <span class="o">=</span> <span class="nx">title</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">TodoInstance</span> <span class="o">=</span> <span class="nx">InstanceType</span><span class="o">&lt;</span><span class="k">typeof</span> <span class="nx">Todo</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="requiredt"><code class="highlighter-rouge">Required&lt;T&gt;</code></h3>

<ul>
  <li>type <code class="highlighter-rouge">T</code>의 모든 속성을 필수로 만듭니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Props</span> <span class="p">{</span>
    <span class="nl">a</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">b</span><span class="p">?:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">props</span><span class="p">:</span> <span class="nx">Required</span><span class="o">&lt;</span><span class="nx">Props</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Required</span><span class="dl">"</span> <span class="p">};</span>
</code></pre></div></div>

<h3 id="thisparametertype"><code class="highlighter-rouge">ThisParameterType</code></h3>

<ul>
  <li>함수 type의 <code class="highlighter-rouge">this</code> 매개 변수의 type을 추출합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">toHex</span><span class="p">(</span><span class="k">this</span><span class="p">:</span> <span class="nb">Number</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">toString</span>

<span class="p">(</span><span class="mi">16</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">HexThis</span> <span class="o">=</span> <span class="nx">ThisParameterType</span><span class="o">&lt;</span><span class="k">typeof</span> <span class="nx">toHex</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="omitthisparameter"><code class="highlighter-rouge">OmitThisParameter</code></h3>

<ul>
  <li>함수 type에서 <code class="highlighter-rouge">this</code> 매개 변수 type을 제거합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">toHex</span><span class="p">(</span><span class="k">this</span><span class="p">:</span> <span class="nb">Number</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">fiveToHex</span><span class="p">:</span> <span class="nx">OmitThisParameter</span><span class="o">&lt;</span><span class="k">typeof</span> <span class="nx">toHex</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">toHex</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="thistypet"><code class="highlighter-rouge">ThisType&lt;T&gt;</code></h3>

<ul>
  <li><code class="highlighter-rouge">ThisType&lt;T&gt;</code> type은 객체 literal이나 interface에서 <code class="highlighter-rouge">this</code>의 type을 지정합니다.</li>
  <li>주로 객체 literal의 메소드에서 <code class="highlighter-rouge">this</code>의 type을 명시적으로 선언할 때 사용됩니다.</li>
  <li><code class="highlighter-rouge">ThisType&lt;T&gt;</code>는 TypeScript의 <code class="highlighter-rouge">--noImplicitThis</code> flag가 활성화된 경우에 유용합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ObjectWithThis</span> <span class="o">=</span> <span class="p">{</span> <span class="na">hello</span><span class="p">:</span> <span class="kr">string</span> <span class="p">}</span> <span class="o">&amp;</span> <span class="nx">ThisType</span><span class="o">&lt;</span><span class="p">{</span> <span class="na">world</span><span class="p">:</span> <span class="kr">string</span> <span class="p">}</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">obj</span><span class="p">:</span> <span class="nx">ObjectWithThis</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">hello</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Hello</span><span class="dl">"</span><span class="p">,</span>
    <span class="nx">getWorld</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">world</span><span class="p">;</span>    <span class="c1">// `this`의 type이 { world: string }으로 명시적으로 지정됨</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">ThisType&lt;T&gt;</code>는 직접적인 예제로 설명하기 어렵습니다.</li>
  <li><code class="highlighter-rouge">ThisType&lt;T&gt;</code> type은 주로 mixin이나 고급 객체 구성 pattern에서 사용됩니다.</li>
</ul>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-advanced-type---conditional-type-조건에-따라-type-결정하기">TypeScript Advanced Type - Conditional Type (조건에 따라 Type 결정하기)</h1>

<h2 id="conditional-type--특정-조건에-따라-type-결정하기">Conditional Type : 특정 조건에 따라 Type 결정하기</h2>

<ul>
  <li>조건부(conditional) type은 TypeScript에서 <strong>특정 조건에 따라 type을 결정</strong>할 수 있게 해주는 고급 type system의 기능입니다.
    <ul>
      <li>type의 형태를 동적으로 조작할 수 있어, 복잡한 type 관계를 표현할 때 유용합니다.
        <ul>
          <li>type을 programming 언어의 <code class="highlighter-rouge">if</code> 문처럼 다룰 수 있게 해주어, type의 선택적 사용을 가능하게 합니다.</li>
        </ul>
      </li>
      <li>조건부 type은 TypeScript의 code를 유연하고 재사용 가능하게 만들어줍니다.</li>
    </ul>
  </li>
  <li>조건부 type은 일반적으로 generic type과 함께 사용되며, TypeScript 2.8 version에서 도입되었습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">U</span> <span class="p">?</span> <span class="nx">X</span> <span class="p">:</span> <span class="nx">Y</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">T extends U ? X : Y</code>는 “type <code class="highlighter-rouge">T</code>가 <code class="highlighter-rouge">U</code>에 할당 가능한 경우 type <code class="highlighter-rouge">X</code>를, 그렇지 않은 경우 type <code class="highlighter-rouge">Y</code>를 사용하라”는 의미입니다.
    <ul>
      <li><code class="highlighter-rouge">T</code>와 <code class="highlighter-rouge">U</code>는 type입니다.</li>
      <li><code class="highlighter-rouge">T</code>가 <code class="highlighter-rouge">U</code>에 할당 가능한 경우의 결과 type은 <code class="highlighter-rouge">X</code>가 되고, 그렇지 않은 경우는 <code class="highlighter-rouge">Y</code>가 됩니다.
        <ul>
          <li>“<code class="highlighter-rouge">T</code>가 <code class="highlighter-rouge">U</code>에 할당 가능한 경우”는 “<code class="highlighter-rouge">T</code>가 <code class="highlighter-rouge">U</code>의 하위 type인 경우”를 의미합니다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="조건부-type-사용-예시">조건부 Type 사용 예시</h2>

<h3 id="조건부-type을-사용한-type-filtering">조건부 Type을 사용한 Type Filtering</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">IsString</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kd">extends</span> <span class="kr">string</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">yes</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">no</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">type</span> <span class="nx">A</span> <span class="o">=</span> <span class="nx">IsString</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">;</span>    <span class="c1">// 'yes'</span>
<span class="kd">type</span> <span class="nx">B</span> <span class="o">=</span> <span class="nx">IsString</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">;</span>    <span class="c1">// 'no'</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">IsString</code> type은 generic type <code class="highlighter-rouge">T</code>가 <code class="highlighter-rouge">string</code>에 할당 가능한지를 검사하여, 그 결과에 따라 <code class="highlighter-rouge">'yes'</code> 또는 <code class="highlighter-rouge">'no'</code>라는 literal type을 반환합니다.</li>
</ul>

<h4 id="never-type-filtering"><code class="highlighter-rouge">never</code> Type Filtering</h4>

<ul>
  <li>조건부 type을 사용하여 특정 조건을 만족하는 type만을 추출할 수 있습니다.</li>
  <li><code class="highlighter-rouge">never</code> type은 TypeScript에서 “type 없음”을 나타내므로, 조건에 맞지 않는 type을 filtering할 때 유용하게 사용됩니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">NonNullable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kd">extends</span> <span class="kc">null</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">?</span> <span class="nx">never</span> <span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">NonNullable</code> type은 <code class="highlighter-rouge">null</code>이나 <code class="highlighter-rouge">undefined</code>를 제외한 type을 생성합니다.</li>
</ul>

<h3 id="조건부-type을-사용한-type-추출">조건부 Type을 사용한 Type 추출</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ExtractStringOrNumber</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kd">extends</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span> <span class="p">?</span> <span class="nx">T</span> <span class="p">:</span> <span class="nx">never</span><span class="p">;</span>

<span class="kd">type</span> <span class="nx">C</span> <span class="o">=</span> <span class="nx">ExtractStringOrNumber</span><span class="o">&lt;</span><span class="kr">string</span> <span class="o">|</span> <span class="nx">boolean</span> <span class="o">|</span> <span class="kr">number</span><span class="o">&gt;</span><span class="p">;</span>    <span class="c1">// string | number</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">ExtractStringOrNumber</code> type은 union type <code class="highlighter-rouge">T</code>에서 <code class="highlighter-rouge">string</code> 또는 <code class="highlighter-rouge">number</code> type만을 추출합니다.</li>
  <li><code class="highlighter-rouge">boolean</code> type은 <code class="highlighter-rouge">never</code>로 대체되므로 결과적으로 추출되지 않습니다.</li>
</ul>

<h3 id="조건부-type을-이용한-함수-overloading-단순화">조건부 Type을 이용한 함수 Overloading 단순화</h3>

<ul>
  <li>조건부 type을 사용하면, 복잡한 함수 overloading을 단순화할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ReturnType</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kd">extends</span> <span class="p">(...</span><span class="nx">args</span><span class="p">:</span> <span class="kr">any</span><span class="p">[])</span> <span class="o">=&gt;</span> <span class="nx">infer</span> <span class="nx">R</span> <span class="p">?</span> <span class="nx">R</span> <span class="p">:</span> <span class="nx">T</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">f1</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">f1</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">string</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">f1</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kr">number</span> <span class="o">|</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Test</span> <span class="o">=</span> <span class="nx">ReturnType</span><span class="o">&lt;</span><span class="k">typeof</span> <span class="nx">f1</span><span class="o">&gt;</span><span class="p">;</span>    <span class="c1">// string | number</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">ReturnType</code>은 함수 type에서 반환 type을 추론합니다.</li>
  <li><code class="highlighter-rouge">infer R</code> keyword를 사용하여 반환 type을 <code class="highlighter-rouge">R</code>로 추론하고, 이를 조건부 type의 결과로 사용합니다.</li>
  <li>따라서 <code class="highlighter-rouge">Test</code> type은 <code class="highlighter-rouge">string | number</code> union type이 됩니다.</li>
</ul>

<h3 id="복잡한-조건과-type-추론">복잡한 조건과 Type 추론</h3>

<ul>
  <li><code class="highlighter-rouge">infer</code> keyword를 사용하여 조건부 type 내에서 type을 추론할 수 있습니다.</li>
  <li>이를 통해 함수의 매개 변수 type이나 반환 type 등을 추출하는 등의 고급 type 조작이 가능해집니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">UnpackPromise</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kd">extends</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">infer</span> <span class="nx">U</span><span class="o">&gt;</span> <span class="p">?</span> <span class="nx">U</span> <span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">UnpackPromise</code> type은 <code class="highlighter-rouge">Promise</code>에서 감싸진 type을 추출합니다.
    <ul>
      <li>e.g., <code class="highlighter-rouge">Promise&lt;string&gt;</code>의 경우 <code class="highlighter-rouge">string</code>을 반환합니다.</li>
    </ul>
  </li>
</ul>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript-advanced-type---mapped-type-기존-type으로-새로운-type-생성하기">TypeScript Advanced Type - Mapped Type (기존 Type으로 새로운 Type 생성하기)</h1>

<h2 id="mapped-type-1">Mapped Type</h2>

<ul>
  <li>
    <p>Mapped Type은 TypeScript에서 <strong>기존의 type을 기반으로 새로운 type을 생성하는 방법을 제공</strong>합니다.</p>
  </li>
  <li>
    <p>Mapped Type을 사용하면, <strong>기존 type의 각 속성을 변형하여 새로운 type을 만들 수 있습니다.</strong></p>
    <ul>
      <li>e.g., 속성을 읽기 전용으로 만들거나, 선택적으로 설정하거나, 심지어 속성 이름을 변형하는 등 다양한 용도로 사용될 수 있습니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">MappedType</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">P</span> <span class="k">in</span> <span class="kr">keyof</span> <span class="nx">T</span><span class="p">]:</span> <span class="nx">T</span><span class="p">[</span><span class="nx">P</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">T</code>는 변형을 적용할 기존 type입니다.</li>
  <li><code class="highlighter-rouge">keyof T</code>는 type <code class="highlighter-rouge">T</code>의 모든 속성 key를 union type으로 추출합니다.</li>
  <li><code class="highlighter-rouge">P in keyof T</code>는 <code class="highlighter-rouge">T</code>의 각 속성에 대해 반복(iterate)하며, 각 속성 key <code class="highlighter-rouge">P</code>에 대해 적용할 변형을 정의합니다.</li>
  <li><code class="highlighter-rouge">T[P]</code>는 속성 key <code class="highlighter-rouge">P</code>에 해당하는 type을 나타냅니다.</li>
</ul>

<h3 id="읽기-전용-mapped-type">읽기 전용 Mapped Type</h3>

<ul>
  <li>기존 type의 <strong>모든 속성을 읽기 전용(readonly)으로 만듭니다.</strong></li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
    <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ReadonlyPerson</span> <span class="o">=</span> <span class="p">{</span>
    <span class="k">readonly</span> <span class="p">[</span><span class="nx">P</span> <span class="k">in</span> <span class="kr">keyof</span> <span class="nx">Person</span><span class="p">]:</span> <span class="nx">Person</span><span class="p">[</span><span class="nx">P</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">person</span><span class="p">:</span> <span class="nx">ReadonlyPerson</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">John</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">age</span><span class="p">:</span> <span class="mi">30</span>
<span class="p">};</span>

<span class="nx">person</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Jane</span><span class="dl">"</span><span class="p">;</span>    <span class="c1">// 오류: 'name' 속성은 읽기 전용이므로 할당할 수 없습니다.</span>
</code></pre></div></div>

<h3 id="선택적-속성-mapped-type">선택적 속성 Mapped Type</h3>

<ul>
  <li>기존 type의 <strong>모든 속성을 선택적(optional property)으로 만듭니다.</strong></li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">PartialPerson</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">P</span> <span class="k">in</span> <span class="kr">keyof</span> <span class="nx">Person</span><span class="p">]?:</span> <span class="nx">Person</span><span class="p">[</span><span class="nx">P</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">person</span><span class="p">:</span> <span class="nx">PartialPerson</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">John</span><span class="dl">"</span>    <span class="c1">// 'age' 속성은 선택적이므로 생략 가능</span>
<span class="p">};</span>
</code></pre></div></div>

<hr />

<h2 id="mapped-type-응용--다른-고급-type과-함께-사용하기">Mapped Type 응용 : 다른 고급 Type과 함께 사용하기</h2>

<ul>
  <li>TypeScript에서 mapped type을 활용할 수 있는 방법과 응용 사례는 다양합니다.</li>
</ul>

<h3 id="조건부-type과의-결합">조건부 Type과의 결합</h3>

<ul>
  <li>mapped type은 조건부 type과 결합하여 특정 조건에 따라 type을 다르게 할당할 수 있습니다.
    <ul>
      <li>e.g., 특정 type만 읽기 전용으로 만들고 싶을 때 사용할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ConditionalReadonly</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">P</span> <span class="k">in</span> <span class="kr">keyof</span> <span class="nx">T</span><span class="p">]:</span> <span class="nx">T</span><span class="p">[</span><span class="nx">P</span><span class="p">]</span> <span class="kd">extends</span> <span class="nb">Function</span> <span class="p">?</span> <span class="nx">T</span><span class="p">[</span><span class="nx">P</span><span class="p">]</span> <span class="p">:</span> <span class="nb">Readonly</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">[</span><span class="nx">P</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">T[P]</code>가 <code class="highlighter-rouge">Function</code> type을 상속한다면 그대로 두고, 그렇지 않은 경우에는 <code class="highlighter-rouge">Readonly&lt;T[P]&gt;</code>를 적용합니다.</li>
</ul>

<h3 id="template-literal-type과의-결합">Template Literal Type과의 결합</h3>

<ul>
  <li>mapped type은 template literal type과 결합하여 속성의 이름을 동적으로 생성할 수 있습니다.</li>
  <li>이를 통해 기존 type의 속성을 기반으로 새로운 속성 이름을 생성하는 것이 가능합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 각 속성 이름 앞에 `get`을 붙이고 `Method`를 뒤에 붙여 새로운 메소드 이름 생성</span>
<span class="kd">type</span> <span class="nx">PropertyNames</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">P</span> <span class="k">in</span> <span class="kr">keyof</span> <span class="nx">T</span> <span class="k">as</span> <span class="s2">`get</span><span class="p">${</span><span class="nx">Capitalize</span><span class="o">&lt;</span><span class="kr">string</span> <span class="o">&amp;</span> <span class="nx">P</span><span class="o">&gt;</span><span class="p">}</span><span class="s2">Method`</span><span class="p">]:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">T</span><span class="p">[</span><span class="nx">P</span><span class="p">]</span>
<span class="p">};</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 기존 type의 속성 이름에 접두사 추가</span>
<span class="kd">type</span> <span class="nx">PrefixedPerson</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">P</span> <span class="k">in</span> <span class="kr">keyof</span> <span class="nx">Person</span> <span class="k">as</span> <span class="s2">`prefixed_</span><span class="p">${</span><span class="kr">string</span> <span class="o">&amp;</span> <span class="nx">P</span><span class="p">}</span><span class="s2">`</span><span class="p">]:</span> <span class="nx">Person</span><span class="p">[</span><span class="nx">P</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">person</span><span class="p">:</span> <span class="nx">PrefixedPerson</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">prefixed_name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">John</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">prefixed_age</span><span class="p">:</span> <span class="mi">30</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="utility-type-확장">Utility Type 확장</h3>

<ul>
  <li>mapped type은 기존 utility type을 확장하거나 변형하여 새로운 utility type을 만드는 데 사용될 수 있습니다.
    <ul>
      <li>e.g., <code class="highlighter-rouge">Partial</code>과 <code class="highlighter-rouge">Readonly</code>를 결합한 새로운 utility type을 정의할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">PartialReadonly</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">P</span> <span class="k">in</span> <span class="kr">keyof</span> <span class="nx">T</span><span class="p">]?:</span> <span class="nb">Readonly</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">[</span><span class="nx">P</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">PartialReadonly</code> type은 객체의 모든 속성을 선택적이면서 동시에 읽기 전용으로 만듭니다.</li>
</ul>

<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />

<h1 id="typescript---type-guard-type-좁히기">TypeScript - Type Guard (Type 좁히기)</h1>

<h2 id="type-guard--type-좁히기narrowing">Type Guard : Type 좁히기(Narrowing)</h2>

<ul>
  <li>
    <p>type guard는 특정 scope 내에서 <strong>변수의 type을 보다 구체적으로 좁히기 위해 사용</strong>하는 표현식입니다.</p>
  </li>
  <li>type guard를 사용하면 <strong>특정 조건에서 변수가 특정 type임을 보장</strong>할 수 있으며, 이를 통해 type 안정성을 높이고 runtime error를 줄일 수 있습니다.
    <ul>
      <li>하지만 남용하면 코드의 복잡성이 증가할 수 있기 때문에, 필요한 경우에만 적절히 사용하는 것이 좋습니다.</li>
    </ul>
  </li>
  <li><strong><code class="highlighter-rouge">typeof</code>, <code class="highlighter-rouge">instanceof</code>, <code class="highlighter-rouge">in</code> keyword를 사용한 type guard</strong>는 JavaScript에서 지원하는 기본적인 type과 class에 대해 사용될 수 있으며, 더 복잡한 type이나 interface에 대해서는 <strong>‘사용자 정의 type guard’</strong>를 사용해야 합니다.</li>
</ul>

<hr />

<h2 id="typeof-keyword-type-guard"><code class="highlighter-rouge">typeof</code> Keyword Type Guard</h2>

<ul>
  <li><code class="highlighter-rouge">typeof</code> type guard는 기본적인 JavaScript type 검사(<code class="highlighter-rouge">string</code>, <code class="highlighter-rouge">number</code>, <code class="highlighter-rouge">boolean</code>, <code class="highlighter-rouge">symbol</code>, <code class="highlighter-rouge">undefined</code>, <code class="highlighter-rouge">object</code>, <code class="highlighter-rouge">function</code>)에 사용됩니다.</li>
  <li>변수가 특정 기본 type일 때만 특정 logic을 실행하도록 할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nx">variable</span> <span class="k">typeof</span> <span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 'variable'은 'type' type으로 간주됨</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="typeof-keyword-type-guard-예제"><code class="highlighter-rouge">typeof</code> Keyword Type Guard 예제</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">padLeft</span><span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">padding</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">padding</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">padding</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)</span> <span class="o">+</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">padding</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">padding</span> <span class="o">+</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">`Expected string or number, got '</span><span class="p">${</span><span class="nx">padding</span><span class="p">}</span><span class="s2">'.`</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">padLeft</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello, world</span><span class="dl">"</span><span class="p">,</span> <span class="mi">4</span><span class="p">));</span>    <span class="c1">// "    Hello, world"</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">padLeft</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello, world</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">&gt;&gt;&gt; </span><span class="dl">"</span><span class="p">));</span>    <span class="c1">// "&gt;&gt;&gt; Hello, world"</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">getNumber</span><span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> 
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span> 
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="instanceof-keyword-type-guard"><code class="highlighter-rouge">instanceof</code> Keyword Type Guard</h2>

<ul>
  <li><code class="highlighter-rouge">instanceof</code> type guard는 class의 instance 여부를 검사할 때 사용됩니다.</li>
  <li>변수가 특정 class의 instance인 경우에만 code block을 실행할 수 있습니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nx">instance</span> <span class="k">instanceof</span> <span class="nx">Class</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 'instance'는 'Class' type으로 간주됨</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="instanceof-keyword-type-guard의-예제"><code class="highlighter-rouge">instanceof</code> Keyword Type Guard의 예제</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Bird</span> <span class="p">{</span>
    <span class="nx">fly</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">bird flies</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Fish</span> <span class="p">{</span>
    <span class="nx">swim</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">fish swims</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">move</span><span class="p">(</span><span class="nx">pet</span><span class="p">:</span> <span class="nx">Bird</span> <span class="o">|</span> <span class="nx">Fish</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">pet</span> <span class="k">instanceof</span> <span class="nx">Bird</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">pet</span><span class="p">.</span><span class="nx">fly</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">pet</span> <span class="k">instanceof</span> <span class="nx">Fish</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">pet</span><span class="p">.</span><span class="nx">swim</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">myBird</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Bird</span><span class="p">();</span>
<span class="kd">const</span> <span class="nx">myFish</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Fish</span><span class="p">();</span>

<span class="nx">move</span><span class="p">(</span><span class="nx">myBird</span><span class="p">);</span>    <span class="c1">// bird flies</span>
<span class="nx">move</span><span class="p">(</span><span class="nx">myFish</span><span class="p">);</span>    <span class="c1">// fish swims</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Person</span> <span class="p">{</span>
    <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Animal</span> <span class="p">{</span>
    <span class="nl">type</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="kd">type</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="kd">type</span> <span class="o">=</span> <span class="kd">type</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">printDetails</span><span class="p">(</span><span class="nx">obj</span><span class="p">:</span> <span class="nx">Person</span> <span class="o">|</span> <span class="nx">Animal</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">obj</span> <span class="k">instanceof</span> <span class="nx">Person</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>    <span class="c1">// obj는 Person으로 추론됨</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="kd">type</span><span class="p">);</span>    <span class="c1">// obj는 Animal로 추론됨</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="in-keyword-type-guard"><code class="highlighter-rouge">in</code> Keyword Type Guard</h2>

<ul>
  <li><code class="highlighter-rouge">in</code> type guard는 객체가 특정 속성(property)을 가지고 있는지 여부를 검사할 때 사용됩니다.</li>
  <li>특정 property가 객체 내에 존재하는 경우에만 code를 실행합니다.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="dl">"</span><span class="s2">property</span><span class="dl">"</span> <span class="k">in</span> <span class="nx">object</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 'object'는 이 block 내에서 'property'를 가진 type으로 간주됨</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="in-keyword-type-guard-예제"><code class="highlighter-rouge">in</code> Keyword Type Guard 예제</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Bird</span> <span class="p">{</span>
    <span class="nx">fly</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
    <span class="nx">layEggs</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Fish</span> <span class="p">{</span>
    <span class="nx">swim</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
    <span class="nx">layEggs</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">move</span><span class="p">(</span><span class="nx">pet</span><span class="p">:</span> <span class="nx">Fish</span> <span class="o">|</span> <span class="nx">Bird</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="dl">"</span><span class="s2">swim</span><span class="dl">"</span> <span class="k">in</span> <span class="nx">pet</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">pet</span><span class="p">.</span><span class="nx">swim</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">pet</span><span class="p">.</span><span class="nx">fly</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">pet</span><span class="p">:</span> <span class="nx">Fish</span> <span class="o">=</span> <span class="p">{</span><span class="nx">swim</span><span class="p">()</span> <span class="p">{},</span> <span class="nx">layEggs</span><span class="p">()</span> <span class="p">{}};</span>
<span class="nx">move</span><span class="p">(</span><span class="nx">pet</span><span class="p">);</span>    <span class="c1">// 'pet.swim()'이 호출됨</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Book</span> <span class="p">{</span>
    <span class="nl">id</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">rank</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">OnlineLecture</span> <span class="p">{</span>
    <span class="nl">id</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">url</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">learnCourse</span><span class="p">(</span><span class="nx">material</span><span class="p">:</span> <span class="nx">Book</span> <span class="o">|</span> <span class="nx">OnlineLecture</span><span class="p">)</span> <span class="p">:</span> <span class="kr">number</span> <span class="o">|</span> <span class="kr">string</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">rank</span> <span class="k">in</span> <span class="nx">material</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">material</span><span class="p">.</span><span class="nx">rank</span><span class="p">;</span>    <span class="c1">// material는 Book 추론됨</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">material</span><span class="p">.</span><span class="nx">url</span><span class="p">;</span>    <span class="c1">// obj는 OnlineLecture로 추론됨</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nx">id</span> <span class="k">in</span> <span class="nx">material</span><span class="p">)</span> <span class="p">{</span>
    	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">material</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="사용자-정의-type-guard">사용자 정의 Type Guard</h2>

<ul>
  <li>사용자 정의 type guard(user-defined type guard)는 개발자가 특정 조건을 직접 정의하여 변수의 type을 좁힐 수 있는 기능입니다.
    <ul>
      <li><code class="highlighter-rouge">parameter is Type</code> 형태의 type 예측을 반환하는 함수로 구현합니다.</li>
    </ul>
  </li>
  <li>type을 추론하는 함수(<code class="highlighter-rouge">isType</code>)가 참(<code class="highlighter-rouge">true</code>)을 반환할 때, 변수(<code class="highlighter-rouge">variable</code>)가 특정 type(<code class="highlighter-rouge">Type</code>)임을 compiler에게 알려주는 방식으로 작동합니다.
    <ul>
      <li>함수가 <code class="highlighter-rouge">true</code>를 반환하면 <code class="highlighter-rouge">variable</code>이 <code class="highlighter-rouge">Type</code>이라고 type system(compiler)이 인식합니다.</li>
      <li><code class="highlighter-rouge">variable is Type</code>이 type을 추론(predicate)하는 부분입니다.</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">isType</span><span class="p">(</span><span class="nx">variable</span><span class="p">:</span> <span class="kr">any</span><span class="p">):</span> <span class="nx">variable</span> <span class="k">is</span> <span class="nx">Type</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">result</span><span class="p">:</span> <span class="nx">boolean</span> <span class="o">=</span> <span class="kc">true</span> <span class="o">||</span> <span class="kc">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="사용자-정의-type-guard-예제">사용자 정의 Type Guard 예제</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Bird</span> <span class="p">{</span>
    <span class="nx">fly</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Fish</span> <span class="p">{</span>
    <span class="nx">swim</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 사용자 정의 type guard</span>
<span class="kd">function</span> <span class="nx">isFish</span><span class="p">(</span><span class="nx">pet</span><span class="p">:</span> <span class="nx">Fish</span> <span class="o">|</span> <span class="nx">Bird</span><span class="p">):</span> <span class="nx">pet</span> <span class="k">is</span> <span class="nx">Fish</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="nx">pet</span> <span class="k">as</span> <span class="nx">Fish</span><span class="p">).</span><span class="nx">swim</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 사용 예시</span>
<span class="kd">function</span> <span class="nx">move</span><span class="p">(</span><span class="nx">pet</span><span class="p">:</span> <span class="nx">Fish</span> <span class="o">|</span> <span class="nx">Bird</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">isFish</span><span class="p">(</span><span class="nx">pet</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">pet</span><span class="p">.</span><span class="nx">swim</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">pet</span><span class="p">.</span><span class="nx">fly</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Car</span> <span class="p">{</span>
    <span class="nl">brand</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">speed</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">isCar</span><span class="p">(</span><span class="nx">vehicle</span><span class="p">:</span> <span class="kr">any</span><span class="p">):</span> <span class="nx">vehicle</span> <span class="k">is</span> <span class="nx">Car</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">"</span><span class="s2">brand</span><span class="dl">"</span> <span class="k">in</span> <span class="nx">vehicle</span> <span class="o">&amp;&amp;</span> <span class="dl">"</span><span class="s2">speed</span><span class="dl">"</span> <span class="k">in</span> <span class="nx">vehicle</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">displayVehicleInfo</span><span class="p">(</span><span class="nx">vehicle</span><span class="p">:</span> <span class="nx">Car</span> <span class="o">|</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="kr">string</span> <span class="p">}):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">isCar</span><span class="p">(</span><span class="nx">vehicle</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">vehicle</span><span class="p">.</span><span class="nx">brand</span><span class="p">,</span> <span class="nx">vehicle</span><span class="p">.</span><span class="nx">speed</span><span class="p">);</span>    <span class="c1">// 'vehicle'은 'Car'로 추론됨</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">vehicle</span><span class="p">.</span><span class="kd">type</span><span class="p">);</span>    <span class="c1">// 'vehicle'은 '{ type: string }'으로 추론됨</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="reference-8">Reference</h2>

<ul>
  <li><a href="https://velog.io/@boyeon_jeong/%ED%83%80%EC%9E%85-%EA%B0%80%EB%93%9C">https://velog.io/@boyeon_jeong/%ED%83%80%EC%9E%85-%EA%B0%80%EB%93%9C</a></li>
</ul>



</div>

<div class="relatedPosts">

  
    
    
    
    

    

      
      

      

      

    

      
      

      

      

    

    
  

</div>

    </main>

    <footer>
      <span>
        &copy; <time datetime="2024-03-07 14:41:12 +0900">2024</time> Inela Avdic Hukic. Powered by Jekyll and <a href="#">Rain</a> theme.
      </span>
    </footer>
  </body>
</html>
